{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getProxiedConnection = exports.mapProxyName = void 0;\nconst logging_1 = require(\"./logging\");\nconst constants_1 = require(\"./constants\");\nconst resolver_1 = require(\"./resolver\");\nconst http = require(\"http\");\nconst tls = require(\"tls\");\nconst logging = require(\"./logging\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst url_1 = require(\"url\");\nconst TRACER_NAME = 'proxy';\nfunction trace(text) {\n  logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nfunction getProxyInfo() {\n  let proxyEnv = '';\n  let envVar = '';\n  /* Prefer using 'grpc_proxy'. Fallback on 'http_proxy' if it is not set.\n   * Also prefer using 'https_proxy' with fallback on 'http_proxy'. The\n   * fallback behavior can be removed if there's a demand for it.\n   */\n  if (process.env.grpc_proxy) {\n    envVar = 'grpc_proxy';\n    proxyEnv = process.env.grpc_proxy;\n  } else if (process.env.https_proxy) {\n    envVar = 'https_proxy';\n    proxyEnv = process.env.https_proxy;\n  } else if (process.env.http_proxy) {\n    envVar = 'http_proxy';\n    proxyEnv = process.env.http_proxy;\n  } else {\n    return {};\n  }\n  let proxyUrl;\n  try {\n    proxyUrl = new url_1.URL(proxyEnv);\n  } catch (e) {\n    (0, logging_1.log)(constants_1.LogVerbosity.ERROR, `cannot parse value of \"${envVar}\" env var`);\n    return {};\n  }\n  if (proxyUrl.protocol !== 'http:') {\n    (0, logging_1.log)(constants_1.LogVerbosity.ERROR, `\"${proxyUrl.protocol}\" scheme not supported in proxy URI`);\n    return {};\n  }\n  let userCred = null;\n  if (proxyUrl.username) {\n    if (proxyUrl.password) {\n      (0, logging_1.log)(constants_1.LogVerbosity.INFO, 'userinfo found in proxy URI');\n      userCred = `${proxyUrl.username}:${proxyUrl.password}`;\n    } else {\n      userCred = proxyUrl.username;\n    }\n  }\n  const hostname = proxyUrl.hostname;\n  let port = proxyUrl.port;\n  /* The proxy URL uses the scheme \"http:\", which has a default port number of\n   * 80. We need to set that explicitly here if it is omitted because otherwise\n   * it will use gRPC's default port 443. */\n  if (port === '') {\n    port = '80';\n  }\n  const result = {\n    address: `${hostname}:${port}`\n  };\n  if (userCred) {\n    result.creds = userCred;\n  }\n  trace('Proxy server ' + result.address + ' set by environment variable ' + envVar);\n  return result;\n}\nfunction getNoProxyHostList() {\n  /* Prefer using 'no_grpc_proxy'. Fallback on 'no_proxy' if it is not set. */\n  let noProxyStr = process.env.no_grpc_proxy;\n  let envVar = 'no_grpc_proxy';\n  if (!noProxyStr) {\n    noProxyStr = process.env.no_proxy;\n    envVar = 'no_proxy';\n  }\n  if (noProxyStr) {\n    trace('No proxy server list set by environment variable ' + envVar);\n    return noProxyStr.split(',');\n  } else {\n    return [];\n  }\n}\nfunction mapProxyName(target, options) {\n  var _a;\n  const noProxyResult = {\n    target: target,\n    extraOptions: {}\n  };\n  if (((_a = options['grpc.enable_http_proxy']) !== null && _a !== void 0 ? _a : 1) === 0) {\n    return noProxyResult;\n  }\n  if (target.scheme === 'unix') {\n    return noProxyResult;\n  }\n  const proxyInfo = getProxyInfo();\n  if (!proxyInfo.address) {\n    return noProxyResult;\n  }\n  const hostPort = (0, uri_parser_1.splitHostPort)(target.path);\n  if (!hostPort) {\n    return noProxyResult;\n  }\n  const serverHost = hostPort.host;\n  for (const host of getNoProxyHostList()) {\n    if (host === serverHost) {\n      trace('Not using proxy for target in no_proxy list: ' + (0, uri_parser_1.uriToString)(target));\n      return noProxyResult;\n    }\n  }\n  const extraOptions = {\n    'grpc.http_connect_target': (0, uri_parser_1.uriToString)(target)\n  };\n  if (proxyInfo.creds) {\n    extraOptions['grpc.http_connect_creds'] = proxyInfo.creds;\n  }\n  return {\n    target: {\n      scheme: 'dns',\n      path: proxyInfo.address\n    },\n    extraOptions: extraOptions\n  };\n}\nexports.mapProxyName = mapProxyName;\nfunction getProxiedConnection(address, channelOptions, connectionOptions) {\n  if (!('grpc.http_connect_target' in channelOptions)) {\n    return Promise.resolve({});\n  }\n  const realTarget = channelOptions['grpc.http_connect_target'];\n  const parsedTarget = (0, uri_parser_1.parseUri)(realTarget);\n  if (parsedTarget === null) {\n    return Promise.resolve({});\n  }\n  const options = {\n    method: 'CONNECT',\n    path: parsedTarget.path\n  };\n  const headers = {\n    Host: parsedTarget.path\n  };\n  // Connect to the subchannel address as a proxy\n  if ((0, subchannel_address_1.isTcpSubchannelAddress)(address)) {\n    options.host = address.host;\n    options.port = address.port;\n  } else {\n    options.socketPath = address.path;\n  }\n  if ('grpc.http_connect_creds' in channelOptions) {\n    headers['Proxy-Authorization'] = 'Basic ' + Buffer.from(channelOptions['grpc.http_connect_creds']).toString('base64');\n  }\n  options.headers = headers;\n  const proxyAddressString = (0, subchannel_address_1.subchannelAddressToString)(address);\n  trace('Using proxy ' + proxyAddressString + ' to connect to ' + options.path);\n  return new Promise((resolve, reject) => {\n    const request = http.request(options);\n    request.once('connect', (res, socket, head) => {\n      var _a;\n      request.removeAllListeners();\n      socket.removeAllListeners();\n      if (res.statusCode === 200) {\n        trace('Successfully connected to ' + options.path + ' through proxy ' + proxyAddressString);\n        if ('secureContext' in connectionOptions) {\n          /* The proxy is connecting to a TLS server, so upgrade this socket\n           * connection to a TLS connection.\n           * This is a workaround for https://github.com/nodejs/node/issues/32922\n           * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\n          const targetPath = (0, resolver_1.getDefaultAuthority)(parsedTarget);\n          const hostPort = (0, uri_parser_1.splitHostPort)(targetPath);\n          const remoteHost = (_a = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _a !== void 0 ? _a : targetPath;\n          const cts = tls.connect(Object.assign({\n            host: remoteHost,\n            servername: remoteHost,\n            socket: socket\n          }, connectionOptions), () => {\n            trace('Successfully established a TLS connection to ' + options.path + ' through proxy ' + proxyAddressString);\n            resolve({\n              socket: cts,\n              realTarget: parsedTarget\n            });\n          });\n          cts.on('error', error => {\n            trace('Failed to establish a TLS connection to ' + options.path + ' through proxy ' + proxyAddressString + ' with error ' + error.message);\n            reject();\n          });\n        } else {\n          trace('Successfully established a plaintext connection to ' + options.path + ' through proxy ' + proxyAddressString);\n          resolve({\n            socket,\n            realTarget: parsedTarget\n          });\n        }\n      } else {\n        (0, logging_1.log)(constants_1.LogVerbosity.ERROR, 'Failed to connect to ' + options.path + ' through proxy ' + proxyAddressString + ' with status ' + res.statusCode);\n        reject();\n      }\n    });\n    request.once('error', err => {\n      request.removeAllListeners();\n      (0, logging_1.log)(constants_1.LogVerbosity.ERROR, 'Failed to connect to proxy ' + proxyAddressString + ' with error ' + err.message);\n      reject();\n    });\n    request.end();\n  });\n}\nexports.getProxiedConnection = getProxiedConnection;","map":{"version":3,"mappings":"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","names":["TRACER_NAME","trace","text","logging","constants_1","DEBUG","getProxyInfo","proxyEnv","envVar","process","env","grpc_proxy","https_proxy","http_proxy","proxyUrl","url_1","e","ERROR","protocol","userCred","username","password","INFO","hostname","port","result","address","creds","getNoProxyHostList","noProxyStr","no_grpc_proxy","no_proxy","split","mapProxyName","target","options","noProxyResult","extraOptions","scheme","proxyInfo","hostPort","path","serverHost","host","exports","getProxiedConnection","channelOptions","connectionOptions","Promise","resolve","realTarget","parsedTarget","method","headers","Host","socketPath","Buffer","from","toString","proxyAddressString","reject","request","http","once","res","socket","head","removeAllListeners","statusCode","targetPath","remoteHost","cts","tls","connect","servername","on","error","message","err","end"],"sources":["/home/achwak/node_modules/@grpc/grpc-js/src/http_proxy.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { log } from './logging';\nimport { LogVerbosity } from './constants';\nimport { getDefaultAuthority } from './resolver';\nimport { Socket } from 'net';\nimport * as http from 'http';\nimport * as tls from 'tls';\nimport * as logging from './logging';\nimport {\n  SubchannelAddress,\n  isTcpSubchannelAddress,\n  subchannelAddressToString,\n} from './subchannel-address';\nimport { ChannelOptions } from './channel-options';\nimport { GrpcUri, parseUri, splitHostPort, uriToString } from './uri-parser';\nimport { URL } from 'url';\n\nconst TRACER_NAME = 'proxy';\n\nfunction trace(text: string): void {\n  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\ninterface ProxyInfo {\n  address?: string;\n  creds?: string;\n}\n\nfunction getProxyInfo(): ProxyInfo {\n  let proxyEnv = '';\n  let envVar = '';\n  /* Prefer using 'grpc_proxy'. Fallback on 'http_proxy' if it is not set.\n   * Also prefer using 'https_proxy' with fallback on 'http_proxy'. The\n   * fallback behavior can be removed if there's a demand for it.\n   */\n  if (process.env.grpc_proxy) {\n    envVar = 'grpc_proxy';\n    proxyEnv = process.env.grpc_proxy;\n  } else if (process.env.https_proxy) {\n    envVar = 'https_proxy';\n    proxyEnv = process.env.https_proxy;\n  } else if (process.env.http_proxy) {\n    envVar = 'http_proxy';\n    proxyEnv = process.env.http_proxy;\n  } else {\n    return {};\n  }\n  let proxyUrl: URL;\n  try {\n    proxyUrl = new URL(proxyEnv);\n  } catch (e) {\n    log(LogVerbosity.ERROR, `cannot parse value of \"${envVar}\" env var`);\n    return {};\n  }\n  if (proxyUrl.protocol !== 'http:') {\n    log(\n      LogVerbosity.ERROR,\n      `\"${proxyUrl.protocol}\" scheme not supported in proxy URI`\n    );\n    return {};\n  }\n  let userCred: string | null = null;\n  if (proxyUrl.username) {\n    if (proxyUrl.password) {\n      log(LogVerbosity.INFO, 'userinfo found in proxy URI');\n      userCred = `${proxyUrl.username}:${proxyUrl.password}`;\n    } else {\n      userCred = proxyUrl.username;\n    }\n  }\n  const hostname = proxyUrl.hostname;\n  let port = proxyUrl.port;\n  /* The proxy URL uses the scheme \"http:\", which has a default port number of\n   * 80. We need to set that explicitly here if it is omitted because otherwise\n   * it will use gRPC's default port 443. */\n  if (port === '') {\n    port = '80';\n  }\n  const result: ProxyInfo = {\n    address: `${hostname}:${port}`,\n  };\n  if (userCred) {\n    result.creds = userCred;\n  }\n  trace(\n    'Proxy server ' + result.address + ' set by environment variable ' + envVar\n  );\n  return result;\n}\n\nfunction getNoProxyHostList(): string[] {\n  /* Prefer using 'no_grpc_proxy'. Fallback on 'no_proxy' if it is not set. */\n  let noProxyStr: string | undefined = process.env.no_grpc_proxy;\n  let envVar = 'no_grpc_proxy';\n  if (!noProxyStr) {\n    noProxyStr = process.env.no_proxy;\n    envVar = 'no_proxy';\n  }\n  if (noProxyStr) {\n    trace('No proxy server list set by environment variable ' + envVar);\n    return noProxyStr.split(',');\n  } else {\n    return [];\n  }\n}\n\nexport interface ProxyMapResult {\n  target: GrpcUri;\n  extraOptions: ChannelOptions;\n}\n\nexport function mapProxyName(\n  target: GrpcUri,\n  options: ChannelOptions\n): ProxyMapResult {\n  const noProxyResult: ProxyMapResult = {\n    target: target,\n    extraOptions: {},\n  };\n  if ((options['grpc.enable_http_proxy'] ?? 1) === 0) {\n    return noProxyResult;\n  }\n  if (target.scheme === 'unix') {\n    return noProxyResult;\n  }\n  const proxyInfo = getProxyInfo();\n  if (!proxyInfo.address) {\n    return noProxyResult;\n  }\n  const hostPort = splitHostPort(target.path);\n  if (!hostPort) {\n    return noProxyResult;\n  }\n  const serverHost = hostPort.host;\n  for (const host of getNoProxyHostList()) {\n    if (host === serverHost) {\n      trace(\n        'Not using proxy for target in no_proxy list: ' + uriToString(target)\n      );\n      return noProxyResult;\n    }\n  }\n  const extraOptions: ChannelOptions = {\n    'grpc.http_connect_target': uriToString(target),\n  };\n  if (proxyInfo.creds) {\n    extraOptions['grpc.http_connect_creds'] = proxyInfo.creds;\n  }\n  return {\n    target: {\n      scheme: 'dns',\n      path: proxyInfo.address,\n    },\n    extraOptions: extraOptions,\n  };\n}\n\nexport interface ProxyConnectionResult {\n  socket?: Socket;\n  realTarget?: GrpcUri;\n}\n\nexport function getProxiedConnection(\n  address: SubchannelAddress,\n  channelOptions: ChannelOptions,\n  connectionOptions: tls.ConnectionOptions\n): Promise<ProxyConnectionResult> {\n  if (!('grpc.http_connect_target' in channelOptions)) {\n    return Promise.resolve<ProxyConnectionResult>({});\n  }\n  const realTarget = channelOptions['grpc.http_connect_target'] as string;\n  const parsedTarget = parseUri(realTarget);\n  if (parsedTarget === null) {\n    return Promise.resolve<ProxyConnectionResult>({});\n  }\n  const options: http.RequestOptions = {\n    method: 'CONNECT',\n    path: parsedTarget.path,\n  };\n  const headers: http.OutgoingHttpHeaders = {\n    Host: parsedTarget.path,\n  };\n  // Connect to the subchannel address as a proxy\n  if (isTcpSubchannelAddress(address)) {\n    options.host = address.host;\n    options.port = address.port;\n  } else {\n    options.socketPath = address.path;\n  }\n  if ('grpc.http_connect_creds' in channelOptions) {\n    headers['Proxy-Authorization'] =\n      'Basic ' +\n      Buffer.from(\n        channelOptions['grpc.http_connect_creds'] as string\n      ).toString('base64');\n  }\n  options.headers = headers\n  const proxyAddressString = subchannelAddressToString(address);\n  trace('Using proxy ' + proxyAddressString + ' to connect to ' + options.path);\n  return new Promise<ProxyConnectionResult>((resolve, reject) => {\n    const request = http.request(options);\n    request.once('connect', (res, socket, head) => {\n      request.removeAllListeners();\n      socket.removeAllListeners();\n      if (res.statusCode === 200) {\n        trace(\n          'Successfully connected to ' +\n            options.path +\n            ' through proxy ' +\n            proxyAddressString\n        );\n        if ('secureContext' in connectionOptions) {\n          /* The proxy is connecting to a TLS server, so upgrade this socket\n           * connection to a TLS connection.\n           * This is a workaround for https://github.com/nodejs/node/issues/32922\n           * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\n          const targetPath = getDefaultAuthority(parsedTarget);\n          const hostPort = splitHostPort(targetPath);\n          const remoteHost = hostPort?.host ?? targetPath;\n\n          const cts = tls.connect(\n            {\n              host: remoteHost,\n              servername: remoteHost,\n              socket: socket,\n              ...connectionOptions,\n            },\n            () => {\n              trace(\n                'Successfully established a TLS connection to ' +\n                  options.path +\n                  ' through proxy ' +\n                  proxyAddressString\n              );\n              resolve({ socket: cts, realTarget: parsedTarget });\n            }\n          );\n          cts.on('error', (error: Error) => {\n            trace('Failed to establish a TLS connection to ' +\n                    options.path +\n                    ' through proxy ' +\n                    proxyAddressString +\n                    ' with error ' +\n                    error.message);\n            reject();\n          });\n        } else {\n          trace(\n            'Successfully established a plaintext connection to ' +\n              options.path +\n              ' through proxy ' +\n              proxyAddressString\n          );\n          resolve({\n            socket,\n            realTarget: parsedTarget,\n          });\n        }\n      } else {\n        log(\n          LogVerbosity.ERROR,\n          'Failed to connect to ' +\n            options.path +\n            ' through proxy ' +\n            proxyAddressString +\n            ' with status ' +\n            res.statusCode\n        );\n        reject();\n      }\n    });\n    request.once('error', (err) => {\n      request.removeAllListeners();\n      log(\n        LogVerbosity.ERROR,\n        'Failed to connect to proxy ' +\n          proxyAddressString +\n          ' with error ' +\n          err.message\n      );\n      reject();\n    });\n    request.end();\n  });\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}