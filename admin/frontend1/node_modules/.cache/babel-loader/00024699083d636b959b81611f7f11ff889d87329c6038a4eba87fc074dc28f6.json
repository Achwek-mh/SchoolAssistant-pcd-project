{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ChannelImplementation = void 0;\nconst channel_credentials_1 = require(\"./channel-credentials\");\nconst internal_channel_1 = require(\"./internal-channel\");\nclass ChannelImplementation {\n  constructor(target, credentials, options) {\n    if (typeof target !== 'string') {\n      throw new TypeError('Channel target must be a string');\n    }\n    if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {\n      throw new TypeError('Channel credentials must be a ChannelCredentials object');\n    }\n    if (options) {\n      if (typeof options !== 'object') {\n        throw new TypeError('Channel options must be an object');\n      }\n    }\n    this.internalChannel = new internal_channel_1.InternalChannel(target, credentials, options);\n  }\n  close() {\n    this.internalChannel.close();\n  }\n  getTarget() {\n    return this.internalChannel.getTarget();\n  }\n  getConnectivityState(tryToConnect) {\n    return this.internalChannel.getConnectivityState(tryToConnect);\n  }\n  watchConnectivityState(currentState, deadline, callback) {\n    this.internalChannel.watchConnectivityState(currentState, deadline, callback);\n  }\n  /**\n   * Get the channelz reference object for this channel. The returned value is\n   * garbage if channelz is disabled for this channel.\n   * @returns\n   */\n  getChannelzRef() {\n    return this.internalChannel.getChannelzRef();\n  }\n  createCall(method, deadline, host, parentCall, propagateFlags) {\n    if (typeof method !== 'string') {\n      throw new TypeError('Channel#createCall: method must be a string');\n    }\n    if (!(typeof deadline === 'number' || deadline instanceof Date)) {\n      throw new TypeError('Channel#createCall: deadline must be a number or Date');\n    }\n    return this.internalChannel.createCall(method, deadline, host, parentCall, propagateFlags);\n  }\n}\nexports.ChannelImplementation = ChannelImplementation;","map":{"version":3,"mappings":";;AAAA;;;;;;;;;;;;;;;;;;;;AAiBA;AAOA;AAoEA,MAAaA,qBAAqB;EAIhCC,YACEC,MAAc,EACdC,WAA+B,EAC/BC,OAAuB;IAEvB,IAAI,OAAOF,MAAM,KAAK,QAAQ,EAAE;MAC9B,MAAM,IAAIG,SAAS,CAAC,iCAAiC,CAAC;;IAExD,IAAI,EAAEF,WAAW,YAAYG,wCAAkB,CAAC,EAAE;MAChD,MAAM,IAAID,SAAS,CACjB,yDAAyD,CAC1D;;IAEH,IAAID,OAAO,EAAE;MACX,IAAI,OAAOA,OAAO,KAAK,QAAQ,EAAE;QAC/B,MAAM,IAAIC,SAAS,CAAC,mCAAmC,CAAC;;;IAI5D,IAAI,CAACE,eAAe,GAAG,IAAIC,kCAAe,CAACN,MAAM,EAAEC,WAAW,EAAEC,OAAO,CAAC;EAC1E;EAEAK,KAAK;IACH,IAAI,CAACF,eAAe,CAACE,KAAK,EAAE;EAC9B;EAEAC,SAAS;IACP,OAAO,IAAI,CAACH,eAAe,CAACG,SAAS,EAAE;EACzC;EAEAC,oBAAoB,CAACC,YAAqB;IACxC,OAAO,IAAI,CAACL,eAAe,CAACI,oBAAoB,CAACC,YAAY,CAAC;EAChE;EAEAC,sBAAsB,CACpBC,YAA+B,EAC/BC,QAAuB,EACvBC,QAAiC;IAEjC,IAAI,CAACT,eAAe,CAACM,sBAAsB,CAACC,YAAY,EAAEC,QAAQ,EAAEC,QAAQ,CAAC;EAC/E;EAEA;;;;;EAKAC,cAAc;IACZ,OAAO,IAAI,CAACV,eAAe,CAACU,cAAc,EAAE;EAC9C;EAEAC,UAAU,CACRC,MAAc,EACdJ,QAAkB,EAClBK,IAA+B,EAC/BC,UAAoC,EACpCC,cAAyC;IAEzC,IAAI,OAAOH,MAAM,KAAK,QAAQ,EAAE;MAC9B,MAAM,IAAId,SAAS,CAAC,6CAA6C,CAAC;;IAEpE,IAAI,EAAE,OAAOU,QAAQ,KAAK,QAAQ,IAAIA,QAAQ,YAAYQ,IAAI,CAAC,EAAE;MAC/D,MAAM,IAAIlB,SAAS,CACjB,uDAAuD,CACxD;;IAEH,OAAO,IAAI,CAACE,eAAe,CAACW,UAAU,CAACC,MAAM,EAAEJ,QAAQ,EAAEK,IAAI,EAAEC,UAAU,EAAEC,cAAc,CAAC;EAC5F;;AAvEFE","names":["ChannelImplementation","constructor","target","credentials","options","TypeError","channel_credentials_1","internalChannel","internal_channel_1","close","getTarget","getConnectivityState","tryToConnect","watchConnectivityState","currentState","deadline","callback","getChannelzRef","createCall","method","host","parentCall","propagateFlags","Date","exports"],"sources":["/home/achwak/node_modules/@grpc/grpc-js/src/channel.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { ChannelCredentials } from './channel-credentials';\nimport { ChannelOptions } from './channel-options';\nimport { ServerSurfaceCall } from './server-call';\n\nimport { ConnectivityState } from './connectivity-state';\nimport { ChannelRef } from './channelz';\nimport { Call } from './call-interface';\nimport { InternalChannel } from './internal-channel';\nimport { Deadline } from './deadline';\n\n/**\n * An interface that represents a communication channel to a server specified\n * by a given address.\n */\nexport interface Channel {\n  /**\n   * Close the channel. This has the same functionality as the existing\n   * grpc.Client.prototype.close\n   */\n  close(): void;\n  /**\n   * Return the target that this channel connects to\n   */\n  getTarget(): string;\n  /**\n   * Get the channel's current connectivity state. This method is here mainly\n   * because it is in the existing internal Channel class, and there isn't\n   * another good place to put it.\n   * @param tryToConnect If true, the channel will start connecting if it is\n   *     idle. Otherwise, idle channels will only start connecting when a\n   *     call starts.\n   */\n  getConnectivityState(tryToConnect: boolean): ConnectivityState;\n  /**\n   * Watch for connectivity state changes. This is also here mainly because\n   * it is in the existing external Channel class.\n   * @param currentState The state to watch for transitions from. This should\n   *     always be populated by calling getConnectivityState immediately\n   *     before.\n   * @param deadline A deadline for waiting for a state change\n   * @param callback Called with no error when a state change, or with an\n   *     error if the deadline passes without a state change.\n   */\n  watchConnectivityState(\n    currentState: ConnectivityState,\n    deadline: Date | number,\n    callback: (error?: Error) => void\n  ): void;\n  /**\n   * Get the channelz reference object for this channel. A request to the\n   * channelz service for the id in this object will provide information\n   * about this channel.\n   */\n  getChannelzRef(): ChannelRef;\n  /**\n   * Create a call object. Call is an opaque type that is used by the Client\n   * class. This function is called by the gRPC library when starting a\n   * request. Implementers should return an instance of Call that is returned\n   * from calling createCall on an instance of the provided Channel class.\n   * @param method The full method string to request.\n   * @param deadline The call deadline\n   * @param host A host string override for making the request\n   * @param parentCall A server call to propagate some information from\n   * @param propagateFlags A bitwise combination of elements of grpc.propagate\n   *     that indicates what information to propagate from parentCall.\n   */\n  createCall(\n    method: string,\n    deadline: Deadline,\n    host: string | null | undefined,\n    parentCall: ServerSurfaceCall | null,\n    propagateFlags: number | null | undefined\n  ): Call;\n}\n\nexport class ChannelImplementation implements Channel {\n\n  private internalChannel: InternalChannel;\n\n  constructor(\n    target: string,\n    credentials: ChannelCredentials,\n    options: ChannelOptions\n  ) {\n    if (typeof target !== 'string') {\n      throw new TypeError('Channel target must be a string');\n    }\n    if (!(credentials instanceof ChannelCredentials)) {\n      throw new TypeError(\n        'Channel credentials must be a ChannelCredentials object'\n      );\n    }\n    if (options) {\n      if (typeof options !== 'object') {\n        throw new TypeError('Channel options must be an object');\n      }\n    }\n\n    this.internalChannel = new InternalChannel(target, credentials, options);\n  }\n\n  close() {\n    this.internalChannel.close();\n  }\n\n  getTarget() {\n    return this.internalChannel.getTarget();\n  }\n\n  getConnectivityState(tryToConnect: boolean) {\n    return this.internalChannel.getConnectivityState(tryToConnect);\n  }\n\n  watchConnectivityState(\n    currentState: ConnectivityState,\n    deadline: Date | number,\n    callback: (error?: Error) => void\n  ): void {\n    this.internalChannel.watchConnectivityState(currentState, deadline, callback);\n  }\n\n  /**\n   * Get the channelz reference object for this channel. The returned value is\n   * garbage if channelz is disabled for this channel.\n   * @returns \n   */\n  getChannelzRef() {\n    return this.internalChannel.getChannelzRef();\n  }\n\n  createCall(\n    method: string,\n    deadline: Deadline,\n    host: string | null | undefined,\n    parentCall: ServerSurfaceCall | null,\n    propagateFlags: number | null | undefined\n  ): Call {\n    if (typeof method !== 'string') {\n      throw new TypeError('Channel#createCall: method must be a string');\n    }\n    if (!(typeof deadline === 'number' || deadline instanceof Date)) {\n      throw new TypeError(\n        'Channel#createCall: deadline must be a number or Date'\n      );\n    }\n    return this.internalChannel.createCall(method, deadline, host, parentCall, propagateFlags);\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}