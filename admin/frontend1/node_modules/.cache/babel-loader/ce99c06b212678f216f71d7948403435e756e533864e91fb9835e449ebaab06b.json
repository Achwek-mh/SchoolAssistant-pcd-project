{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Http2ServerCallStream = exports.ServerDuplexStreamImpl = exports.ServerWritableStreamImpl = exports.ServerReadableStreamImpl = exports.ServerUnaryCallImpl = void 0;\nconst events_1 = require(\"events\");\nconst http2 = require(\"http2\");\nconst stream_1 = require(\"stream\");\nconst zlib = require(\"zlib\");\nconst util_1 = require(\"util\");\nconst constants_1 = require(\"./constants\");\nconst metadata_1 = require(\"./metadata\");\nconst stream_decoder_1 = require(\"./stream-decoder\");\nconst logging = require(\"./logging\");\nconst error_1 = require(\"./error\");\nconst TRACER_NAME = 'server_call';\nconst unzip = (0, util_1.promisify)(zlib.unzip);\nconst inflate = (0, util_1.promisify)(zlib.inflate);\nfunction trace(text) {\n  logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst GRPC_ACCEPT_ENCODING_HEADER = 'grpc-accept-encoding';\nconst GRPC_ENCODING_HEADER = 'grpc-encoding';\nconst GRPC_MESSAGE_HEADER = 'grpc-message';\nconst GRPC_STATUS_HEADER = 'grpc-status';\nconst GRPC_TIMEOUT_HEADER = 'grpc-timeout';\nconst DEADLINE_REGEX = /(\\d{1,8})\\s*([HMSmun])/;\nconst deadlineUnitsToMs = {\n  H: 3600000,\n  M: 60000,\n  S: 1000,\n  m: 1,\n  u: 0.001,\n  n: 0.000001\n};\nconst defaultCompressionHeaders = {\n  // TODO(cjihrig): Remove these encoding headers from the default response\n  // once compression is integrated.\n  [GRPC_ACCEPT_ENCODING_HEADER]: 'identity,deflate,gzip',\n  [GRPC_ENCODING_HEADER]: 'identity'\n};\nconst defaultResponseHeaders = {\n  [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,\n  [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto'\n};\nconst defaultResponseOptions = {\n  waitForTrailers: true\n};\nclass ServerUnaryCallImpl extends events_1.EventEmitter {\n  constructor(call, metadata, request) {\n    super();\n    this.call = call;\n    this.metadata = metadata;\n    this.request = request;\n    this.cancelled = false;\n    this.call.setupSurfaceCall(this);\n  }\n  getPeer() {\n    return this.call.getPeer();\n  }\n  sendMetadata(responseMetadata) {\n    this.call.sendMetadata(responseMetadata);\n  }\n  getDeadline() {\n    return this.call.getDeadline();\n  }\n  getPath() {\n    return this.call.getPath();\n  }\n}\nexports.ServerUnaryCallImpl = ServerUnaryCallImpl;\nclass ServerReadableStreamImpl extends stream_1.Readable {\n  constructor(call, metadata, deserialize, encoding) {\n    super({\n      objectMode: true\n    });\n    this.call = call;\n    this.metadata = metadata;\n    this.deserialize = deserialize;\n    this.cancelled = false;\n    this.call.setupSurfaceCall(this);\n    this.call.setupReadable(this, encoding);\n  }\n  _read(size) {\n    if (!this.call.consumeUnpushedMessages(this)) {\n      return;\n    }\n    this.call.resume();\n  }\n  getPeer() {\n    return this.call.getPeer();\n  }\n  sendMetadata(responseMetadata) {\n    this.call.sendMetadata(responseMetadata);\n  }\n  getDeadline() {\n    return this.call.getDeadline();\n  }\n  getPath() {\n    return this.call.getPath();\n  }\n}\nexports.ServerReadableStreamImpl = ServerReadableStreamImpl;\nclass ServerWritableStreamImpl extends stream_1.Writable {\n  constructor(call, metadata, serialize, request) {\n    super({\n      objectMode: true\n    });\n    this.call = call;\n    this.metadata = metadata;\n    this.serialize = serialize;\n    this.request = request;\n    this.cancelled = false;\n    this.trailingMetadata = new metadata_1.Metadata();\n    this.call.setupSurfaceCall(this);\n    this.on('error', err => {\n      this.call.sendError(err);\n      this.end();\n    });\n  }\n  getPeer() {\n    return this.call.getPeer();\n  }\n  sendMetadata(responseMetadata) {\n    this.call.sendMetadata(responseMetadata);\n  }\n  getDeadline() {\n    return this.call.getDeadline();\n  }\n  getPath() {\n    return this.call.getPath();\n  }\n  _write(chunk, encoding,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  callback) {\n    try {\n      const response = this.call.serializeMessage(chunk);\n      if (!this.call.write(response)) {\n        this.call.once('drain', callback);\n        return;\n      }\n    } catch (err) {\n      this.emit('error', {\n        details: (0, error_1.getErrorMessage)(err),\n        code: constants_1.Status.INTERNAL\n      });\n    }\n    callback();\n  }\n  _final(callback) {\n    this.call.sendStatus({\n      code: constants_1.Status.OK,\n      details: 'OK',\n      metadata: this.trailingMetadata\n    });\n    callback(null);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  end(metadata) {\n    if (metadata) {\n      this.trailingMetadata = metadata;\n    }\n    return super.end();\n  }\n}\nexports.ServerWritableStreamImpl = ServerWritableStreamImpl;\nclass ServerDuplexStreamImpl extends stream_1.Duplex {\n  constructor(call, metadata, serialize, deserialize, encoding) {\n    super({\n      objectMode: true\n    });\n    this.call = call;\n    this.metadata = metadata;\n    this.serialize = serialize;\n    this.deserialize = deserialize;\n    this.cancelled = false;\n    this.trailingMetadata = new metadata_1.Metadata();\n    this.call.setupSurfaceCall(this);\n    this.call.setupReadable(this, encoding);\n    this.on('error', err => {\n      this.call.sendError(err);\n      this.end();\n    });\n  }\n  getPeer() {\n    return this.call.getPeer();\n  }\n  sendMetadata(responseMetadata) {\n    this.call.sendMetadata(responseMetadata);\n  }\n  getDeadline() {\n    return this.call.getDeadline();\n  }\n  getPath() {\n    return this.call.getPath();\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  end(metadata) {\n    if (metadata) {\n      this.trailingMetadata = metadata;\n    }\n    return super.end();\n  }\n}\nexports.ServerDuplexStreamImpl = ServerDuplexStreamImpl;\nServerDuplexStreamImpl.prototype._read = ServerReadableStreamImpl.prototype._read;\nServerDuplexStreamImpl.prototype._write = ServerWritableStreamImpl.prototype._write;\nServerDuplexStreamImpl.prototype._final = ServerWritableStreamImpl.prototype._final;\n// Internal class that wraps the HTTP2 request.\nclass Http2ServerCallStream extends events_1.EventEmitter {\n  constructor(stream, handler, options) {\n    super();\n    this.stream = stream;\n    this.handler = handler;\n    this.options = options;\n    this.cancelled = false;\n    this.deadlineTimer = null;\n    this.statusSent = false;\n    this.deadline = Infinity;\n    this.wantTrailers = false;\n    this.metadataSent = false;\n    this.canPush = false;\n    this.isPushPending = false;\n    this.bufferedMessages = [];\n    this.messagesToPush = [];\n    this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n    this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n    this.stream.once('error', err => {\n      /* We need an error handler to avoid uncaught error event exceptions, but\n       * there is nothing we can reasonably do here. Any error event should\n       * have a corresponding close event, which handles emitting the cancelled\n       * event. And the stream is now in a bad state, so we can't reasonably\n       * expect to be able to send an error over it. */\n    });\n    this.stream.once('close', () => {\n      var _a;\n      trace('Request to method ' + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) + ' stream closed with rstCode ' + this.stream.rstCode);\n      if (!this.statusSent) {\n        this.cancelled = true;\n        this.emit('cancelled', 'cancelled');\n        this.emit('streamEnd', false);\n        this.sendStatus({\n          code: constants_1.Status.CANCELLED,\n          details: 'Cancelled by client',\n          metadata: null\n        });\n      }\n    });\n    this.stream.on('drain', () => {\n      this.emit('drain');\n    });\n    if ('grpc.max_send_message_length' in options) {\n      this.maxSendMessageSize = options['grpc.max_send_message_length'];\n    }\n    if ('grpc.max_receive_message_length' in options) {\n      this.maxReceiveMessageSize = options['grpc.max_receive_message_length'];\n    }\n  }\n  checkCancelled() {\n    /* In some cases the stream can become destroyed before the close event\n     * fires. That creates a race condition that this check works around */\n    if (this.stream.destroyed || this.stream.closed) {\n      this.cancelled = true;\n    }\n    return this.cancelled;\n  }\n  getDecompressedMessage(message, encoding) {\n    if (encoding === 'deflate') {\n      return inflate(message.subarray(5));\n    } else if (encoding === 'gzip') {\n      return unzip(message.subarray(5));\n    } else if (encoding === 'identity') {\n      return message.subarray(5);\n    }\n    return Promise.reject({\n      code: constants_1.Status.UNIMPLEMENTED,\n      details: `Received message compressed with unsupported encoding \"${encoding}\"`\n    });\n  }\n  sendMetadata(customMetadata) {\n    if (this.checkCancelled()) {\n      return;\n    }\n    if (this.metadataSent) {\n      return;\n    }\n    this.metadataSent = true;\n    const custom = customMetadata ? customMetadata.toHttp2Headers() : null;\n    // TODO(cjihrig): Include compression headers.\n    const headers = Object.assign(Object.assign(Object.assign({}, defaultResponseHeaders), defaultCompressionHeaders), custom);\n    this.stream.respond(headers, defaultResponseOptions);\n  }\n  receiveMetadata(headers) {\n    const metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n    if (logging.isTracerEnabled(TRACER_NAME)) {\n      trace('Request to ' + this.handler.path + ' received headers ' + JSON.stringify(metadata.toJSON()));\n    }\n    // TODO(cjihrig): Receive compression metadata.\n    const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);\n    if (timeoutHeader.length > 0) {\n      const match = timeoutHeader[0].toString().match(DEADLINE_REGEX);\n      if (match === null) {\n        const err = new Error('Invalid deadline');\n        err.code = constants_1.Status.OUT_OF_RANGE;\n        this.sendError(err);\n        return metadata;\n      }\n      const timeout = +match[1] * deadlineUnitsToMs[match[2]] | 0;\n      const now = new Date();\n      this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);\n      this.deadlineTimer = setTimeout(handleExpiredDeadline, timeout, this);\n      metadata.remove(GRPC_TIMEOUT_HEADER);\n    }\n    // Remove several headers that should not be propagated to the application\n    metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);\n    metadata.remove(http2.constants.HTTP2_HEADER_TE);\n    metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);\n    metadata.remove('grpc-accept-encoding');\n    return metadata;\n  }\n  receiveUnaryMessage(encoding, next) {\n    const {\n      stream\n    } = this;\n    let receivedLength = 0;\n    const call = this;\n    const body = [];\n    const limit = this.maxReceiveMessageSize;\n    stream.on('data', onData);\n    stream.on('end', onEnd);\n    stream.on('error', onEnd);\n    function onData(chunk) {\n      receivedLength += chunk.byteLength;\n      if (limit !== -1 && receivedLength > limit) {\n        stream.removeListener('data', onData);\n        stream.removeListener('end', onEnd);\n        stream.removeListener('error', onEnd);\n        next({\n          code: constants_1.Status.RESOURCE_EXHAUSTED,\n          details: `Received message larger than max (${receivedLength} vs. ${limit})`\n        });\n        return;\n      }\n      body.push(chunk);\n    }\n    function onEnd(err) {\n      stream.removeListener('data', onData);\n      stream.removeListener('end', onEnd);\n      stream.removeListener('error', onEnd);\n      if (err !== undefined) {\n        next({\n          code: constants_1.Status.INTERNAL,\n          details: err.message\n        });\n        return;\n      }\n      if (receivedLength === 0) {\n        next({\n          code: constants_1.Status.INTERNAL,\n          details: 'received empty unary message'\n        });\n        return;\n      }\n      call.emit('receiveMessage');\n      const requestBytes = Buffer.concat(body, receivedLength);\n      const compressed = requestBytes.readUInt8(0) === 1;\n      const compressedMessageEncoding = compressed ? encoding : 'identity';\n      const decompressedMessage = call.getDecompressedMessage(requestBytes, compressedMessageEncoding);\n      if (Buffer.isBuffer(decompressedMessage)) {\n        call.safeDeserializeMessage(decompressedMessage, next);\n        return;\n      }\n      decompressedMessage.then(decompressed => call.safeDeserializeMessage(decompressed, next), err => next(err.code ? err : {\n        code: constants_1.Status.INTERNAL,\n        details: `Received \"grpc-encoding\" header \"${encoding}\" but ${encoding} decompression failed`\n      }));\n    }\n  }\n  safeDeserializeMessage(buffer, next) {\n    try {\n      next(null, this.deserializeMessage(buffer));\n    } catch (err) {\n      next({\n        details: (0, error_1.getErrorMessage)(err),\n        code: constants_1.Status.INTERNAL\n      });\n    }\n  }\n  serializeMessage(value) {\n    const messageBuffer = this.handler.serialize(value);\n    // TODO(cjihrig): Call compression aware serializeMessage().\n    const byteLength = messageBuffer.byteLength;\n    const output = Buffer.allocUnsafe(byteLength + 5);\n    output.writeUInt8(0, 0);\n    output.writeUInt32BE(byteLength, 1);\n    messageBuffer.copy(output, 5);\n    return output;\n  }\n  deserializeMessage(bytes) {\n    return this.handler.deserialize(bytes);\n  }\n  async sendUnaryMessage(err, value, metadata, flags) {\n    if (this.checkCancelled()) {\n      return;\n    }\n    if (metadata === undefined) {\n      metadata = null;\n    }\n    if (err) {\n      if (!Object.prototype.hasOwnProperty.call(err, 'metadata') && metadata) {\n        err.metadata = metadata;\n      }\n      this.sendError(err);\n      return;\n    }\n    try {\n      const response = this.serializeMessage(value);\n      this.write(response);\n      this.sendStatus({\n        code: constants_1.Status.OK,\n        details: 'OK',\n        metadata\n      });\n    } catch (err) {\n      this.sendError({\n        details: (0, error_1.getErrorMessage)(err),\n        code: constants_1.Status.INTERNAL\n      });\n    }\n  }\n  sendStatus(statusObj) {\n    var _a, _b;\n    this.emit('callEnd', statusObj.code);\n    this.emit('streamEnd', statusObj.code === constants_1.Status.OK);\n    if (this.checkCancelled()) {\n      return;\n    }\n    trace('Request to method ' + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) + ' ended with status code: ' + constants_1.Status[statusObj.code] + ' details: ' + statusObj.details);\n    if (this.deadlineTimer) clearTimeout(this.deadlineTimer);\n    if (this.stream.headersSent) {\n      if (!this.wantTrailers) {\n        this.wantTrailers = true;\n        this.stream.once('wantTrailers', () => {\n          var _a;\n          const trailersToSend = Object.assign({\n            [GRPC_STATUS_HEADER]: statusObj.code,\n            [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details)\n          }, (_a = statusObj.metadata) === null || _a === void 0 ? void 0 : _a.toHttp2Headers());\n          this.stream.sendTrailers(trailersToSend);\n          this.statusSent = true;\n        });\n        this.stream.end();\n      }\n    } else {\n      // Trailers-only response\n      const trailersToSend = Object.assign(Object.assign({\n        [GRPC_STATUS_HEADER]: statusObj.code,\n        [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details)\n      }, defaultResponseHeaders), (_b = statusObj.metadata) === null || _b === void 0 ? void 0 : _b.toHttp2Headers());\n      this.stream.respond(trailersToSend, {\n        endStream: true\n      });\n      this.statusSent = true;\n    }\n  }\n  sendError(error) {\n    const status = {\n      code: constants_1.Status.UNKNOWN,\n      details: 'message' in error ? error.message : 'Unknown Error',\n      metadata: 'metadata' in error && error.metadata !== undefined ? error.metadata : null\n    };\n    if ('code' in error && typeof error.code === 'number' && Number.isInteger(error.code)) {\n      status.code = error.code;\n      if ('details' in error && typeof error.details === 'string') {\n        status.details = error.details;\n      }\n    }\n    this.sendStatus(status);\n  }\n  write(chunk) {\n    if (this.checkCancelled()) {\n      return;\n    }\n    if (this.maxSendMessageSize !== -1 && chunk.length > this.maxSendMessageSize) {\n      this.sendError({\n        code: constants_1.Status.RESOURCE_EXHAUSTED,\n        details: `Sent message larger than max (${chunk.length} vs. ${this.maxSendMessageSize})`\n      });\n      return;\n    }\n    this.sendMetadata();\n    this.emit('sendMessage');\n    return this.stream.write(chunk);\n  }\n  resume() {\n    this.stream.resume();\n  }\n  setupSurfaceCall(call) {\n    this.once('cancelled', reason => {\n      call.cancelled = true;\n      call.emit('cancelled', reason);\n    });\n    this.once('callEnd', status => call.emit('callEnd', status));\n  }\n  setupReadable(readable, encoding) {\n    const decoder = new stream_decoder_1.StreamDecoder();\n    let readsDone = false;\n    let pendingMessageProcessing = false;\n    let pushedEnd = false;\n    const maybePushEnd = async () => {\n      if (!pushedEnd && readsDone && !pendingMessageProcessing) {\n        pushedEnd = true;\n        await this.pushOrBufferMessage(readable, null);\n      }\n    };\n    this.stream.on('data', async data => {\n      const messages = decoder.write(data);\n      pendingMessageProcessing = true;\n      this.stream.pause();\n      for (const message of messages) {\n        if (this.maxReceiveMessageSize !== -1 && message.length > this.maxReceiveMessageSize) {\n          this.sendError({\n            code: constants_1.Status.RESOURCE_EXHAUSTED,\n            details: `Received message larger than max (${message.length} vs. ${this.maxReceiveMessageSize})`\n          });\n          return;\n        }\n        this.emit('receiveMessage');\n        const compressed = message.readUInt8(0) === 1;\n        const compressedMessageEncoding = compressed ? encoding : 'identity';\n        const decompressedMessage = await this.getDecompressedMessage(message, compressedMessageEncoding);\n        // Encountered an error with decompression; it'll already have been propogated back\n        // Just return early\n        if (!decompressedMessage) return;\n        await this.pushOrBufferMessage(readable, decompressedMessage);\n      }\n      pendingMessageProcessing = false;\n      this.stream.resume();\n      await maybePushEnd();\n    });\n    this.stream.once('end', async () => {\n      readsDone = true;\n      await maybePushEnd();\n    });\n  }\n  consumeUnpushedMessages(readable) {\n    this.canPush = true;\n    while (this.messagesToPush.length > 0) {\n      const nextMessage = this.messagesToPush.shift();\n      const canPush = readable.push(nextMessage);\n      if (nextMessage === null || canPush === false) {\n        this.canPush = false;\n        break;\n      }\n    }\n    return this.canPush;\n  }\n  async pushOrBufferMessage(readable, messageBytes) {\n    if (this.isPushPending) {\n      this.bufferedMessages.push(messageBytes);\n    } else {\n      await this.pushMessage(readable, messageBytes);\n    }\n  }\n  async pushMessage(readable, messageBytes) {\n    if (messageBytes === null) {\n      trace('Received end of stream');\n      if (this.canPush) {\n        readable.push(null);\n      } else {\n        this.messagesToPush.push(null);\n      }\n      return;\n    }\n    trace('Received message of length ' + messageBytes.length);\n    this.isPushPending = true;\n    try {\n      const deserialized = await this.deserializeMessage(messageBytes);\n      if (this.canPush) {\n        if (!readable.push(deserialized)) {\n          this.canPush = false;\n          this.stream.pause();\n        }\n      } else {\n        this.messagesToPush.push(deserialized);\n      }\n    } catch (error) {\n      // Ignore any remaining messages when errors occur.\n      this.bufferedMessages.length = 0;\n      let code = (0, error_1.getErrorCode)(error);\n      if (code === null || code < constants_1.Status.OK || code > constants_1.Status.UNAUTHENTICATED) {\n        code = constants_1.Status.INTERNAL;\n      }\n      readable.emit('error', {\n        details: (0, error_1.getErrorMessage)(error),\n        code: code\n      });\n    }\n    this.isPushPending = false;\n    if (this.bufferedMessages.length > 0) {\n      await this.pushMessage(readable, this.bufferedMessages.shift());\n    }\n  }\n  getPeer() {\n    const socket = this.stream.session.socket;\n    if (socket.remoteAddress) {\n      if (socket.remotePort) {\n        return `${socket.remoteAddress}:${socket.remotePort}`;\n      } else {\n        return socket.remoteAddress;\n      }\n    } else {\n      return 'unknown';\n    }\n  }\n  getDeadline() {\n    return this.deadline;\n  }\n  getPath() {\n    return this.handler.path;\n  }\n}\nexports.Http2ServerCallStream = Http2ServerCallStream;\nfunction handleExpiredDeadline(call) {\n  const err = new Error('Deadline exceeded');\n  err.code = constants_1.Status.DEADLINE_EXCEEDED;\n  call.sendError(err);\n  call.cancelled = true;\n  call.emit('cancelled', 'deadline');\n}","map":{"version":3,"mappings":"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","names":["TRACER_NAME","unzip","zlib","inflate","trace","text","logging","constants_1","DEBUG","GRPC_ACCEPT_ENCODING_HEADER","GRPC_ENCODING_HEADER","GRPC_MESSAGE_HEADER","GRPC_STATUS_HEADER","GRPC_TIMEOUT_HEADER","DEADLINE_REGEX","deadlineUnitsToMs","H","M","S","m","u","n","defaultCompressionHeaders","defaultResponseHeaders","http2","constants","HTTP2_HEADER_STATUS","HTTP_STATUS_OK","HTTP2_HEADER_CONTENT_TYPE","defaultResponseOptions","waitForTrailers","ServerUnaryCallImpl","events_1","constructor","call","metadata","request","cancelled","setupSurfaceCall","getPeer","sendMetadata","responseMetadata","getDeadline","getPath","exports","ServerReadableStreamImpl","stream_1","deserialize","encoding","objectMode","setupReadable","_read","size","consumeUnpushedMessages","resume","ServerWritableStreamImpl","serialize","trailingMetadata","metadata_1","on","err","sendError","end","_write","chunk","callback","response","serializeMessage","write","once","emit","details","code","INTERNAL","_final","sendStatus","OK","ServerDuplexStreamImpl","prototype","Http2ServerCallStream","stream","handler","options","Infinity","path","rstCode","statusSent","CANCELLED","maxSendMessageSize","maxReceiveMessageSize","checkCancelled","destroyed","closed","getDecompressedMessage","message","subarray","Promise","reject","UNIMPLEMENTED","customMetadata","metadataSent","custom","toHttp2Headers","headers","respond","receiveMetadata","fromHttp2Headers","isTracerEnabled","JSON","stringify","toJSON","timeoutHeader","get","length","match","toString","Error","OUT_OF_RANGE","timeout","now","Date","deadline","setMilliseconds","getMilliseconds","deadlineTimer","setTimeout","handleExpiredDeadline","remove","HTTP2_HEADER_ACCEPT_ENCODING","HTTP2_HEADER_TE","receiveUnaryMessage","next","receivedLength","body","limit","onData","onEnd","byteLength","removeListener","RESOURCE_EXHAUSTED","push","undefined","requestBytes","Buffer","concat","compressed","readUInt8","compressedMessageEncoding","decompressedMessage","isBuffer","safeDeserializeMessage","then","decompressed","buffer","deserializeMessage","value","messageBuffer","output","allocUnsafe","writeUInt8","writeUInt32BE","copy","bytes","sendUnaryMessage","flags","Object","hasOwnProperty","statusObj","clearTimeout","headersSent","wantTrailers","trailersToSend","encodeURI","sendTrailers","endStream","error","status","UNKNOWN","Number","isInteger","reason","readable","decoder","stream_decoder_1","readsDone","pendingMessageProcessing","pushedEnd","maybePushEnd","pushOrBufferMessage","data","messages","pause","canPush","messagesToPush","nextMessage","shift","messageBytes","isPushPending","bufferedMessages","pushMessage","deserialized","UNAUTHENTICATED","socket","session","remoteAddress","remotePort","DEADLINE_EXCEEDED"],"sources":["/home/achwak/node_modules/@grpc/grpc-js/src/server-call.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { EventEmitter } from 'events';\nimport * as http2 from 'http2';\nimport { Duplex, Readable, Writable } from 'stream';\nimport * as zlib from 'zlib';\nimport { promisify } from 'util';\n\nimport {\n  Status,\n  DEFAULT_MAX_SEND_MESSAGE_LENGTH,\n  DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH,\n  LogVerbosity,\n} from './constants';\nimport { Deserialize, Serialize } from './make-client';\nimport { Metadata } from './metadata';\nimport { StreamDecoder } from './stream-decoder';\nimport { ObjectReadable, ObjectWritable } from './object-stream';\nimport { ChannelOptions } from './channel-options';\nimport * as logging from './logging';\nimport { StatusObject, PartialStatusObject } from './call-interface';\nimport { Deadline } from './deadline';\nimport { getErrorCode, getErrorMessage } from './error';\n\nconst TRACER_NAME = 'server_call';\nconst unzip = promisify(zlib.unzip);\nconst inflate = promisify(zlib.inflate);\n\nfunction trace(text: string): void {\n  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\ninterface DeadlineUnitIndexSignature {\n  [name: string]: number;\n}\n\nconst GRPC_ACCEPT_ENCODING_HEADER = 'grpc-accept-encoding';\nconst GRPC_ENCODING_HEADER = 'grpc-encoding';\nconst GRPC_MESSAGE_HEADER = 'grpc-message';\nconst GRPC_STATUS_HEADER = 'grpc-status';\nconst GRPC_TIMEOUT_HEADER = 'grpc-timeout';\nconst DEADLINE_REGEX = /(\\d{1,8})\\s*([HMSmun])/;\nconst deadlineUnitsToMs: DeadlineUnitIndexSignature = {\n  H: 3600000,\n  M: 60000,\n  S: 1000,\n  m: 1,\n  u: 0.001,\n  n: 0.000001,\n};\nconst defaultCompressionHeaders = {\n  // TODO(cjihrig): Remove these encoding headers from the default response\n  // once compression is integrated.\n  [GRPC_ACCEPT_ENCODING_HEADER]: 'identity,deflate,gzip',\n  [GRPC_ENCODING_HEADER]: 'identity',\n}\nconst defaultResponseHeaders = {\n  [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,\n  [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto',\n};\nconst defaultResponseOptions = {\n  waitForTrailers: true,\n} as http2.ServerStreamResponseOptions;\n\nexport type ServerStatusResponse = Partial<StatusObject>;\n\nexport type ServerErrorResponse = ServerStatusResponse & Error;\n\nexport type ServerSurfaceCall = {\n  cancelled: boolean;\n  readonly metadata: Metadata;\n  getPeer(): string;\n  sendMetadata(responseMetadata: Metadata): void;\n  getDeadline(): Deadline;\n  getPath(): string;\n} & EventEmitter;\n\nexport type ServerUnaryCall<RequestType, ResponseType> = ServerSurfaceCall & {\n  request: RequestType;\n};\nexport type ServerReadableStream<RequestType, ResponseType> =\n  ServerSurfaceCall & ObjectReadable<RequestType>;\nexport type ServerWritableStream<RequestType, ResponseType> =\n  ServerSurfaceCall &\n    ObjectWritable<ResponseType> & {\n      request: RequestType;\n      end: (metadata?: Metadata) => void;\n    };\nexport type ServerDuplexStream<RequestType, ResponseType> = ServerSurfaceCall &\n  ObjectReadable<RequestType> &\n  ObjectWritable<ResponseType> & { end: (metadata?: Metadata) => void };\n\nexport class ServerUnaryCallImpl<RequestType, ResponseType>\n  extends EventEmitter\n  implements ServerUnaryCall<RequestType, ResponseType>\n{\n  cancelled: boolean;\n\n  constructor(\n    private call: Http2ServerCallStream<RequestType, ResponseType>,\n    public metadata: Metadata,\n    public request: RequestType\n  ) {\n    super();\n    this.cancelled = false;\n    this.call.setupSurfaceCall(this);\n  }\n\n  getPeer(): string {\n    return this.call.getPeer();\n  }\n\n  sendMetadata(responseMetadata: Metadata): void {\n    this.call.sendMetadata(responseMetadata);\n  }\n\n  getDeadline(): Deadline {\n    return this.call.getDeadline();\n  }\n\n  getPath(): string {\n    return this.call.getPath();\n  }\n}\n\nexport class ServerReadableStreamImpl<RequestType, ResponseType>\n  extends Readable\n  implements ServerReadableStream<RequestType, ResponseType>\n{\n  cancelled: boolean;\n\n  constructor(\n    private call: Http2ServerCallStream<RequestType, ResponseType>,\n    public metadata: Metadata,\n    public deserialize: Deserialize<RequestType>,\n    encoding: string\n  ) {\n    super({ objectMode: true });\n    this.cancelled = false;\n    this.call.setupSurfaceCall(this);\n    this.call.setupReadable(this, encoding);\n  }\n\n  _read(size: number) {\n    if (!this.call.consumeUnpushedMessages(this)) {\n      return;\n    }\n\n    this.call.resume();\n  }\n\n  getPeer(): string {\n    return this.call.getPeer();\n  }\n\n  sendMetadata(responseMetadata: Metadata): void {\n    this.call.sendMetadata(responseMetadata);\n  }\n\n  getDeadline(): Deadline {\n    return this.call.getDeadline();\n  }\n\n  getPath(): string {\n    return this.call.getPath();\n  }\n}\n\nexport class ServerWritableStreamImpl<RequestType, ResponseType>\n  extends Writable\n  implements ServerWritableStream<RequestType, ResponseType>\n{\n  cancelled: boolean;\n  private trailingMetadata: Metadata;\n\n  constructor(\n    private call: Http2ServerCallStream<RequestType, ResponseType>,\n    public metadata: Metadata,\n    public serialize: Serialize<ResponseType>,\n    public request: RequestType\n  ) {\n    super({ objectMode: true });\n    this.cancelled = false;\n    this.trailingMetadata = new Metadata();\n    this.call.setupSurfaceCall(this);\n\n    this.on('error', (err) => {\n      this.call.sendError(err);\n      this.end();\n    });\n  }\n\n  getPeer(): string {\n    return this.call.getPeer();\n  }\n\n  sendMetadata(responseMetadata: Metadata): void {\n    this.call.sendMetadata(responseMetadata);\n  }\n\n  getDeadline(): Deadline {\n    return this.call.getDeadline();\n  }\n\n  getPath(): string {\n    return this.call.getPath();\n  }\n\n  _write(\n    chunk: ResponseType,\n    encoding: string,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callback: (...args: any[]) => void\n  ) {\n    try {\n      const response = this.call.serializeMessage(chunk);\n\n      if (!this.call.write(response)) {\n        this.call.once('drain', callback);\n        return;\n      }\n    } catch (err) {\n      this.emit('error', {\n        details: getErrorMessage(err),\n        code: Status.INTERNAL\n      });\n    }\n\n    callback();\n  }\n\n  _final(callback: Function): void {\n    this.call.sendStatus({\n      code: Status.OK,\n      details: 'OK',\n      metadata: this.trailingMetadata,\n    });\n    callback(null);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  end(metadata?: any) {\n    if (metadata) {\n      this.trailingMetadata = metadata;\n    }\n\n    return super.end();\n  }\n}\n\nexport class ServerDuplexStreamImpl<RequestType, ResponseType>\n  extends Duplex\n  implements ServerDuplexStream<RequestType, ResponseType>\n{\n  cancelled: boolean;\n  private trailingMetadata: Metadata;\n\n  constructor(\n    private call: Http2ServerCallStream<RequestType, ResponseType>,\n    public metadata: Metadata,\n    public serialize: Serialize<ResponseType>,\n    public deserialize: Deserialize<RequestType>,\n    encoding: string\n  ) {\n    super({ objectMode: true });\n    this.cancelled = false;\n    this.trailingMetadata = new Metadata();\n    this.call.setupSurfaceCall(this);\n    this.call.setupReadable(this, encoding);\n\n    this.on('error', (err) => {\n      this.call.sendError(err);\n      this.end();\n    });\n  }\n\n  getPeer(): string {\n    return this.call.getPeer();\n  }\n\n  sendMetadata(responseMetadata: Metadata): void {\n    this.call.sendMetadata(responseMetadata);\n  }\n\n  getDeadline(): Deadline {\n    return this.call.getDeadline();\n  }\n\n  getPath(): string {\n    return this.call.getPath();\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  end(metadata?: any) {\n    if (metadata) {\n      this.trailingMetadata = metadata;\n    }\n\n    return super.end();\n  }\n}\n\nServerDuplexStreamImpl.prototype._read =\n  ServerReadableStreamImpl.prototype._read;\nServerDuplexStreamImpl.prototype._write =\n  ServerWritableStreamImpl.prototype._write;\nServerDuplexStreamImpl.prototype._final =\n  ServerWritableStreamImpl.prototype._final;\n\n// Unary response callback signature.\nexport type sendUnaryData<ResponseType> = (\n  error: ServerErrorResponse | ServerStatusResponse | null,\n  value?: ResponseType | null,\n  trailer?: Metadata,\n  flags?: number\n) => void;\n\n// User provided handler for unary calls.\nexport type handleUnaryCall<RequestType, ResponseType> = (\n  call: ServerUnaryCall<RequestType, ResponseType>,\n  callback: sendUnaryData<ResponseType>\n) => void;\n\n// User provided handler for client streaming calls.\nexport type handleClientStreamingCall<RequestType, ResponseType> = (\n  call: ServerReadableStream<RequestType, ResponseType>,\n  callback: sendUnaryData<ResponseType>\n) => void;\n\n// User provided handler for server streaming calls.\nexport type handleServerStreamingCall<RequestType, ResponseType> = (\n  call: ServerWritableStream<RequestType, ResponseType>\n) => void;\n\n// User provided handler for bidirectional streaming calls.\nexport type handleBidiStreamingCall<RequestType, ResponseType> = (\n  call: ServerDuplexStream<RequestType, ResponseType>\n) => void;\n\nexport type HandleCall<RequestType, ResponseType> =\n  | handleUnaryCall<RequestType, ResponseType>\n  | handleClientStreamingCall<RequestType, ResponseType>\n  | handleServerStreamingCall<RequestType, ResponseType>\n  | handleBidiStreamingCall<RequestType, ResponseType>;\n\nexport interface UnaryHandler<RequestType, ResponseType> {\n  func: handleUnaryCall<RequestType, ResponseType>;\n  serialize: Serialize<ResponseType>;\n  deserialize: Deserialize<RequestType>;\n  type: HandlerType;\n  path: string;\n}\n\nexport interface ClientStreamingHandler<RequestType, ResponseType> {\n  func: handleClientStreamingCall<RequestType, ResponseType>;\n  serialize: Serialize<ResponseType>;\n  deserialize: Deserialize<RequestType>;\n  type: HandlerType;\n  path: string;\n}\n\nexport interface ServerStreamingHandler<RequestType, ResponseType> {\n  func: handleServerStreamingCall<RequestType, ResponseType>;\n  serialize: Serialize<ResponseType>;\n  deserialize: Deserialize<RequestType>;\n  type: HandlerType;\n  path: string;\n}\n\nexport interface BidiStreamingHandler<RequestType, ResponseType> {\n  func: handleBidiStreamingCall<RequestType, ResponseType>;\n  serialize: Serialize<ResponseType>;\n  deserialize: Deserialize<RequestType>;\n  type: HandlerType;\n  path: string;\n}\n\nexport type Handler<RequestType, ResponseType> =\n  | UnaryHandler<RequestType, ResponseType>\n  | ClientStreamingHandler<RequestType, ResponseType>\n  | ServerStreamingHandler<RequestType, ResponseType>\n  | BidiStreamingHandler<RequestType, ResponseType>;\n\nexport type HandlerType = 'bidi' | 'clientStream' | 'serverStream' | 'unary';\n\n// Internal class that wraps the HTTP2 request.\nexport class Http2ServerCallStream<\n  RequestType,\n  ResponseType\n> extends EventEmitter {\n  cancelled = false;\n  deadlineTimer: NodeJS.Timer | null = null;\n  private statusSent = false;\n  private deadline: Deadline = Infinity;\n  private wantTrailers = false;\n  private metadataSent = false;\n  private canPush = false;\n  private isPushPending = false;\n  private bufferedMessages: Array<Buffer | null> = [];\n  private messagesToPush: Array<RequestType | null> = [];\n  private maxSendMessageSize: number = DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n  private maxReceiveMessageSize: number = DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n\n  constructor(\n    private stream: http2.ServerHttp2Stream,\n    private handler: Handler<RequestType, ResponseType>,\n    private options: ChannelOptions\n  ) {\n    super();\n\n    this.stream.once('error', (err: ServerErrorResponse) => {\n      /* We need an error handler to avoid uncaught error event exceptions, but\n       * there is nothing we can reasonably do here. Any error event should\n       * have a corresponding close event, which handles emitting the cancelled\n       * event. And the stream is now in a bad state, so we can't reasonably\n       * expect to be able to send an error over it. */\n    });\n\n    this.stream.once('close', () => {\n      trace(\n        'Request to method ' +\n          this.handler?.path +\n          ' stream closed with rstCode ' +\n          this.stream.rstCode\n      );\n\n      if (!this.statusSent) {\n        this.cancelled = true;\n        this.emit('cancelled', 'cancelled');\n        this.emit('streamEnd', false);\n        this.sendStatus({\n          code: Status.CANCELLED,\n          details: 'Cancelled by client',\n          metadata: null,\n        });\n      }\n    });\n\n    this.stream.on('drain', () => {\n      this.emit('drain');\n    });\n\n    if ('grpc.max_send_message_length' in options) {\n      this.maxSendMessageSize = options['grpc.max_send_message_length']!;\n    }\n    if ('grpc.max_receive_message_length' in options) {\n      this.maxReceiveMessageSize = options['grpc.max_receive_message_length']!;\n    }\n  }\n\n  private checkCancelled(): boolean {\n    /* In some cases the stream can become destroyed before the close event\n     * fires. That creates a race condition that this check works around */\n    if (this.stream.destroyed || this.stream.closed) {\n      this.cancelled = true;\n    }\n    return this.cancelled;\n  }\n\n  private getDecompressedMessage(\n    message: Buffer,\n    encoding: string\n  ): Buffer | Promise<Buffer> {\n    if (encoding === 'deflate') {\n      return inflate(message.subarray(5));\n    } else if (encoding === 'gzip') {\n      return unzip(message.subarray(5));\n    } else if (encoding === 'identity') {\n      return message.subarray(5);\n    }\n\n    return Promise.reject({\n      code: Status.UNIMPLEMENTED,\n      details: `Received message compressed with unsupported encoding \"${encoding}\"`,\n    });\n  }\n\n  sendMetadata(customMetadata?: Metadata) {\n    if (this.checkCancelled()) {\n      return;\n    }\n\n    if (this.metadataSent) {\n      return;\n    }\n\n    this.metadataSent = true;\n    const custom = customMetadata ? customMetadata.toHttp2Headers() : null;\n    // TODO(cjihrig): Include compression headers.\n    const headers = { ...defaultResponseHeaders, ...defaultCompressionHeaders, ...custom };\n    this.stream.respond(headers, defaultResponseOptions);\n  }\n\n  receiveMetadata(headers: http2.IncomingHttpHeaders) {\n    const metadata = Metadata.fromHttp2Headers(headers);\n\n    if (logging.isTracerEnabled(TRACER_NAME)) {\n      trace(\n        'Request to ' +\n          this.handler.path +\n          ' received headers ' +\n          JSON.stringify(metadata.toJSON())\n      );\n    }\n\n    // TODO(cjihrig): Receive compression metadata.\n\n    const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);\n\n    if (timeoutHeader.length > 0) {\n      const match = timeoutHeader[0].toString().match(DEADLINE_REGEX);\n\n      if (match === null) {\n        const err = new Error('Invalid deadline') as ServerErrorResponse;\n        err.code = Status.OUT_OF_RANGE;\n        this.sendError(err);\n        return metadata;\n      }\n\n      const timeout = (+match[1] * deadlineUnitsToMs[match[2]]) | 0;\n\n      const now = new Date();\n      this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);\n      this.deadlineTimer = setTimeout(handleExpiredDeadline, timeout, this);\n      metadata.remove(GRPC_TIMEOUT_HEADER);\n    }\n\n    // Remove several headers that should not be propagated to the application\n    metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);\n    metadata.remove(http2.constants.HTTP2_HEADER_TE);\n    metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);\n    metadata.remove('grpc-accept-encoding');\n\n    return metadata;\n  }\n\n  receiveUnaryMessage(\n    encoding: string,\n    next: (\n      err: Partial<ServerStatusResponse> | null,\n      request?: RequestType\n    ) => void\n  ): void {\n    const { stream } = this;\n\n    let receivedLength = 0;\n    const call = this;\n    const body: Buffer[] = [];\n    const limit = this.maxReceiveMessageSize;\n\n    stream.on('data', onData);\n    stream.on('end', onEnd);\n    stream.on('error', onEnd);\n\n    function onData(chunk: Buffer) {\n      receivedLength += chunk.byteLength;\n\n      if (limit !== -1 && receivedLength > limit) {\n        stream.removeListener('data', onData);\n        stream.removeListener('end', onEnd);\n        stream.removeListener('error', onEnd);\n        next({\n          code: Status.RESOURCE_EXHAUSTED,\n          details: `Received message larger than max (${receivedLength} vs. ${limit})`,\n        });\n        return;\n      }\n\n      body.push(chunk);\n    }\n\n    function onEnd(err?: Error) {\n      stream.removeListener('data', onData);\n      stream.removeListener('end', onEnd);\n      stream.removeListener('error', onEnd);\n\n      if (err !== undefined) {\n        next({ code: Status.INTERNAL, details: err.message });\n        return;\n      }\n\n      if (receivedLength === 0) {\n        next({ code: Status.INTERNAL, details: 'received empty unary message' })\n        return;\n      }\n\n      call.emit('receiveMessage');\n\n      const requestBytes = Buffer.concat(body, receivedLength);\n      const compressed = requestBytes.readUInt8(0) === 1;\n      const compressedMessageEncoding = compressed ? encoding : 'identity';\n      const decompressedMessage = call.getDecompressedMessage(\n        requestBytes,\n        compressedMessageEncoding\n      );\n\n      if (Buffer.isBuffer(decompressedMessage)) {\n        call.safeDeserializeMessage(decompressedMessage, next);\n        return;\n      }\n\n      decompressedMessage.then(\n        (decompressed) => call.safeDeserializeMessage(decompressed, next),\n        (err: any) => next(\n          err.code\n            ? err\n            : {\n                code: Status.INTERNAL,\n                details: `Received \"grpc-encoding\" header \"${encoding}\" but ${encoding} decompression failed`,\n              }\n        )\n      )\n    }\n  }\n\n  private safeDeserializeMessage(\n    buffer: Buffer,\n    next: (err: Partial<ServerStatusResponse> | null, request?: RequestType) => void\n  ) {\n    try {\n      next(null, this.deserializeMessage(buffer));\n    } catch (err) {\n      next({\n        details: getErrorMessage(err),\n        code: Status.INTERNAL\n      });\n    }\n  }\n\n  serializeMessage(value: ResponseType) {\n    const messageBuffer = this.handler.serialize(value);\n\n    // TODO(cjihrig): Call compression aware serializeMessage().\n    const byteLength = messageBuffer.byteLength;\n    const output = Buffer.allocUnsafe(byteLength + 5);\n    output.writeUInt8(0, 0);\n    output.writeUInt32BE(byteLength, 1);\n    messageBuffer.copy(output, 5);\n    return output;\n  }\n\n  deserializeMessage(bytes: Buffer) {\n    return this.handler.deserialize(bytes);\n  }\n\n  async sendUnaryMessage(\n    err: ServerErrorResponse | ServerStatusResponse | null,\n    value?: ResponseType | null,\n    metadata?: Metadata | null,\n    flags?: number\n  ) {\n    if (this.checkCancelled()) {\n      return;\n    }\n\n    if (metadata === undefined) {\n      metadata = null;\n    }\n\n    if (err) {\n      if (!Object.prototype.hasOwnProperty.call(err, 'metadata') && metadata) {\n        err.metadata = metadata;\n      }\n      this.sendError(err);\n      return;\n    }\n\n    try {\n      const response = this.serializeMessage(value!);\n\n      this.write(response);\n      this.sendStatus({ code: Status.OK, details: 'OK', metadata });\n    } catch (err) {\n      this.sendError({\n        details: getErrorMessage(err),\n        code: Status.INTERNAL\n      });\n    }\n  }\n\n  sendStatus(statusObj: PartialStatusObject) {\n    this.emit('callEnd', statusObj.code);\n    this.emit('streamEnd', statusObj.code === Status.OK);\n    if (this.checkCancelled()) {\n      return;\n    }\n\n    trace(\n      'Request to method ' +\n        this.handler?.path +\n        ' ended with status code: ' +\n        Status[statusObj.code] +\n        ' details: ' +\n        statusObj.details\n    );\n\n    if (this.deadlineTimer) clearTimeout(this.deadlineTimer);\n\n    if (this.stream.headersSent) {\n      if (!this.wantTrailers) {\n        this.wantTrailers = true;\n        this.stream.once('wantTrailers', () => {\n          const trailersToSend = {\n            [GRPC_STATUS_HEADER]: statusObj.code,\n            [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details),\n            ...statusObj.metadata?.toHttp2Headers(),\n          };\n  \n          this.stream.sendTrailers(trailersToSend);\n          this.statusSent = true;\n        });\n        this.stream.end();\n      }\n    } else {\n      // Trailers-only response\n      const trailersToSend = {\n        [GRPC_STATUS_HEADER]: statusObj.code,\n        [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details),\n        ...defaultResponseHeaders,\n        ...statusObj.metadata?.toHttp2Headers(),\n      };\n      this.stream.respond(trailersToSend, {endStream: true});\n      this.statusSent = true;\n    }\n  }\n\n  sendError(error: ServerErrorResponse | ServerStatusResponse) {\n    const status: PartialStatusObject = {\n      code: Status.UNKNOWN,\n      details: 'message' in error ? error.message : 'Unknown Error',\n      metadata:\n        'metadata' in error && error.metadata !== undefined\n          ? error.metadata\n          : null,\n    };\n\n    if (\n      'code' in error &&\n      typeof error.code === 'number' &&\n      Number.isInteger(error.code)\n    ) {\n      status.code = error.code;\n\n      if ('details' in error && typeof error.details === 'string') {\n        status.details = error.details!;\n      }\n    }\n\n    this.sendStatus(status);\n  }\n\n  write(chunk: Buffer) {\n    if (this.checkCancelled()) {\n      return;\n    }\n\n    if (\n      this.maxSendMessageSize !== -1 &&\n      chunk.length > this.maxSendMessageSize\n    ) {\n      this.sendError({\n        code: Status.RESOURCE_EXHAUSTED,\n        details: `Sent message larger than max (${chunk.length} vs. ${this.maxSendMessageSize})`,\n      });\n      return;\n    }\n\n    this.sendMetadata();\n    this.emit('sendMessage');\n    return this.stream.write(chunk);\n  }\n\n  resume() {\n    this.stream.resume();\n  }\n\n  setupSurfaceCall(call: ServerSurfaceCall) {\n    this.once('cancelled', (reason) => {\n      call.cancelled = true;\n      call.emit('cancelled', reason);\n    });\n\n    this.once('callEnd', (status) => call.emit('callEnd', status));\n  }\n\n  setupReadable(\n    readable:\n      | ServerReadableStream<RequestType, ResponseType>\n      | ServerDuplexStream<RequestType, ResponseType>,\n    encoding: string\n  ) {\n    const decoder = new StreamDecoder();\n\n    let readsDone = false;\n\n    let pendingMessageProcessing = false;\n\n    let pushedEnd = false;\n\n    const maybePushEnd = async () => {\n      if (!pushedEnd && readsDone && !pendingMessageProcessing) {\n        pushedEnd = true;\n        await this.pushOrBufferMessage(readable, null);\n      }\n    };\n\n    this.stream.on('data', async (data: Buffer) => {\n      const messages = decoder.write(data);\n\n      pendingMessageProcessing = true;\n      this.stream.pause();\n      for (const message of messages) {\n        if (\n          this.maxReceiveMessageSize !== -1 &&\n          message.length > this.maxReceiveMessageSize\n        ) {\n          this.sendError({\n            code: Status.RESOURCE_EXHAUSTED,\n            details: `Received message larger than max (${message.length} vs. ${this.maxReceiveMessageSize})`,\n          });\n          return;\n        }\n        this.emit('receiveMessage');\n\n        const compressed = message.readUInt8(0) === 1;\n        const compressedMessageEncoding = compressed ? encoding : 'identity';\n        const decompressedMessage = await this.getDecompressedMessage(\n          message,\n          compressedMessageEncoding\n        );\n\n        // Encountered an error with decompression; it'll already have been propogated back\n        // Just return early\n        if (!decompressedMessage) return;\n\n        await this.pushOrBufferMessage(readable, decompressedMessage);\n      }\n      pendingMessageProcessing = false;\n      this.stream.resume();\n      await maybePushEnd();\n    });\n\n    this.stream.once('end', async () => {\n      readsDone = true;\n      await maybePushEnd();\n    });\n  }\n\n  consumeUnpushedMessages(\n    readable:\n      | ServerReadableStream<RequestType, ResponseType>\n      | ServerDuplexStream<RequestType, ResponseType>\n  ): boolean {\n    this.canPush = true;\n\n    while (this.messagesToPush.length > 0) {\n      const nextMessage = this.messagesToPush.shift();\n      const canPush = readable.push(nextMessage);\n\n      if (nextMessage === null || canPush === false) {\n        this.canPush = false;\n        break;\n      }\n    }\n\n    return this.canPush;\n  }\n\n  private async pushOrBufferMessage(\n    readable:\n      | ServerReadableStream<RequestType, ResponseType>\n      | ServerDuplexStream<RequestType, ResponseType>,\n    messageBytes: Buffer | null\n  ): Promise<void> {\n    if (this.isPushPending) {\n      this.bufferedMessages.push(messageBytes);\n    } else {\n      await this.pushMessage(readable, messageBytes);\n    }\n  }\n\n  private async pushMessage(\n    readable:\n      | ServerReadableStream<RequestType, ResponseType>\n      | ServerDuplexStream<RequestType, ResponseType>,\n    messageBytes: Buffer | null\n  ) {\n    if (messageBytes === null) {\n      trace('Received end of stream');\n      if (this.canPush) {\n        readable.push(null);\n      } else {\n        this.messagesToPush.push(null);\n      }\n\n      return;\n    }\n\n    trace('Received message of length ' + messageBytes.length);\n\n    this.isPushPending = true;\n\n    try {\n      const deserialized = await this.deserializeMessage(messageBytes);\n\n      if (this.canPush) {\n        if (!readable.push(deserialized)) {\n          this.canPush = false;\n          this.stream.pause();\n        }\n      } else {\n        this.messagesToPush.push(deserialized);\n      }\n    } catch (error) {\n      // Ignore any remaining messages when errors occur.\n      this.bufferedMessages.length = 0;\n      let code = getErrorCode(error);\n      if (code === null || code < Status.OK || code > Status.UNAUTHENTICATED) {\n        code = Status.INTERNAL\n      }\n\n      readable.emit('error', {\n        details: getErrorMessage(error),\n        code: code\n      });\n    }\n\n    this.isPushPending = false;\n\n    if (this.bufferedMessages.length > 0) {\n      await this.pushMessage(\n        readable,\n        this.bufferedMessages.shift() as Buffer | null\n      );\n    }\n  }\n\n  getPeer(): string {\n    const socket = this.stream.session.socket;\n    if (socket.remoteAddress) {\n      if (socket.remotePort) {\n        return `${socket.remoteAddress}:${socket.remotePort}`;\n      } else {\n        return socket.remoteAddress;\n      }\n    } else {\n      return 'unknown';\n    }\n  }\n\n  getDeadline(): Deadline {\n    return this.deadline;\n  }\n\n  getPath(): string {\n    return this.handler.path;\n  }\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\ntype UntypedServerCall = Http2ServerCallStream<any, any>;\n\nfunction handleExpiredDeadline(call: UntypedServerCall) {\n  const err = new Error('Deadline exceeded') as ServerErrorResponse;\n  err.code = Status.DEADLINE_EXCEEDED;\n\n  call.sendError(err);\n  call.cancelled = true;\n  call.emit('cancelled', 'deadline');\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}