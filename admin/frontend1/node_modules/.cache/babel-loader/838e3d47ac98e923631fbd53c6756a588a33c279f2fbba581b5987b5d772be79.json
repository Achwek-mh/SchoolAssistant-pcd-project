{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RetryingCall = exports.MessageBufferTracker = exports.RetryThrottler = void 0;\nconst constants_1 = require(\"./constants\");\nconst metadata_1 = require(\"./metadata\");\nconst logging = require(\"./logging\");\nconst TRACER_NAME = 'retrying_call';\nclass RetryThrottler {\n  constructor(maxTokens, tokenRatio, previousRetryThrottler) {\n    this.maxTokens = maxTokens;\n    this.tokenRatio = tokenRatio;\n    if (previousRetryThrottler) {\n      /* When carrying over tokens from a previous config, rescale them to the\n       * new max value */\n      this.tokens = previousRetryThrottler.tokens * (maxTokens / previousRetryThrottler.maxTokens);\n    } else {\n      this.tokens = maxTokens;\n    }\n  }\n  addCallSucceeded() {\n    this.tokens = Math.max(this.tokens + this.tokenRatio, this.maxTokens);\n  }\n  addCallFailed() {\n    this.tokens = Math.min(this.tokens - 1, 0);\n  }\n  canRetryCall() {\n    return this.tokens > this.maxTokens / 2;\n  }\n}\nexports.RetryThrottler = RetryThrottler;\nclass MessageBufferTracker {\n  constructor(totalLimit, limitPerCall) {\n    this.totalLimit = totalLimit;\n    this.limitPerCall = limitPerCall;\n    this.totalAllocated = 0;\n    this.allocatedPerCall = new Map();\n  }\n  allocate(size, callId) {\n    var _a;\n    const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;\n    if (this.limitPerCall - currentPerCall < size || this.totalLimit - this.totalAllocated < size) {\n      return false;\n    }\n    this.allocatedPerCall.set(callId, currentPerCall + size);\n    this.totalAllocated += size;\n    return true;\n  }\n  free(size, callId) {\n    var _a;\n    if (this.totalAllocated < size) {\n      throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > total allocated ${this.totalAllocated}`);\n    }\n    this.totalAllocated -= size;\n    const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;\n    if (currentPerCall < size) {\n      throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > allocated for call ${currentPerCall}`);\n    }\n    this.allocatedPerCall.set(callId, currentPerCall - size);\n  }\n  freeAll(callId) {\n    var _a;\n    const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;\n    if (this.totalAllocated < currentPerCall) {\n      throw new Error(`Invalid buffer allocation state: call ${callId} allocated ${currentPerCall} > total allocated ${this.totalAllocated}`);\n    }\n    this.totalAllocated -= currentPerCall;\n    this.allocatedPerCall.delete(callId);\n  }\n}\nexports.MessageBufferTracker = MessageBufferTracker;\nconst PREVIONS_RPC_ATTEMPTS_METADATA_KEY = 'grpc-previous-rpc-attempts';\nclass RetryingCall {\n  constructor(channel, callConfig, methodName, host, credentials, deadline, callNumber, bufferTracker, retryThrottler) {\n    this.channel = channel;\n    this.callConfig = callConfig;\n    this.methodName = methodName;\n    this.host = host;\n    this.credentials = credentials;\n    this.deadline = deadline;\n    this.callNumber = callNumber;\n    this.bufferTracker = bufferTracker;\n    this.retryThrottler = retryThrottler;\n    this.listener = null;\n    this.initialMetadata = null;\n    this.underlyingCalls = [];\n    this.writeBuffer = [];\n    /**\n     * The offset of message indices in the writeBuffer. For example, if\n     * writeBufferOffset is 10, message 10 is in writeBuffer[0] and message 15\n     * is in writeBuffer[5].\n     */\n    this.writeBufferOffset = 0;\n    /**\n     * Tracks whether a read has been started, so that we know whether to start\n     * reads on new child calls. This only matters for the first read, because\n     * once a message comes in the child call becomes committed and there will\n     * be no new child calls.\n     */\n    this.readStarted = false;\n    this.transparentRetryUsed = false;\n    /**\n     * Number of attempts so far\n     */\n    this.attempts = 0;\n    this.hedgingTimer = null;\n    this.committedCallIndex = null;\n    this.initialRetryBackoffSec = 0;\n    this.nextRetryBackoffSec = 0;\n    if (callConfig.methodConfig.retryPolicy) {\n      this.state = 'RETRY';\n      const retryPolicy = callConfig.methodConfig.retryPolicy;\n      this.nextRetryBackoffSec = this.initialRetryBackoffSec = Number(retryPolicy.initialBackoff.substring(0, retryPolicy.initialBackoff.length - 1));\n    } else if (callConfig.methodConfig.hedgingPolicy) {\n      this.state = 'HEDGING';\n    } else {\n      this.state = 'TRANSPARENT_ONLY';\n    }\n  }\n  getCallNumber() {\n    return this.callNumber;\n  }\n  trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);\n  }\n  reportStatus(statusObject) {\n    this.trace('ended with status: code=' + statusObject.code + ' details=\"' + statusObject.details + '\"');\n    this.bufferTracker.freeAll(this.callNumber);\n    this.writeBufferOffset = this.writeBufferOffset + this.writeBuffer.length;\n    this.writeBuffer = [];\n    process.nextTick(() => {\n      var _a;\n      // Explicitly construct status object to remove progress field\n      (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus({\n        code: statusObject.code,\n        details: statusObject.details,\n        metadata: statusObject.metadata\n      });\n    });\n  }\n  cancelWithStatus(status, details) {\n    this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\n    this.reportStatus({\n      code: status,\n      details,\n      metadata: new metadata_1.Metadata()\n    });\n    for (const {\n      call\n    } of this.underlyingCalls) {\n      call.cancelWithStatus(status, details);\n    }\n  }\n  getPeer() {\n    if (this.committedCallIndex !== null) {\n      return this.underlyingCalls[this.committedCallIndex].call.getPeer();\n    } else {\n      return 'unknown';\n    }\n  }\n  getBufferEntry(messageIndex) {\n    var _a;\n    return (_a = this.writeBuffer[messageIndex - this.writeBufferOffset]) !== null && _a !== void 0 ? _a : {\n      entryType: 'FREED',\n      allocated: false\n    };\n  }\n  getNextBufferIndex() {\n    return this.writeBufferOffset + this.writeBuffer.length;\n  }\n  clearSentMessages() {\n    if (this.state !== 'COMMITTED') {\n      return;\n    }\n    const earliestNeededMessageIndex = this.underlyingCalls[this.committedCallIndex].nextMessageToSend;\n    for (let messageIndex = this.writeBufferOffset; messageIndex < earliestNeededMessageIndex; messageIndex++) {\n      const bufferEntry = this.getBufferEntry(messageIndex);\n      if (bufferEntry.allocated) {\n        this.bufferTracker.free(bufferEntry.message.message.length, this.callNumber);\n      }\n    }\n    this.writeBuffer = this.writeBuffer.slice(earliestNeededMessageIndex - this.writeBufferOffset);\n    this.writeBufferOffset = earliestNeededMessageIndex;\n  }\n  commitCall(index) {\n    if (this.state === 'COMMITTED') {\n      return;\n    }\n    if (this.underlyingCalls[index].state === 'COMPLETED') {\n      return;\n    }\n    this.trace('Committing call [' + this.underlyingCalls[index].call.getCallNumber() + '] at index ' + index);\n    this.state = 'COMMITTED';\n    this.committedCallIndex = index;\n    for (let i = 0; i < this.underlyingCalls.length; i++) {\n      if (i === index) {\n        continue;\n      }\n      if (this.underlyingCalls[i].state === 'COMPLETED') {\n        continue;\n      }\n      this.underlyingCalls[i].state = 'COMPLETED';\n      this.underlyingCalls[i].call.cancelWithStatus(constants_1.Status.CANCELLED, 'Discarded in favor of other hedged attempt');\n    }\n    this.clearSentMessages();\n  }\n  commitCallWithMostMessages() {\n    if (this.state === 'COMMITTED') {\n      return;\n    }\n    let mostMessages = -1;\n    let callWithMostMessages = -1;\n    for (const [index, childCall] of this.underlyingCalls.entries()) {\n      if (childCall.state === 'ACTIVE' && childCall.nextMessageToSend > mostMessages) {\n        mostMessages = childCall.nextMessageToSend;\n        callWithMostMessages = index;\n      }\n    }\n    if (callWithMostMessages === -1) {\n      /* There are no active calls, disable retries to force the next call that\n       * is started to be committed. */\n      this.state = 'TRANSPARENT_ONLY';\n    } else {\n      this.commitCall(callWithMostMessages);\n    }\n  }\n  isStatusCodeInList(list, code) {\n    return list.some(value => value === code || value.toString().toLowerCase() === constants_1.Status[code].toLowerCase());\n  }\n  getNextRetryBackoffMs() {\n    var _a;\n    const retryPolicy = (_a = this.callConfig) === null || _a === void 0 ? void 0 : _a.methodConfig.retryPolicy;\n    if (!retryPolicy) {\n      return 0;\n    }\n    const nextBackoffMs = Math.random() * this.nextRetryBackoffSec * 1000;\n    const maxBackoffSec = Number(retryPolicy.maxBackoff.substring(0, retryPolicy.maxBackoff.length - 1));\n    this.nextRetryBackoffSec = Math.min(this.nextRetryBackoffSec * retryPolicy.backoffMultiplier, maxBackoffSec);\n    return nextBackoffMs;\n  }\n  maybeRetryCall(pushback, callback) {\n    if (this.state !== 'RETRY') {\n      callback(false);\n      return;\n    }\n    const retryPolicy = this.callConfig.methodConfig.retryPolicy;\n    if (this.attempts >= Math.min(retryPolicy.maxAttempts, 5)) {\n      callback(false);\n      return;\n    }\n    let retryDelayMs;\n    if (pushback === null) {\n      retryDelayMs = this.getNextRetryBackoffMs();\n    } else if (pushback < 0) {\n      this.state = 'TRANSPARENT_ONLY';\n      callback(false);\n      return;\n    } else {\n      retryDelayMs = pushback;\n      this.nextRetryBackoffSec = this.initialRetryBackoffSec;\n    }\n    setTimeout(() => {\n      var _a, _b;\n      if (this.state !== 'RETRY') {\n        callback(false);\n        return;\n      }\n      if ((_b = (_a = this.retryThrottler) === null || _a === void 0 ? void 0 : _a.canRetryCall()) !== null && _b !== void 0 ? _b : true) {\n        callback(true);\n        this.attempts += 1;\n        this.startNewAttempt();\n      }\n    }, retryDelayMs);\n  }\n  countActiveCalls() {\n    let count = 0;\n    for (const call of this.underlyingCalls) {\n      if ((call === null || call === void 0 ? void 0 : call.state) === 'ACTIVE') {\n        count += 1;\n      }\n    }\n    return count;\n  }\n  handleProcessedStatus(status, callIndex, pushback) {\n    var _a, _b, _c;\n    switch (this.state) {\n      case 'COMMITTED':\n      case 'TRANSPARENT_ONLY':\n        this.commitCall(callIndex);\n        this.reportStatus(status);\n        break;\n      case 'HEDGING':\n        if (this.isStatusCodeInList((_a = this.callConfig.methodConfig.hedgingPolicy.nonFatalStatusCodes) !== null && _a !== void 0 ? _a : [], status.code)) {\n          (_b = this.retryThrottler) === null || _b === void 0 ? void 0 : _b.addCallFailed();\n          let delayMs;\n          if (pushback === null) {\n            delayMs = 0;\n          } else if (pushback < 0) {\n            this.state = 'TRANSPARENT_ONLY';\n            this.commitCall(callIndex);\n            this.reportStatus(status);\n            return;\n          } else {\n            delayMs = pushback;\n          }\n          setTimeout(() => {\n            this.maybeStartHedgingAttempt();\n            // If after trying to start a call there are no active calls, this was the last one\n            if (this.countActiveCalls() === 0) {\n              this.commitCall(callIndex);\n              this.reportStatus(status);\n            }\n          }, delayMs);\n        } else {\n          this.commitCall(callIndex);\n          this.reportStatus(status);\n        }\n        break;\n      case 'RETRY':\n        if (this.isStatusCodeInList(this.callConfig.methodConfig.retryPolicy.retryableStatusCodes, status.code)) {\n          (_c = this.retryThrottler) === null || _c === void 0 ? void 0 : _c.addCallFailed();\n          this.maybeRetryCall(pushback, retried => {\n            if (!retried) {\n              this.commitCall(callIndex);\n              this.reportStatus(status);\n            }\n          });\n        } else {\n          this.commitCall(callIndex);\n          this.reportStatus(status);\n        }\n        break;\n    }\n  }\n  getPushback(metadata) {\n    const mdValue = metadata.get('grpc-retry-pushback-ms');\n    if (mdValue.length === 0) {\n      return null;\n    }\n    try {\n      return parseInt(mdValue[0]);\n    } catch (e) {\n      return -1;\n    }\n  }\n  handleChildStatus(status, callIndex) {\n    var _a;\n    if (this.underlyingCalls[callIndex].state === 'COMPLETED') {\n      return;\n    }\n    this.trace('state=' + this.state + ' handling status with progress ' + status.progress + ' from child [' + this.underlyingCalls[callIndex].call.getCallNumber() + '] in state ' + this.underlyingCalls[callIndex].state);\n    this.underlyingCalls[callIndex].state = 'COMPLETED';\n    if (status.code === constants_1.Status.OK) {\n      (_a = this.retryThrottler) === null || _a === void 0 ? void 0 : _a.addCallSucceeded();\n      this.commitCall(callIndex);\n      this.reportStatus(status);\n      return;\n    }\n    if (this.state === 'COMMITTED') {\n      this.reportStatus(status);\n      return;\n    }\n    const pushback = this.getPushback(status.metadata);\n    switch (status.progress) {\n      case 'NOT_STARTED':\n        // RPC never leaves the client, always safe to retry\n        this.startNewAttempt();\n        break;\n      case 'REFUSED':\n        // RPC reaches the server library, but not the server application logic\n        if (this.transparentRetryUsed) {\n          this.handleProcessedStatus(status, callIndex, pushback);\n        } else {\n          this.transparentRetryUsed = true;\n          this.startNewAttempt();\n        }\n        ;\n        break;\n      case 'DROP':\n        this.commitCall(callIndex);\n        this.reportStatus(status);\n        break;\n      case 'PROCESSED':\n        this.handleProcessedStatus(status, callIndex, pushback);\n        break;\n    }\n  }\n  maybeStartHedgingAttempt() {\n    if (this.state !== 'HEDGING') {\n      return;\n    }\n    if (!this.callConfig.methodConfig.hedgingPolicy) {\n      return;\n    }\n    const hedgingPolicy = this.callConfig.methodConfig.hedgingPolicy;\n    if (this.attempts >= Math.min(hedgingPolicy.maxAttempts, 5)) {\n      return;\n    }\n    this.attempts += 1;\n    this.startNewAttempt();\n    this.maybeStartHedgingTimer();\n  }\n  maybeStartHedgingTimer() {\n    var _a, _b, _c;\n    if (this.hedgingTimer) {\n      clearTimeout(this.hedgingTimer);\n    }\n    if (this.state !== 'HEDGING') {\n      return;\n    }\n    if (!this.callConfig.methodConfig.hedgingPolicy) {\n      return;\n    }\n    const hedgingPolicy = this.callConfig.methodConfig.hedgingPolicy;\n    if (this.attempts >= Math.min(hedgingPolicy.maxAttempts, 5)) {\n      return;\n    }\n    const hedgingDelayString = (_a = hedgingPolicy.hedgingDelay) !== null && _a !== void 0 ? _a : '0s';\n    const hedgingDelaySec = Number(hedgingDelayString.substring(0, hedgingDelayString.length - 1));\n    this.hedgingTimer = setTimeout(() => {\n      this.maybeStartHedgingAttempt();\n    }, hedgingDelaySec * 1000);\n    (_c = (_b = this.hedgingTimer).unref) === null || _c === void 0 ? void 0 : _c.call(_b);\n  }\n  startNewAttempt() {\n    const child = this.channel.createLoadBalancingCall(this.callConfig, this.methodName, this.host, this.credentials, this.deadline);\n    this.trace('Created child call [' + child.getCallNumber() + '] for attempt ' + this.attempts);\n    const index = this.underlyingCalls.length;\n    this.underlyingCalls.push({\n      state: 'ACTIVE',\n      call: child,\n      nextMessageToSend: 0\n    });\n    const previousAttempts = this.attempts - 1;\n    const initialMetadata = this.initialMetadata.clone();\n    if (previousAttempts > 0) {\n      initialMetadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\n    }\n    let receivedMetadata = false;\n    child.start(initialMetadata, {\n      onReceiveMetadata: metadata => {\n        this.trace('Received metadata from child [' + child.getCallNumber() + ']');\n        this.commitCall(index);\n        receivedMetadata = true;\n        if (previousAttempts > 0) {\n          metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\n        }\n        if (this.underlyingCalls[index].state === 'ACTIVE') {\n          this.listener.onReceiveMetadata(metadata);\n        }\n      },\n      onReceiveMessage: message => {\n        this.trace('Received message from child [' + child.getCallNumber() + ']');\n        this.commitCall(index);\n        if (this.underlyingCalls[index].state === 'ACTIVE') {\n          this.listener.onReceiveMessage(message);\n        }\n      },\n      onReceiveStatus: status => {\n        this.trace('Received status from child [' + child.getCallNumber() + ']');\n        if (!receivedMetadata && previousAttempts > 0) {\n          status.metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\n        }\n        this.handleChildStatus(status, index);\n      }\n    });\n    this.sendNextChildMessage(index);\n    if (this.readStarted) {\n      child.startRead();\n    }\n  }\n  start(metadata, listener) {\n    this.trace('start called');\n    this.listener = listener;\n    this.initialMetadata = metadata;\n    this.attempts += 1;\n    this.startNewAttempt();\n    this.maybeStartHedgingTimer();\n  }\n  handleChildWriteCompleted(childIndex) {\n    var _a, _b;\n    const childCall = this.underlyingCalls[childIndex];\n    const messageIndex = childCall.nextMessageToSend;\n    (_b = (_a = this.getBufferEntry(messageIndex)).callback) === null || _b === void 0 ? void 0 : _b.call(_a);\n    this.clearSentMessages();\n    childCall.nextMessageToSend += 1;\n    this.sendNextChildMessage(childIndex);\n  }\n  sendNextChildMessage(childIndex) {\n    const childCall = this.underlyingCalls[childIndex];\n    if (childCall.state === 'COMPLETED') {\n      return;\n    }\n    if (this.getBufferEntry(childCall.nextMessageToSend)) {\n      const bufferEntry = this.getBufferEntry(childCall.nextMessageToSend);\n      switch (bufferEntry.entryType) {\n        case 'MESSAGE':\n          childCall.call.sendMessageWithContext({\n            callback: error => {\n              // Ignore error\n              this.handleChildWriteCompleted(childIndex);\n            }\n          }, bufferEntry.message.message);\n          break;\n        case 'HALF_CLOSE':\n          childCall.nextMessageToSend += 1;\n          childCall.call.halfClose();\n          break;\n        case 'FREED':\n          // Should not be possible\n          break;\n      }\n    }\n  }\n  sendMessageWithContext(context, message) {\n    var _a;\n    this.trace('write() called with message of length ' + message.length);\n    const writeObj = {\n      message,\n      flags: context.flags\n    };\n    const messageIndex = this.getNextBufferIndex();\n    const bufferEntry = {\n      entryType: 'MESSAGE',\n      message: writeObj,\n      allocated: this.bufferTracker.allocate(message.length, this.callNumber)\n    };\n    this.writeBuffer.push(bufferEntry);\n    if (bufferEntry.allocated) {\n      (_a = context.callback) === null || _a === void 0 ? void 0 : _a.call(context);\n      for (const [callIndex, call] of this.underlyingCalls.entries()) {\n        if (call.state === 'ACTIVE' && call.nextMessageToSend === messageIndex) {\n          call.call.sendMessageWithContext({\n            callback: error => {\n              // Ignore error\n              this.handleChildWriteCompleted(callIndex);\n            }\n          }, message);\n        }\n      }\n    } else {\n      this.commitCallWithMostMessages();\n      // commitCallWithMostMessages can fail if we are between ping attempts\n      if (this.committedCallIndex === null) {\n        return;\n      }\n      const call = this.underlyingCalls[this.committedCallIndex];\n      bufferEntry.callback = context.callback;\n      if (call.state === 'ACTIVE' && call.nextMessageToSend === messageIndex) {\n        call.call.sendMessageWithContext({\n          callback: error => {\n            // Ignore error\n            this.handleChildWriteCompleted(this.committedCallIndex);\n          }\n        }, message);\n      }\n    }\n  }\n  startRead() {\n    this.trace('startRead called');\n    this.readStarted = true;\n    for (const underlyingCall of this.underlyingCalls) {\n      if ((underlyingCall === null || underlyingCall === void 0 ? void 0 : underlyingCall.state) === 'ACTIVE') {\n        underlyingCall.call.startRead();\n      }\n    }\n  }\n  halfClose() {\n    this.trace('halfClose called');\n    const halfCloseIndex = this.getNextBufferIndex();\n    this.writeBuffer.push({\n      entryType: 'HALF_CLOSE',\n      allocated: false\n    });\n    for (const call of this.underlyingCalls) {\n      if ((call === null || call === void 0 ? void 0 : call.state) === 'ACTIVE' && call.nextMessageToSend === halfCloseIndex) {\n        call.nextMessageToSend += 1;\n        call.call.halfClose();\n      }\n    }\n  }\n  setCredentials(newCredentials) {\n    throw new Error(\"Method not implemented.\");\n  }\n  getMethod() {\n    return this.methodName;\n  }\n  getHost() {\n    return this.host;\n  }\n}\nexports.RetryingCall = RetryingCall;","map":{"version":3,"mappings":";;AAAA;;;;;;;;;;;;;;;;;;;;AAkBA;AAEA;AAEA;AAKA,MAAMA,WAAW,GAAG,eAAe;AAEnC,MAAaC,cAAc;EAEzBC,YAA6BC,SAAiB,EAAmBC,UAAkB,EAAEC,sBAAuC;IAA/F,cAAS,GAATF,SAAS;IAA2B,eAAU,GAAVC,UAAU;IACzE,IAAIC,sBAAsB,EAAE;MAC1B;;MAEA,IAAI,CAACC,MAAM,GAAGD,sBAAsB,CAACC,MAAM,IAAIH,SAAS,GAAGE,sBAAsB,CAACF,SAAS,CAAC;KAC7F,MAAM;MACL,IAAI,CAACG,MAAM,GAAGH,SAAS;;EAE3B;EAEAI,gBAAgB;IACd,IAAI,CAACD,MAAM,GAAGE,IAAI,CAACC,GAAG,CAAC,IAAI,CAACH,MAAM,GAAG,IAAI,CAACF,UAAU,EAAE,IAAI,CAACD,SAAS,CAAC;EACvE;EAEAO,aAAa;IACX,IAAI,CAACJ,MAAM,GAAGE,IAAI,CAACG,GAAG,CAAC,IAAI,CAACL,MAAM,GAAG,CAAC,EAAE,CAAC,CAAC;EAC5C;EAEAM,YAAY;IACV,OAAO,IAAI,CAACN,MAAM,GAAG,IAAI,CAACH,SAAS,GAAG,CAAC;EACzC;;AAtBFU;AAyBA,MAAaC,oBAAoB;EAI/BZ,YAAoBa,UAAkB,EAAUC,YAAoB;IAAhD,eAAU,GAAVD,UAAU;IAAkB,iBAAY,GAAZC,YAAY;IAHpD,mBAAc,GAAW,CAAC;IAC1B,qBAAgB,GAAwB,IAAIC,GAAG,EAAkB;EAEF;EAEvEC,QAAQ,CAACC,IAAY,EAAEC,MAAc;;IACnC,MAAMC,cAAc,GAAG,UAAI,CAACC,gBAAgB,CAACC,GAAG,CAACH,MAAM,CAAC,mCAAI,CAAC;IAC7D,IAAI,IAAI,CAACJ,YAAY,GAAGK,cAAc,GAAGF,IAAI,IAAI,IAAI,CAACJ,UAAU,GAAG,IAAI,CAACS,cAAc,GAAGL,IAAI,EAAE;MAC7F,OAAO,KAAK;;IAEd,IAAI,CAACG,gBAAgB,CAACG,GAAG,CAACL,MAAM,EAAEC,cAAc,GAAGF,IAAI,CAAC;IACxD,IAAI,CAACK,cAAc,IAAIL,IAAI;IAC3B,OAAO,IAAI;EACb;EAEAO,IAAI,CAACP,IAAY,EAAEC,MAAc;;IAC/B,IAAI,IAAI,CAACI,cAAc,GAAGL,IAAI,EAAE;MAC9B,MAAM,IAAIQ,KAAK,CAAC,yCAAyCP,MAAM,UAAUD,IAAI,sBAAsB,IAAI,CAACK,cAAc,EAAE,CAAC;;IAE3H,IAAI,CAACA,cAAc,IAAIL,IAAI;IAC3B,MAAME,cAAc,GAAG,UAAI,CAACC,gBAAgB,CAACC,GAAG,CAACH,MAAM,CAAC,mCAAI,CAAC;IAC7D,IAAIC,cAAc,GAAGF,IAAI,EAAE;MACzB,MAAM,IAAIQ,KAAK,CAAC,yCAAyCP,MAAM,UAAUD,IAAI,yBAAyBE,cAAc,EAAE,CAAC;;IAEzH,IAAI,CAACC,gBAAgB,CAACG,GAAG,CAACL,MAAM,EAAEC,cAAc,GAAGF,IAAI,CAAC;EAC1D;EAEAS,OAAO,CAACR,MAAc;;IACpB,MAAMC,cAAc,GAAG,UAAI,CAACC,gBAAgB,CAACC,GAAG,CAACH,MAAM,CAAC,mCAAI,CAAC;IAC7D,IAAI,IAAI,CAACI,cAAc,GAAGH,cAAc,EAAE;MACxC,MAAM,IAAIM,KAAK,CAAC,yCAAyCP,MAAM,cAAcC,cAAc,sBAAsB,IAAI,CAACG,cAAc,EAAE,CAAC;;IAEzI,IAAI,CAACA,cAAc,IAAIH,cAAc;IACrC,IAAI,CAACC,gBAAgB,CAACO,MAAM,CAACT,MAAM,CAAC;EACtC;;AAnCFP;AA2FA,MAAMiB,kCAAkC,GAAG,4BAA4B;AAEvE,MAAaC,YAAY;EA4BvB7B,YACmB8B,OAAwB,EACxBC,UAAsB,EACtBC,UAAkB,EAClBC,IAAY,EACZC,WAA4B,EAC5BC,QAAkB,EAClBC,UAAkB,EAClBC,aAAmC,EACnCC,cAA+B;IAR/B,YAAO,GAAPR,OAAO;IACP,eAAU,GAAVC,UAAU;IACV,eAAU,GAAVC,UAAU;IACV,SAAI,GAAJC,IAAI;IACJ,gBAAW,GAAXC,WAAW;IACX,aAAQ,GAARC,QAAQ;IACR,eAAU,GAAVC,UAAU;IACV,kBAAa,GAAbC,aAAa;IACb,mBAAc,GAAdC,cAAc;IAnCzB,aAAQ,GAAgC,IAAI;IAC5C,oBAAe,GAAoB,IAAI;IACvC,oBAAe,GAAqB,EAAE;IACtC,gBAAW,GAAuB,EAAE;IAC5C;;;;;IAKQ,sBAAiB,GAAG,CAAC;IAC7B;;;;;;IAMQ,gBAAW,GAAG,KAAK;IACnB,yBAAoB,GAAY,KAAK;IAC7C;;;IAGQ,aAAQ,GAAW,CAAC;IACpB,iBAAY,GAAwB,IAAI;IACxC,uBAAkB,GAAkB,IAAI;IACxC,2BAAsB,GAAG,CAAC;IAC1B,wBAAmB,GAAG,CAAC;IAY7B,IAAIP,UAAU,CAACQ,YAAY,CAACC,WAAW,EAAE;MACvC,IAAI,CAACC,KAAK,GAAG,OAAO;MACpB,MAAMD,WAAW,GAAGT,UAAU,CAACQ,YAAY,CAACC,WAAW;MACvD,IAAI,CAACE,mBAAmB,GAAG,IAAI,CAACC,sBAAsB,GAAGC,MAAM,CAACJ,WAAW,CAACK,cAAc,CAACC,SAAS,CAAC,CAAC,EAAEN,WAAW,CAACK,cAAc,CAACE,MAAM,GAAG,CAAC,CAAC,CAAC;KAChJ,MAAM,IAAIhB,UAAU,CAACQ,YAAY,CAACS,aAAa,EAAE;MAChD,IAAI,CAACP,KAAK,GAAG,SAAS;KACvB,MAAM;MACL,IAAI,CAACA,KAAK,GAAG,kBAAkB;;EAEnC;EACAQ,aAAa;IACX,OAAO,IAAI,CAACb,UAAU;EACxB;EAEQc,KAAK,CAACC,IAAY;IACxBC,OAAO,CAACF,KAAK,CACXG,wBAAY,CAACC,KAAK,EAClBxD,WAAW,EACX,GAAG,GAAG,IAAI,CAACsC,UAAU,GAAG,IAAI,GAAGe,IAAI,CACpC;EACH;EAEQI,YAAY,CAACC,YAA0B;IAC7C,IAAI,CAACN,KAAK,CAAC,0BAA0B,GAAGM,YAAY,CAACC,IAAI,GAAG,YAAY,GAAGD,YAAY,CAACE,OAAO,GAAG,GAAG,CAAC;IACtG,IAAI,CAACrB,aAAa,CAACX,OAAO,CAAC,IAAI,CAACU,UAAU,CAAC;IAC3C,IAAI,CAACuB,iBAAiB,GAAG,IAAI,CAACA,iBAAiB,GAAG,IAAI,CAACC,WAAW,CAACb,MAAM;IACzE,IAAI,CAACa,WAAW,GAAG,EAAE;IACrBC,OAAO,CAACC,QAAQ,CAAC,MAAK;;MACpB;MACA,UAAI,CAACC,QAAQ,0CAAEC,eAAe,CAAC;QAC7BP,IAAI,EAAED,YAAY,CAACC,IAAI;QACvBC,OAAO,EAAEF,YAAY,CAACE,OAAO;QAC7BO,QAAQ,EAAET,YAAY,CAACS;OACxB,CAAC;IACJ,CAAC,CAAC;EACJ;EAEAC,gBAAgB,CAACC,MAAc,EAAET,OAAe;IAC9C,IAAI,CAACR,KAAK,CAAC,yBAAyB,GAAGiB,MAAM,GAAG,aAAa,GAAGT,OAAO,GAAG,GAAG,CAAC;IAC9E,IAAI,CAACH,YAAY,CAAC;MAACE,IAAI,EAAEU,MAAM;MAAET,OAAO;MAAEO,QAAQ,EAAE,IAAIG,mBAAQ;IAAE,CAAC,CAAC;IACpE,KAAK,MAAM;MAACC;IAAI,CAAC,IAAI,IAAI,CAACC,eAAe,EAAE;MACzCD,IAAI,CAACH,gBAAgB,CAACC,MAAM,EAAET,OAAO,CAAC;;EAE1C;EACAa,OAAO;IACL,IAAI,IAAI,CAACC,kBAAkB,KAAK,IAAI,EAAE;MACpC,OAAO,IAAI,CAACF,eAAe,CAAC,IAAI,CAACE,kBAAkB,CAAC,CAACH,IAAI,CAACE,OAAO,EAAE;KACpE,MAAM;MACL,OAAO,SAAS;;EAEpB;EAEQE,cAAc,CAACC,YAAoB;;IACzC,OAAO,UAAI,CAACd,WAAW,CAACc,YAAY,GAAG,IAAI,CAACf,iBAAiB,CAAC,mCAAI;MAACgB,SAAS,EAAE,OAAO;MAAEC,SAAS,EAAE;IAAK,CAAC;EAC1G;EAEQC,kBAAkB;IACxB,OAAO,IAAI,CAAClB,iBAAiB,GAAG,IAAI,CAACC,WAAW,CAACb,MAAM;EACzD;EAEQ+B,iBAAiB;IACvB,IAAI,IAAI,CAACrC,KAAK,KAAK,WAAW,EAAE;MAC9B;;IAEF,MAAMsC,0BAA0B,GAAG,IAAI,CAACT,eAAe,CAAC,IAAI,CAACE,kBAAmB,CAAC,CAACQ,iBAAiB;IACnG,KAAK,IAAIN,YAAY,GAAG,IAAI,CAACf,iBAAiB,EAAEe,YAAY,GAAGK,0BAA0B,EAAEL,YAAY,EAAE,EAAE;MACzG,MAAMO,WAAW,GAAG,IAAI,CAACR,cAAc,CAACC,YAAY,CAAC;MACrD,IAAIO,WAAW,CAACL,SAAS,EAAE;QACzB,IAAI,CAACvC,aAAa,CAACb,IAAI,CAACyD,WAAW,CAACC,OAAQ,CAACA,OAAO,CAACnC,MAAM,EAAE,IAAI,CAACX,UAAU,CAAC;;;IAGjF,IAAI,CAACwB,WAAW,GAAG,IAAI,CAACA,WAAW,CAACuB,KAAK,CAACJ,0BAA0B,GAAG,IAAI,CAACpB,iBAAiB,CAAC;IAC9F,IAAI,CAACA,iBAAiB,GAAGoB,0BAA0B;EACrD;EAEQK,UAAU,CAACC,KAAa;IAC9B,IAAI,IAAI,CAAC5C,KAAK,KAAK,WAAW,EAAE;MAC9B;;IAEF,IAAI,IAAI,CAAC6B,eAAe,CAACe,KAAK,CAAC,CAAC5C,KAAK,KAAK,WAAW,EAAE;MACrD;;IAEF,IAAI,CAACS,KAAK,CAAC,mBAAmB,GAAG,IAAI,CAACoB,eAAe,CAACe,KAAK,CAAC,CAAChB,IAAI,CAACpB,aAAa,EAAE,GAAG,aAAa,GAAGoC,KAAK,CAAC;IAC1G,IAAI,CAAC5C,KAAK,GAAG,WAAW;IACxB,IAAI,CAAC+B,kBAAkB,GAAGa,KAAK;IAC/B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAChB,eAAe,CAACvB,MAAM,EAAEuC,CAAC,EAAE,EAAE;MACpD,IAAIA,CAAC,KAAKD,KAAK,EAAE;QACf;;MAEF,IAAI,IAAI,CAACf,eAAe,CAACgB,CAAC,CAAC,CAAC7C,KAAK,KAAK,WAAW,EAAE;QACjD;;MAEF,IAAI,CAAC6B,eAAe,CAACgB,CAAC,CAAC,CAAC7C,KAAK,GAAG,WAAW;MAC3C,IAAI,CAAC6B,eAAe,CAACgB,CAAC,CAAC,CAACjB,IAAI,CAACH,gBAAgB,CAACb,kBAAM,CAACkC,SAAS,EAAE,4CAA4C,CAAC;;IAE/G,IAAI,CAACT,iBAAiB,EAAE;EAC1B;EAEQU,0BAA0B;IAChC,IAAI,IAAI,CAAC/C,KAAK,KAAK,WAAW,EAAE;MAC9B;;IAEF,IAAIgD,YAAY,GAAG,CAAC,CAAC;IACrB,IAAIC,oBAAoB,GAAG,CAAC,CAAC;IAC7B,KAAK,MAAM,CAACL,KAAK,EAAEM,SAAS,CAAC,IAAI,IAAI,CAACrB,eAAe,CAACsB,OAAO,EAAE,EAAE;MAC/D,IAAID,SAAS,CAAClD,KAAK,KAAK,QAAQ,IAAIkD,SAAS,CAACX,iBAAiB,GAAGS,YAAY,EAAE;QAC9EA,YAAY,GAAGE,SAAS,CAACX,iBAAiB;QAC1CU,oBAAoB,GAAGL,KAAK;;;IAGhC,IAAIK,oBAAoB,KAAK,CAAC,CAAC,EAAE;MAC/B;;MAEA,IAAI,CAACjD,KAAK,GAAG,kBAAkB;KAChC,MAAM;MACL,IAAI,CAAC2C,UAAU,CAACM,oBAAoB,CAAC;;EAEzC;EAEQG,kBAAkB,CAACC,IAAyB,EAAErC,IAAY;IAChE,OAAOqC,IAAI,CAACC,IAAI,CAAEC,KAAK,IAAIA,KAAK,KAAKvC,IAAI,IAAIuC,KAAK,CAACC,QAAQ,EAAE,CAACC,WAAW,EAAE,KAAK7C,kBAAM,CAACI,IAAI,CAAC,CAACyC,WAAW,EAAE,CAAE;EAC9G;EAEQC,qBAAqB;;IAC3B,MAAM3D,WAAW,GAAG,UAAI,CAACT,UAAU,0CAAEQ,YAAY,CAACC,WAAW;IAC7D,IAAI,CAACA,WAAW,EAAE;MAChB,OAAO,CAAC;;IAEV,MAAM4D,aAAa,GAAG9F,IAAI,CAAC+F,MAAM,EAAE,GAAG,IAAI,CAAC3D,mBAAmB,GAAG,IAAI;IACrE,MAAM4D,aAAa,GAAG1D,MAAM,CAACJ,WAAW,CAAC+D,UAAU,CAACzD,SAAS,CAAC,CAAC,EAAEN,WAAW,CAAC+D,UAAU,CAACxD,MAAM,GAAG,CAAC,CAAC,CAAC;IACpG,IAAI,CAACL,mBAAmB,GAAGpC,IAAI,CAACG,GAAG,CAAC,IAAI,CAACiC,mBAAmB,GAAGF,WAAW,CAACgE,iBAAiB,EAAEF,aAAa,CAAC;IAC5G,OAAOF,aAAa;EACtB;EAEQK,cAAc,CAACC,QAAuB,EAAEC,QAAoC;IAClF,IAAI,IAAI,CAAClE,KAAK,KAAK,OAAO,EAAE;MAC1BkE,QAAQ,CAAC,KAAK,CAAC;MACf;;IAEF,MAAMnE,WAAW,GAAG,IAAI,CAACT,UAAW,CAACQ,YAAY,CAACC,WAAY;IAC9D,IAAI,IAAI,CAACoE,QAAQ,IAAItG,IAAI,CAACG,GAAG,CAAC+B,WAAW,CAACqE,WAAW,EAAE,CAAC,CAAC,EAAE;MACzDF,QAAQ,CAAC,KAAK,CAAC;MACf;;IAEF,IAAIG,YAAoB;IACxB,IAAIJ,QAAQ,KAAK,IAAI,EAAE;MACrBI,YAAY,GAAG,IAAI,CAACX,qBAAqB,EAAE;KAC5C,MAAM,IAAIO,QAAQ,GAAG,CAAC,EAAE;MACvB,IAAI,CAACjE,KAAK,GAAG,kBAAkB;MAC/BkE,QAAQ,CAAC,KAAK,CAAC;MACf;KACD,MAAM;MACLG,YAAY,GAAGJ,QAAQ;MACvB,IAAI,CAAChE,mBAAmB,GAAG,IAAI,CAACC,sBAAsB;;IAExDoE,UAAU,CAAC,MAAK;;MACd,IAAI,IAAI,CAACtE,KAAK,KAAK,OAAO,EAAE;QAC1BkE,QAAQ,CAAC,KAAK,CAAC;QACf;;MAEF,IAAI,gBAAI,CAACrE,cAAc,0CAAE5B,YAAY,EAAE,mCAAI,IAAI,EAAE;QAC/CiG,QAAQ,CAAC,IAAI,CAAC;QACd,IAAI,CAACC,QAAQ,IAAI,CAAC;QAClB,IAAI,CAACI,eAAe,EAAE;;IAE1B,CAAC,EAAEF,YAAY,CAAC;EAClB;EAEQG,gBAAgB;IACtB,IAAIC,KAAK,GAAG,CAAC;IACb,KAAK,MAAM7C,IAAI,IAAI,IAAI,CAACC,eAAe,EAAE;MACvC,IAAI,KAAI,aAAJD,IAAI,uBAAJA,IAAI,CAAE5B,KAAK,MAAK,QAAQ,EAAE;QAC5ByE,KAAK,IAAI,CAAC;;;IAGd,OAAOA,KAAK;EACd;EAEQC,qBAAqB,CAAChD,MAAoB,EAAEiD,SAAiB,EAAEV,QAAuB;;IAC5F,QAAQ,IAAI,CAACjE,KAAK;MAChB,KAAK,WAAW;MAChB,KAAK,kBAAkB;QACrB,IAAI,CAAC2C,UAAU,CAACgC,SAAS,CAAC;QAC1B,IAAI,CAAC7D,YAAY,CAACY,MAAM,CAAC;QACzB;MACF,KAAK,SAAS;QACZ,IAAI,IAAI,CAAC0B,kBAAkB,CAAC,UAAI,CAAC9D,UAAW,CAACQ,YAAY,CAACS,aAAc,CAACqE,mBAAmB,mCAAI,EAAE,EAAElD,MAAM,CAACV,IAAI,CAAC,EAAE;UAChH,UAAI,CAACnB,cAAc,0CAAE9B,aAAa,EAAE;UACpC,IAAI8G,OAAe;UACnB,IAAIZ,QAAQ,KAAK,IAAI,EAAE;YACrBY,OAAO,GAAG,CAAC;WACZ,MAAM,IAAIZ,QAAQ,GAAG,CAAC,EAAE;YACvB,IAAI,CAACjE,KAAK,GAAG,kBAAkB;YAC/B,IAAI,CAAC2C,UAAU,CAACgC,SAAS,CAAC;YAC1B,IAAI,CAAC7D,YAAY,CAACY,MAAM,CAAC;YACzB;WACD,MAAM;YACLmD,OAAO,GAAGZ,QAAQ;;UAEpBK,UAAU,CAAC,MAAK;YACd,IAAI,CAACQ,wBAAwB,EAAE;YAC/B;YACA,IAAI,IAAI,CAACN,gBAAgB,EAAE,KAAK,CAAC,EAAE;cACjC,IAAI,CAAC7B,UAAU,CAACgC,SAAS,CAAC;cAC1B,IAAI,CAAC7D,YAAY,CAACY,MAAM,CAAC;;UAE7B,CAAC,EAAEmD,OAAO,CAAC;SACZ,MAAM;UACL,IAAI,CAAClC,UAAU,CAACgC,SAAS,CAAC;UAC1B,IAAI,CAAC7D,YAAY,CAACY,MAAM,CAAC;;QAE3B;MACF,KAAK,OAAO;QACV,IAAI,IAAI,CAAC0B,kBAAkB,CAAC,IAAI,CAAC9D,UAAW,CAACQ,YAAY,CAACC,WAAY,CAACgF,oBAAoB,EAAErD,MAAM,CAACV,IAAI,CAAC,EAAE;UACzG,UAAI,CAACnB,cAAc,0CAAE9B,aAAa,EAAE;UACpC,IAAI,CAACiG,cAAc,CAACC,QAAQ,EAAGe,OAAO,IAAI;YACxC,IAAI,CAACA,OAAO,EAAE;cACZ,IAAI,CAACrC,UAAU,CAACgC,SAAS,CAAC;cAC1B,IAAI,CAAC7D,YAAY,CAACY,MAAM,CAAC;;UAE7B,CAAC,CAAC;SACH,MAAM;UACL,IAAI,CAACiB,UAAU,CAACgC,SAAS,CAAC;UAC1B,IAAI,CAAC7D,YAAY,CAACY,MAAM,CAAC;;QAE3B;IAAM;EAEZ;EAEQuD,WAAW,CAACzD,QAAkB;IACpC,MAAM0D,OAAO,GAAG1D,QAAQ,CAAC5C,GAAG,CAAC,wBAAwB,CAAC;IACtD,IAAIsG,OAAO,CAAC5E,MAAM,KAAK,CAAC,EAAE;MACxB,OAAO,IAAI;;IAEb,IAAI;MACF,OAAO6E,QAAQ,CAACD,OAAO,CAAC,CAAC,CAAW,CAAC;KACtC,CAAC,OAAOE,CAAC,EAAE;MACV,OAAO,CAAC,CAAC;;EAEb;EAEQC,iBAAiB,CAAC3D,MAAgC,EAAEiD,SAAiB;;IAC3E,IAAI,IAAI,CAAC9C,eAAe,CAAC8C,SAAS,CAAC,CAAC3E,KAAK,KAAK,WAAW,EAAE;MACzD;;IAEF,IAAI,CAACS,KAAK,CAAC,QAAQ,GAAG,IAAI,CAACT,KAAK,GAAG,iCAAiC,GAAG0B,MAAM,CAAC4D,QAAQ,GAAG,eAAe,GAAG,IAAI,CAACzD,eAAe,CAAC8C,SAAS,CAAC,CAAC/C,IAAI,CAACpB,aAAa,EAAE,GAAG,aAAa,GAAG,IAAI,CAACqB,eAAe,CAAC8C,SAAS,CAAC,CAAC3E,KAAK,CAAC;IACxN,IAAI,CAAC6B,eAAe,CAAC8C,SAAS,CAAC,CAAC3E,KAAK,GAAG,WAAW;IACnD,IAAI0B,MAAM,CAACV,IAAI,KAAKJ,kBAAM,CAAC2E,EAAE,EAAE;MAC7B,UAAI,CAAC1F,cAAc,0CAAEjC,gBAAgB,EAAE;MACvC,IAAI,CAAC+E,UAAU,CAACgC,SAAS,CAAC;MAC1B,IAAI,CAAC7D,YAAY,CAACY,MAAM,CAAC;MACzB;;IAEF,IAAI,IAAI,CAAC1B,KAAK,KAAK,WAAW,EAAE;MAC9B,IAAI,CAACc,YAAY,CAACY,MAAM,CAAC;MACzB;;IAEF,MAAMuC,QAAQ,GAAG,IAAI,CAACgB,WAAW,CAACvD,MAAM,CAACF,QAAQ,CAAC;IAClD,QAAQE,MAAM,CAAC4D,QAAQ;MACrB,KAAK,aAAa;QAChB;QACA,IAAI,CAACf,eAAe,EAAE;QACtB;MACF,KAAK,SAAS;QACZ;QACA,IAAI,IAAI,CAACiB,oBAAoB,EAAE;UAC7B,IAAI,CAACd,qBAAqB,CAAChD,MAAM,EAAEiD,SAAS,EAAEV,QAAQ,CAAC;SACxD,MAAM;UACL,IAAI,CAACuB,oBAAoB,GAAG,IAAI;UAChC,IAAI,CAACjB,eAAe,EAAE;;QACvB;QACD;MACF,KAAK,MAAM;QACT,IAAI,CAAC5B,UAAU,CAACgC,SAAS,CAAC;QAC1B,IAAI,CAAC7D,YAAY,CAACY,MAAM,CAAC;QACzB;MACF,KAAK,WAAW;QACd,IAAI,CAACgD,qBAAqB,CAAChD,MAAM,EAAEiD,SAAS,EAAEV,QAAQ,CAAC;QACvD;IAAM;EAEZ;EAEQa,wBAAwB;IAC9B,IAAI,IAAI,CAAC9E,KAAK,KAAK,SAAS,EAAE;MAC5B;;IAEF,IAAI,CAAC,IAAI,CAACV,UAAU,CAACQ,YAAY,CAACS,aAAa,EAAE;MAC/C;;IAEF,MAAMA,aAAa,GAAG,IAAI,CAACjB,UAAU,CAACQ,YAAY,CAACS,aAAa;IAChE,IAAI,IAAI,CAAC4D,QAAQ,IAAItG,IAAI,CAACG,GAAG,CAACuC,aAAa,CAAC6D,WAAW,EAAE,CAAC,CAAC,EAAE;MAC3D;;IAEF,IAAI,CAACD,QAAQ,IAAI,CAAC;IAClB,IAAI,CAACI,eAAe,EAAE;IACtB,IAAI,CAACkB,sBAAsB,EAAE;EAC/B;EAEQA,sBAAsB;;IAC5B,IAAI,IAAI,CAACC,YAAY,EAAE;MACrBC,YAAY,CAAC,IAAI,CAACD,YAAY,CAAC;;IAEjC,IAAI,IAAI,CAAC1F,KAAK,KAAK,SAAS,EAAE;MAC5B;;IAEF,IAAI,CAAC,IAAI,CAACV,UAAU,CAACQ,YAAY,CAACS,aAAa,EAAE;MAC/C;;IAEF,MAAMA,aAAa,GAAG,IAAI,CAACjB,UAAU,CAACQ,YAAY,CAACS,aAAa;IAChE,IAAI,IAAI,CAAC4D,QAAQ,IAAItG,IAAI,CAACG,GAAG,CAACuC,aAAa,CAAC6D,WAAW,EAAE,CAAC,CAAC,EAAE;MAC3D;;IAEF,MAAMwB,kBAAkB,GAAG,mBAAa,CAACC,YAAY,mCAAI,IAAI;IAC7D,MAAMC,eAAe,GAAG3F,MAAM,CAACyF,kBAAkB,CAACvF,SAAS,CAAC,CAAC,EAAEuF,kBAAkB,CAACtF,MAAM,GAAG,CAAC,CAAC,CAAC;IAC9F,IAAI,CAACoF,YAAY,GAAGpB,UAAU,CAAC,MAAK;MAClC,IAAI,CAACQ,wBAAwB,EAAE;IACjC,CAAC,EAAEgB,eAAe,GAAG,IAAI,CAAC;IAC1B,gBAAI,CAACJ,YAAY,EAACK,KAAK,kDAAI;EAC7B;EAEQxB,eAAe;IACrB,MAAMyB,KAAK,GAAG,IAAI,CAAC3G,OAAO,CAAC4G,uBAAuB,CAAC,IAAI,CAAC3G,UAAU,EAAE,IAAI,CAACC,UAAU,EAAE,IAAI,CAACC,IAAI,EAAE,IAAI,CAACC,WAAW,EAAE,IAAI,CAACC,QAAQ,CAAC;IAChI,IAAI,CAACe,KAAK,CAAC,sBAAsB,GAAGuF,KAAK,CAACxF,aAAa,EAAE,GAAG,gBAAgB,GAAG,IAAI,CAAC2D,QAAQ,CAAC;IAC7F,MAAMvB,KAAK,GAAG,IAAI,CAACf,eAAe,CAACvB,MAAM;IACzC,IAAI,CAACuB,eAAe,CAACqE,IAAI,CAAC;MAAClG,KAAK,EAAE,QAAQ;MAAE4B,IAAI,EAAEoE,KAAK;MAAEzD,iBAAiB,EAAE;IAAC,CAAC,CAAC;IAC/E,MAAM4D,gBAAgB,GAAG,IAAI,CAAChC,QAAQ,GAAG,CAAC;IAC1C,MAAMiC,eAAe,GAAG,IAAI,CAACA,eAAgB,CAACC,KAAK,EAAE;IACrD,IAAIF,gBAAgB,GAAG,CAAC,EAAE;MACxBC,eAAe,CAACtH,GAAG,CAACK,kCAAkC,EAAE,GAAGgH,gBAAgB,EAAE,CAAC;;IAEhF,IAAIG,gBAAgB,GAAG,KAAK;IAC5BN,KAAK,CAACO,KAAK,CAACH,eAAe,EAAE;MAC3BI,iBAAiB,EAAEhF,QAAQ,IAAG;QAC5B,IAAI,CAACf,KAAK,CAAC,gCAAgC,GAAGuF,KAAK,CAACxF,aAAa,EAAE,GAAG,GAAG,CAAC;QAC1E,IAAI,CAACmC,UAAU,CAACC,KAAK,CAAC;QACtB0D,gBAAgB,GAAG,IAAI;QACvB,IAAIH,gBAAgB,GAAG,CAAC,EAAE;UACxB3E,QAAQ,CAAC1C,GAAG,CAACK,kCAAkC,EAAE,GAAGgH,gBAAgB,EAAE,CAAC;;QAEzE,IAAI,IAAI,CAACtE,eAAe,CAACe,KAAK,CAAC,CAAC5C,KAAK,KAAK,QAAQ,EAAE;UAClD,IAAI,CAACsB,QAAS,CAACkF,iBAAiB,CAAChF,QAAQ,CAAC;;MAE9C,CAAC;MACDiF,gBAAgB,EAAEhE,OAAO,IAAG;QAC1B,IAAI,CAAChC,KAAK,CAAC,+BAA+B,GAAGuF,KAAK,CAACxF,aAAa,EAAE,GAAG,GAAG,CAAC;QACzE,IAAI,CAACmC,UAAU,CAACC,KAAK,CAAC;QACtB,IAAI,IAAI,CAACf,eAAe,CAACe,KAAK,CAAC,CAAC5C,KAAK,KAAK,QAAQ,EAAE;UAClD,IAAI,CAACsB,QAAS,CAACmF,gBAAgB,CAAChE,OAAO,CAAC;;MAE5C,CAAC;MACDlB,eAAe,EAAEG,MAAM,IAAG;QACxB,IAAI,CAACjB,KAAK,CAAC,8BAA8B,GAAGuF,KAAK,CAACxF,aAAa,EAAE,GAAG,GAAG,CAAC;QACxE,IAAI,CAAC8F,gBAAgB,IAAIH,gBAAgB,GAAG,CAAC,EAAE;UAC7CzE,MAAM,CAACF,QAAQ,CAAC1C,GAAG,CAACK,kCAAkC,EAAE,GAAGgH,gBAAgB,EAAE,CAAC;;QAEhF,IAAI,CAACd,iBAAiB,CAAC3D,MAAM,EAAEkB,KAAK,CAAC;MACvC;KACD,CAAC;IACF,IAAI,CAAC8D,oBAAoB,CAAC9D,KAAK,CAAC;IAChC,IAAI,IAAI,CAAC+D,WAAW,EAAE;MACpBX,KAAK,CAACY,SAAS,EAAE;;EAErB;EAEAL,KAAK,CAAC/E,QAAkB,EAAEF,QAA8B;IACtD,IAAI,CAACb,KAAK,CAAC,cAAc,CAAC;IAC1B,IAAI,CAACa,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAAC8E,eAAe,GAAG5E,QAAQ;IAC/B,IAAI,CAAC2C,QAAQ,IAAI,CAAC;IAClB,IAAI,CAACI,eAAe,EAAE;IACtB,IAAI,CAACkB,sBAAsB,EAAE;EAC/B;EAEQoB,yBAAyB,CAACC,UAAkB;;IAClD,MAAM5D,SAAS,GAAG,IAAI,CAACrB,eAAe,CAACiF,UAAU,CAAC;IAClD,MAAM7E,YAAY,GAAGiB,SAAS,CAACX,iBAAiB;IAChD,gBAAI,CAACP,cAAc,CAACC,YAAY,CAAC,EAACiC,QAAQ,kDAAI;IAC9C,IAAI,CAAC7B,iBAAiB,EAAE;IACxBa,SAAS,CAACX,iBAAiB,IAAI,CAAC;IAChC,IAAI,CAACmE,oBAAoB,CAACI,UAAU,CAAC;EACvC;EAEQJ,oBAAoB,CAACI,UAAkB;IAC7C,MAAM5D,SAAS,GAAG,IAAI,CAACrB,eAAe,CAACiF,UAAU,CAAC;IAClD,IAAI5D,SAAS,CAAClD,KAAK,KAAK,WAAW,EAAE;MACnC;;IAEF,IAAI,IAAI,CAACgC,cAAc,CAACkB,SAAS,CAACX,iBAAiB,CAAC,EAAE;MACpD,MAAMC,WAAW,GAAG,IAAI,CAACR,cAAc,CAACkB,SAAS,CAACX,iBAAiB,CAAC;MACpE,QAAQC,WAAW,CAACN,SAAS;QAC3B,KAAK,SAAS;UACZgB,SAAS,CAACtB,IAAI,CAACmF,sBAAsB,CAAC;YACpC7C,QAAQ,EAAG8C,KAAK,IAAI;cAClB;cACA,IAAI,CAACH,yBAAyB,CAACC,UAAU,CAAC;YAC5C;WACD,EAAEtE,WAAW,CAACC,OAAQ,CAACA,OAAO,CAAC;UAChC;QACF,KAAK,YAAY;UACfS,SAAS,CAACX,iBAAiB,IAAI,CAAC;UAChCW,SAAS,CAACtB,IAAI,CAACqF,SAAS,EAAE;UAC1B;QACF,KAAK,OAAO;UACV;UACA;MAAM;;EAGd;EAEAF,sBAAsB,CAACG,OAAuB,EAAEzE,OAAe;;IAC7D,IAAI,CAAChC,KAAK,CAAC,wCAAwC,GAAGgC,OAAO,CAACnC,MAAM,CAAC;IACrE,MAAM6G,QAAQ,GAAgB;MAC5B1E,OAAO;MACP2E,KAAK,EAAEF,OAAO,CAACE;KAChB;IACD,MAAMnF,YAAY,GAAG,IAAI,CAACG,kBAAkB,EAAE;IAC9C,MAAMI,WAAW,GAAqB;MACpCN,SAAS,EAAE,SAAS;MACpBO,OAAO,EAAE0E,QAAQ;MACjBhF,SAAS,EAAE,IAAI,CAACvC,aAAa,CAACrB,QAAQ,CAACkE,OAAO,CAACnC,MAAM,EAAE,IAAI,CAACX,UAAU;KACvE;IACD,IAAI,CAACwB,WAAW,CAAC+E,IAAI,CAAC1D,WAAW,CAAC;IAClC,IAAIA,WAAW,CAACL,SAAS,EAAE;MACzB,aAAO,CAAC+B,QAAQ,uDAAI;MACpB,KAAK,MAAM,CAACS,SAAS,EAAE/C,IAAI,CAAC,IAAI,IAAI,CAACC,eAAe,CAACsB,OAAO,EAAE,EAAE;QAC9D,IAAIvB,IAAI,CAAC5B,KAAK,KAAK,QAAQ,IAAI4B,IAAI,CAACW,iBAAiB,KAAKN,YAAY,EAAE;UACtEL,IAAI,CAACA,IAAI,CAACmF,sBAAsB,CAAC;YAC/B7C,QAAQ,EAAG8C,KAAK,IAAI;cAClB;cACA,IAAI,CAACH,yBAAyB,CAAClC,SAAS,CAAC;YAC3C;WACD,EAAElC,OAAO,CAAC;;;KAGhB,MAAM;MACL,IAAI,CAACM,0BAA0B,EAAE;MACjC;MACA,IAAI,IAAI,CAAChB,kBAAkB,KAAK,IAAI,EAAE;QACpC;;MAEF,MAAMH,IAAI,GAAG,IAAI,CAACC,eAAe,CAAC,IAAI,CAACE,kBAAkB,CAAC;MAC1DS,WAAW,CAAC0B,QAAQ,GAAGgD,OAAO,CAAChD,QAAQ;MACvC,IAAItC,IAAI,CAAC5B,KAAK,KAAK,QAAQ,IAAI4B,IAAI,CAACW,iBAAiB,KAAKN,YAAY,EAAE;QACtEL,IAAI,CAACA,IAAI,CAACmF,sBAAsB,CAAC;UAC/B7C,QAAQ,EAAG8C,KAAK,IAAI;YAClB;YACA,IAAI,CAACH,yBAAyB,CAAC,IAAI,CAAC9E,kBAAmB,CAAC;UAC1D;SACD,EAAEU,OAAO,CAAC;;;EAGjB;EACAmE,SAAS;IACP,IAAI,CAACnG,KAAK,CAAC,kBAAkB,CAAC;IAC9B,IAAI,CAACkG,WAAW,GAAG,IAAI;IACvB,KAAK,MAAMU,cAAc,IAAI,IAAI,CAACxF,eAAe,EAAE;MACjD,IAAI,eAAc,aAAdwF,cAAc,uBAAdA,cAAc,CAAErH,KAAK,MAAK,QAAQ,EAAE;QACtCqH,cAAc,CAACzF,IAAI,CAACgF,SAAS,EAAE;;;EAGrC;EACAK,SAAS;IACP,IAAI,CAACxG,KAAK,CAAC,kBAAkB,CAAC;IAC9B,MAAM6G,cAAc,GAAG,IAAI,CAAClF,kBAAkB,EAAE;IAChD,IAAI,CAACjB,WAAW,CAAC+E,IAAI,CAAC;MACpBhE,SAAS,EAAE,YAAY;MACvBC,SAAS,EAAE;KACZ,CAAC;IACF,KAAK,MAAMP,IAAI,IAAI,IAAI,CAACC,eAAe,EAAE;MACvC,IAAI,KAAI,aAAJD,IAAI,uBAAJA,IAAI,CAAE5B,KAAK,MAAK,QAAQ,IAAI4B,IAAI,CAACW,iBAAiB,KAAK+E,cAAc,EAAE;QACzE1F,IAAI,CAACW,iBAAiB,IAAI,CAAC;QAC3BX,IAAI,CAACA,IAAI,CAACqF,SAAS,EAAE;;;EAG3B;EACAM,cAAc,CAACC,cAA+B;IAC5C,MAAM,IAAIxI,KAAK,CAAC,yBAAyB,CAAC;EAC5C;EACAyI,SAAS;IACP,OAAO,IAAI,CAAClI,UAAU;EACxB;EACAmI,OAAO;IACL,OAAO,IAAI,CAAClI,IAAI;EAClB;;AA1gBFtB","names":["TRACER_NAME","RetryThrottler","constructor","maxTokens","tokenRatio","previousRetryThrottler","tokens","addCallSucceeded","Math","max","addCallFailed","min","canRetryCall","exports","MessageBufferTracker","totalLimit","limitPerCall","Map","allocate","size","callId","currentPerCall","allocatedPerCall","get","totalAllocated","set","free","Error","freeAll","delete","PREVIONS_RPC_ATTEMPTS_METADATA_KEY","RetryingCall","channel","callConfig","methodName","host","credentials","deadline","callNumber","bufferTracker","retryThrottler","methodConfig","retryPolicy","state","nextRetryBackoffSec","initialRetryBackoffSec","Number","initialBackoff","substring","length","hedgingPolicy","getCallNumber","trace","text","logging","constants_1","DEBUG","reportStatus","statusObject","code","details","writeBufferOffset","writeBuffer","process","nextTick","listener","onReceiveStatus","metadata","cancelWithStatus","status","metadata_1","call","underlyingCalls","getPeer","committedCallIndex","getBufferEntry","messageIndex","entryType","allocated","getNextBufferIndex","clearSentMessages","earliestNeededMessageIndex","nextMessageToSend","bufferEntry","message","slice","commitCall","index","i","CANCELLED","commitCallWithMostMessages","mostMessages","callWithMostMessages","childCall","entries","isStatusCodeInList","list","some","value","toString","toLowerCase","getNextRetryBackoffMs","nextBackoffMs","random","maxBackoffSec","maxBackoff","backoffMultiplier","maybeRetryCall","pushback","callback","attempts","maxAttempts","retryDelayMs","setTimeout","startNewAttempt","countActiveCalls","count","handleProcessedStatus","callIndex","nonFatalStatusCodes","delayMs","maybeStartHedgingAttempt","retryableStatusCodes","retried","getPushback","mdValue","parseInt","e","handleChildStatus","progress","OK","transparentRetryUsed","maybeStartHedgingTimer","hedgingTimer","clearTimeout","hedgingDelayString","hedgingDelay","hedgingDelaySec","unref","child","createLoadBalancingCall","push","previousAttempts","initialMetadata","clone","receivedMetadata","start","onReceiveMetadata","onReceiveMessage","sendNextChildMessage","readStarted","startRead","handleChildWriteCompleted","childIndex","sendMessageWithContext","error","halfClose","context","writeObj","flags","underlyingCall","halfCloseIndex","setCredentials","newCredentials","getMethod","getHost"],"sources":["/home/achwak/node_modules/@grpc/grpc-js/src/retrying-call.ts"],"sourcesContent":["/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { CallCredentials } from \"./call-credentials\";\nimport { LogVerbosity, Status } from \"./constants\";\nimport { Deadline } from \"./deadline\";\nimport { Metadata } from \"./metadata\";\nimport { CallConfig } from \"./resolver\";\nimport * as logging from './logging';\nimport { Call, InterceptingListener, MessageContext, StatusObject, WriteCallback, WriteObject } from \"./call-interface\";\nimport { LoadBalancingCall, StatusObjectWithProgress } from \"./load-balancing-call\";\nimport { InternalChannel } from \"./internal-channel\";\n\nconst TRACER_NAME = 'retrying_call';\n\nexport class RetryThrottler {\n  private tokens: number;\n  constructor(private readonly maxTokens: number, private readonly tokenRatio: number, previousRetryThrottler?: RetryThrottler) {\n    if (previousRetryThrottler) {\n      /* When carrying over tokens from a previous config, rescale them to the\n       * new max value */\n      this.tokens = previousRetryThrottler.tokens * (maxTokens / previousRetryThrottler.maxTokens);\n    } else {\n      this.tokens = maxTokens;\n    }\n  }\n\n  addCallSucceeded() {\n    this.tokens = Math.max(this.tokens + this.tokenRatio, this.maxTokens);\n  }\n\n  addCallFailed() {\n    this.tokens = Math.min(this.tokens - 1, 0);\n  }\n\n  canRetryCall() {\n    return this.tokens > this.maxTokens / 2;\n  }\n}\n\nexport class MessageBufferTracker {\n  private totalAllocated: number = 0;\n  private allocatedPerCall: Map<number, number> = new Map<number, number>();\n\n  constructor(private totalLimit: number, private limitPerCall: number) {}\n\n  allocate(size: number, callId: number): boolean {\n    const currentPerCall = this.allocatedPerCall.get(callId) ?? 0;\n    if (this.limitPerCall - currentPerCall < size || this.totalLimit - this.totalAllocated < size) {\n      return false;\n    }\n    this.allocatedPerCall.set(callId, currentPerCall + size);\n    this.totalAllocated += size;\n    return true;\n  }\n\n  free(size: number, callId: number) {\n    if (this.totalAllocated < size) {\n      throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > total allocated ${this.totalAllocated}`);\n    }\n    this.totalAllocated -= size;\n    const currentPerCall = this.allocatedPerCall.get(callId) ?? 0;\n    if (currentPerCall < size) {\n      throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > allocated for call ${currentPerCall}`);\n    }\n    this.allocatedPerCall.set(callId, currentPerCall - size);\n  }\n\n  freeAll(callId: number) {\n    const currentPerCall = this.allocatedPerCall.get(callId) ?? 0;\n    if (this.totalAllocated < currentPerCall) {\n      throw new Error(`Invalid buffer allocation state: call ${callId} allocated ${currentPerCall} > total allocated ${this.totalAllocated}`);\n    }\n    this.totalAllocated -= currentPerCall;\n    this.allocatedPerCall.delete(callId);\n  }\n}\n\ntype UnderlyingCallState = 'ACTIVE' | 'COMPLETED';\n\ninterface UnderlyingCall {\n  state: UnderlyingCallState;\n  call: LoadBalancingCall;\n  nextMessageToSend: number;\n}\n\n/**\n * A retrying call can be in one of these states:\n * RETRY: Retries are configured and new attempts may be sent\n * HEDGING: Hedging is configured and new attempts may be sent\n * TRANSPARENT_ONLY: Neither retries nor hedging are configured, and\n * transparent retry attempts may still be sent\n * COMMITTED: One attempt is committed, and no new attempts will be\n * sent\n */\ntype RetryingCallState = 'RETRY' | 'HEDGING' | 'TRANSPARENT_ONLY' | 'COMMITTED';\n\n/**\n * The different types of objects that can be stored in the write buffer, with\n * the following meanings:\n * MESSAGE: This is a message to be sent.\n * HALF_CLOSE: When this entry is reached, the calls should send a half-close.\n * FREED: This slot previously contained a message that has been sent on all\n * child calls and is no longer needed.\n */\ntype WriteBufferEntryType = 'MESSAGE' | 'HALF_CLOSE' | 'FREED';\n\n/**\n * Entry in the buffer of messages to send to the remote end.\n */\ninterface WriteBufferEntry {\n  entryType: WriteBufferEntryType;\n  /**\n   * Message to send.\n   * Only populated if entryType is MESSAGE.\n   */\n  message?: WriteObject;\n  /**\n   * Callback to call after sending the message.\n   * Only populated if entryType is MESSAGE and the call is in the COMMITTED\n   * state.\n   */\n  callback?: WriteCallback;\n  /**\n   * Indicates whether the message is allocated in the buffer tracker. Ignored\n   * if entryType is not MESSAGE. Should be the return value of\n   * bufferTracker.allocate.\n   */\n  allocated: boolean;\n}\n\nconst PREVIONS_RPC_ATTEMPTS_METADATA_KEY = 'grpc-previous-rpc-attempts';\n\nexport class RetryingCall implements Call {\n  private state: RetryingCallState;\n  private listener: InterceptingListener | null = null;\n  private initialMetadata: Metadata | null = null;\n  private underlyingCalls: UnderlyingCall[] = [];\n  private writeBuffer: WriteBufferEntry[] = [];\n  /**\n   * The offset of message indices in the writeBuffer. For example, if\n   * writeBufferOffset is 10, message 10 is in writeBuffer[0] and message 15\n   * is in writeBuffer[5].\n   */\n  private writeBufferOffset = 0;\n  /**\n   * Tracks whether a read has been started, so that we know whether to start\n   * reads on new child calls. This only matters for the first read, because\n   * once a message comes in the child call becomes committed and there will\n   * be no new child calls.\n   */\n  private readStarted = false;\n  private transparentRetryUsed: boolean = false;\n  /**\n   * Number of attempts so far\n   */\n  private attempts: number = 0;\n  private hedgingTimer: NodeJS.Timer | null = null;\n  private committedCallIndex: number | null = null;\n  private initialRetryBackoffSec = 0;\n  private nextRetryBackoffSec = 0;\n  constructor(\n    private readonly channel: InternalChannel,\n    private readonly callConfig: CallConfig,\n    private readonly methodName: string,\n    private readonly host: string,\n    private readonly credentials: CallCredentials,\n    private readonly deadline: Deadline,\n    private readonly callNumber: number,\n    private readonly bufferTracker: MessageBufferTracker,\n    private readonly retryThrottler?: RetryThrottler\n  ) {\n    if (callConfig.methodConfig.retryPolicy) {\n      this.state = 'RETRY';\n      const retryPolicy = callConfig.methodConfig.retryPolicy;\n      this.nextRetryBackoffSec = this.initialRetryBackoffSec = Number(retryPolicy.initialBackoff.substring(0, retryPolicy.initialBackoff.length - 1));\n    } else if (callConfig.methodConfig.hedgingPolicy) {\n      this.state = 'HEDGING';\n    } else {\n      this.state = 'TRANSPARENT_ONLY';\n    }\n  }\n  getCallNumber(): number {\n    return this.callNumber;\n  }\n\n  private trace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      TRACER_NAME,\n      '[' + this.callNumber + '] ' + text\n    );\n  }\n\n  private reportStatus(statusObject: StatusObject) {\n    this.trace('ended with status: code=' + statusObject.code + ' details=\"' + statusObject.details + '\"');\n    this.bufferTracker.freeAll(this.callNumber);\n    this.writeBufferOffset = this.writeBufferOffset + this.writeBuffer.length;\n    this.writeBuffer = [];\n    process.nextTick(() => {\n      // Explicitly construct status object to remove progress field\n      this.listener?.onReceiveStatus({\n        code: statusObject.code,\n        details: statusObject.details,\n        metadata: statusObject.metadata\n      });\n    });\n  }\n\n  cancelWithStatus(status: Status, details: string): void {\n    this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\n    this.reportStatus({code: status, details, metadata: new Metadata()});\n    for (const {call} of this.underlyingCalls) {\n      call.cancelWithStatus(status, details);\n    }\n  }\n  getPeer(): string {\n    if (this.committedCallIndex !== null) {\n      return this.underlyingCalls[this.committedCallIndex].call.getPeer();\n    } else {\n      return 'unknown';\n    }\n  }\n\n  private getBufferEntry(messageIndex: number): WriteBufferEntry {\n    return this.writeBuffer[messageIndex - this.writeBufferOffset] ?? {entryType: 'FREED', allocated: false};\n  }\n\n  private getNextBufferIndex() {\n    return this.writeBufferOffset + this.writeBuffer.length;\n  }\n\n  private clearSentMessages() {\n    if (this.state !== 'COMMITTED') {\n      return;\n    }\n    const earliestNeededMessageIndex = this.underlyingCalls[this.committedCallIndex!].nextMessageToSend;\n    for (let messageIndex = this.writeBufferOffset; messageIndex < earliestNeededMessageIndex; messageIndex++) {\n      const bufferEntry = this.getBufferEntry(messageIndex);\n      if (bufferEntry.allocated) {\n        this.bufferTracker.free(bufferEntry.message!.message.length, this.callNumber);\n      }\n    }\n    this.writeBuffer = this.writeBuffer.slice(earliestNeededMessageIndex - this.writeBufferOffset);\n    this.writeBufferOffset = earliestNeededMessageIndex;\n  }\n\n  private commitCall(index: number) {\n    if (this.state === 'COMMITTED') {\n      return;\n    }\n    if (this.underlyingCalls[index].state === 'COMPLETED') {\n      return;\n    }\n    this.trace('Committing call [' + this.underlyingCalls[index].call.getCallNumber() + '] at index ' + index);\n    this.state = 'COMMITTED';\n    this.committedCallIndex = index;\n    for (let i = 0; i < this.underlyingCalls.length; i++) {\n      if (i === index) {\n        continue;\n      }\n      if (this.underlyingCalls[i].state === 'COMPLETED') {\n        continue;\n      }\n      this.underlyingCalls[i].state = 'COMPLETED';\n      this.underlyingCalls[i].call.cancelWithStatus(Status.CANCELLED, 'Discarded in favor of other hedged attempt');\n    }\n    this.clearSentMessages();\n  }\n\n  private commitCallWithMostMessages() {\n    if (this.state === 'COMMITTED') {\n      return;\n    }\n    let mostMessages = -1;\n    let callWithMostMessages = -1;\n    for (const [index, childCall] of this.underlyingCalls.entries()) {\n      if (childCall.state === 'ACTIVE' && childCall.nextMessageToSend > mostMessages) {\n        mostMessages = childCall.nextMessageToSend;\n        callWithMostMessages = index;\n      }\n    }\n    if (callWithMostMessages === -1) {\n      /* There are no active calls, disable retries to force the next call that\n       * is started to be committed. */\n      this.state = 'TRANSPARENT_ONLY';\n    } else {\n      this.commitCall(callWithMostMessages);\n    }\n  }\n\n  private isStatusCodeInList(list: (Status | string)[], code: Status) {\n    return list.some((value => value === code || value.toString().toLowerCase() === Status[code].toLowerCase()));\n  }\n\n  private getNextRetryBackoffMs() {\n    const retryPolicy = this.callConfig?.methodConfig.retryPolicy;\n    if (!retryPolicy) {\n      return 0;\n    }\n    const nextBackoffMs = Math.random() * this.nextRetryBackoffSec * 1000;\n    const maxBackoffSec = Number(retryPolicy.maxBackoff.substring(0, retryPolicy.maxBackoff.length - 1));\n    this.nextRetryBackoffSec = Math.min(this.nextRetryBackoffSec * retryPolicy.backoffMultiplier, maxBackoffSec);\n    return nextBackoffMs\n  }\n\n  private maybeRetryCall(pushback: number | null, callback: (retried: boolean) => void) {\n    if (this.state !== 'RETRY') {\n      callback(false);\n      return;\n    }\n    const retryPolicy = this.callConfig!.methodConfig.retryPolicy!;\n    if (this.attempts >= Math.min(retryPolicy.maxAttempts, 5)) {\n      callback(false);\n      return;\n    }\n    let retryDelayMs: number;\n    if (pushback === null) {\n      retryDelayMs = this.getNextRetryBackoffMs();\n    } else if (pushback < 0) {\n      this.state = 'TRANSPARENT_ONLY';\n      callback(false);\n      return;\n    } else {\n      retryDelayMs = pushback;\n      this.nextRetryBackoffSec = this.initialRetryBackoffSec;\n    }\n    setTimeout(() => {\n      if (this.state !== 'RETRY') {\n        callback(false);\n        return;\n      }\n      if (this.retryThrottler?.canRetryCall() ?? true) {\n        callback(true);\n        this.attempts += 1;\n        this.startNewAttempt();\n      }\n    }, retryDelayMs);\n  }\n\n  private countActiveCalls(): number {\n    let count = 0;\n    for (const call of this.underlyingCalls) {\n      if (call?.state === 'ACTIVE') {\n        count += 1;\n      }\n    }\n    return count;\n  }\n\n  private handleProcessedStatus(status: StatusObject, callIndex: number, pushback: number | null) {\n    switch (this.state) {\n      case 'COMMITTED':\n      case 'TRANSPARENT_ONLY':\n        this.commitCall(callIndex);\n        this.reportStatus(status);\n        break;\n      case 'HEDGING':\n        if (this.isStatusCodeInList(this.callConfig!.methodConfig.hedgingPolicy!.nonFatalStatusCodes ?? [], status.code)) {\n          this.retryThrottler?.addCallFailed();\n          let delayMs: number;\n          if (pushback === null) {\n            delayMs = 0;\n          } else if (pushback < 0) {\n            this.state = 'TRANSPARENT_ONLY';\n            this.commitCall(callIndex);\n            this.reportStatus(status);\n            return;\n          } else {\n            delayMs = pushback;\n          }\n          setTimeout(() => {\n            this.maybeStartHedgingAttempt();\n            // If after trying to start a call there are no active calls, this was the last one\n            if (this.countActiveCalls() === 0) {\n              this.commitCall(callIndex);\n              this.reportStatus(status);\n            }\n          }, delayMs);\n        } else {\n          this.commitCall(callIndex);\n          this.reportStatus(status);\n        }\n        break;\n      case 'RETRY':\n        if (this.isStatusCodeInList(this.callConfig!.methodConfig.retryPolicy!.retryableStatusCodes, status.code)) {\n          this.retryThrottler?.addCallFailed();\n          this.maybeRetryCall(pushback, (retried) => {\n            if (!retried) {\n              this.commitCall(callIndex);\n              this.reportStatus(status);\n            }\n          });\n        } else {\n          this.commitCall(callIndex);\n          this.reportStatus(status);\n        }\n        break;\n    }\n  }\n\n  private getPushback(metadata: Metadata): number | null {\n    const mdValue = metadata.get('grpc-retry-pushback-ms');\n    if (mdValue.length === 0) {\n      return null;\n    }\n    try {\n      return parseInt(mdValue[0] as string);\n    } catch (e) {\n      return -1;\n    }\n  }\n\n  private handleChildStatus(status: StatusObjectWithProgress, callIndex: number) {\n    if (this.underlyingCalls[callIndex].state === 'COMPLETED') {\n      return;\n    }\n    this.trace('state=' + this.state + ' handling status with progress ' + status.progress + ' from child [' + this.underlyingCalls[callIndex].call.getCallNumber() + '] in state ' + this.underlyingCalls[callIndex].state);\n    this.underlyingCalls[callIndex].state = 'COMPLETED';\n    if (status.code === Status.OK) {\n      this.retryThrottler?.addCallSucceeded();\n      this.commitCall(callIndex);\n      this.reportStatus(status);\n      return;\n    }\n    if (this.state === 'COMMITTED') {\n      this.reportStatus(status);\n      return;\n    }\n    const pushback = this.getPushback(status.metadata);\n    switch (status.progress) {\n      case 'NOT_STARTED':\n        // RPC never leaves the client, always safe to retry\n        this.startNewAttempt();\n        break;\n      case 'REFUSED':\n        // RPC reaches the server library, but not the server application logic\n        if (this.transparentRetryUsed) {\n          this.handleProcessedStatus(status, callIndex, pushback);\n        } else {\n          this.transparentRetryUsed = true;\n          this.startNewAttempt();\n        };\n        break;\n      case 'DROP':\n        this.commitCall(callIndex);\n        this.reportStatus(status);\n        break;\n      case 'PROCESSED':\n        this.handleProcessedStatus(status, callIndex, pushback);\n        break;\n    }\n  }\n\n  private maybeStartHedgingAttempt() {\n    if (this.state !== 'HEDGING') {\n      return;\n    }\n    if (!this.callConfig.methodConfig.hedgingPolicy) {\n      return;\n    }\n    const hedgingPolicy = this.callConfig.methodConfig.hedgingPolicy;\n    if (this.attempts >= Math.min(hedgingPolicy.maxAttempts, 5)) {\n      return;\n    }\n    this.attempts += 1;\n    this.startNewAttempt();\n    this.maybeStartHedgingTimer();\n  }\n\n  private maybeStartHedgingTimer() {\n    if (this.hedgingTimer) {\n      clearTimeout(this.hedgingTimer);\n    }\n    if (this.state !== 'HEDGING') {\n      return;\n    }\n    if (!this.callConfig.methodConfig.hedgingPolicy) {\n      return;\n    }\n    const hedgingPolicy = this.callConfig.methodConfig.hedgingPolicy;\n    if (this.attempts >= Math.min(hedgingPolicy.maxAttempts, 5)) {\n      return;\n    }\n    const hedgingDelayString = hedgingPolicy.hedgingDelay ?? '0s';\n    const hedgingDelaySec = Number(hedgingDelayString.substring(0, hedgingDelayString.length - 1));\n    this.hedgingTimer = setTimeout(() => {\n      this.maybeStartHedgingAttempt();\n    }, hedgingDelaySec * 1000);\n    this.hedgingTimer.unref?.();\n  }\n\n  private startNewAttempt() {\n    const child = this.channel.createLoadBalancingCall(this.callConfig, this.methodName, this.host, this.credentials, this.deadline);\n    this.trace('Created child call [' + child.getCallNumber() + '] for attempt ' + this.attempts);\n    const index = this.underlyingCalls.length;\n    this.underlyingCalls.push({state: 'ACTIVE', call: child, nextMessageToSend: 0});\n    const previousAttempts = this.attempts - 1;\n    const initialMetadata = this.initialMetadata!.clone();\n    if (previousAttempts > 0) {\n      initialMetadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\n    }\n    let receivedMetadata = false;\n    child.start(initialMetadata, {\n      onReceiveMetadata: metadata => {\n        this.trace('Received metadata from child [' + child.getCallNumber() + ']');\n        this.commitCall(index);\n        receivedMetadata = true;\n        if (previousAttempts > 0) {\n          metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\n        }\n        if (this.underlyingCalls[index].state === 'ACTIVE') {\n          this.listener!.onReceiveMetadata(metadata);\n        }\n      },\n      onReceiveMessage: message => {\n        this.trace('Received message from child [' + child.getCallNumber() + ']');\n        this.commitCall(index);\n        if (this.underlyingCalls[index].state === 'ACTIVE') {\n          this.listener!.onReceiveMessage(message);\n        }\n      },\n      onReceiveStatus: status => {\n        this.trace('Received status from child [' + child.getCallNumber() + ']');\n        if (!receivedMetadata && previousAttempts > 0) {\n          status.metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\n        }\n        this.handleChildStatus(status, index);\n      }\n    });\n    this.sendNextChildMessage(index);\n    if (this.readStarted) {\n      child.startRead();\n    }\n  }\n\n  start(metadata: Metadata, listener: InterceptingListener): void {\n    this.trace('start called');\n    this.listener = listener;\n    this.initialMetadata = metadata;\n    this.attempts += 1;\n    this.startNewAttempt();\n    this.maybeStartHedgingTimer();\n  }\n\n  private handleChildWriteCompleted(childIndex: number) {\n    const childCall = this.underlyingCalls[childIndex];\n    const messageIndex = childCall.nextMessageToSend;\n    this.getBufferEntry(messageIndex).callback?.();\n    this.clearSentMessages();\n    childCall.nextMessageToSend += 1;\n    this.sendNextChildMessage(childIndex);\n  }\n\n  private sendNextChildMessage(childIndex: number) {\n    const childCall = this.underlyingCalls[childIndex];\n    if (childCall.state === 'COMPLETED') {\n      return;\n    }\n    if (this.getBufferEntry(childCall.nextMessageToSend)) {\n      const bufferEntry = this.getBufferEntry(childCall.nextMessageToSend);\n      switch (bufferEntry.entryType) {\n        case 'MESSAGE':\n          childCall.call.sendMessageWithContext({\n            callback: (error) => {\n              // Ignore error\n              this.handleChildWriteCompleted(childIndex);\n            }\n          }, bufferEntry.message!.message);\n          break;\n        case 'HALF_CLOSE':\n          childCall.nextMessageToSend += 1;\n          childCall.call.halfClose();\n          break;\n        case 'FREED':\n          // Should not be possible\n          break;\n      }\n    }\n  }\n\n  sendMessageWithContext(context: MessageContext, message: Buffer): void {\n    this.trace('write() called with message of length ' + message.length);\n    const writeObj: WriteObject = {\n      message,\n      flags: context.flags,\n    };\n    const messageIndex = this.getNextBufferIndex();\n    const bufferEntry: WriteBufferEntry = {\n      entryType: 'MESSAGE',\n      message: writeObj,\n      allocated: this.bufferTracker.allocate(message.length, this.callNumber)\n    };\n    this.writeBuffer.push(bufferEntry);\n    if (bufferEntry.allocated) {\n      context.callback?.();\n      for (const [callIndex, call] of this.underlyingCalls.entries()) {\n        if (call.state === 'ACTIVE' && call.nextMessageToSend === messageIndex) {\n          call.call.sendMessageWithContext({\n            callback: (error) => {\n              // Ignore error\n              this.handleChildWriteCompleted(callIndex);\n            }\n          }, message);\n        }\n      }\n    } else {\n      this.commitCallWithMostMessages();\n      // commitCallWithMostMessages can fail if we are between ping attempts\n      if (this.committedCallIndex === null) {\n        return;\n      }\n      const call = this.underlyingCalls[this.committedCallIndex];\n      bufferEntry.callback = context.callback; \n      if (call.state === 'ACTIVE' && call.nextMessageToSend === messageIndex) {\n        call.call.sendMessageWithContext({\n          callback: (error) => {\n            // Ignore error\n            this.handleChildWriteCompleted(this.committedCallIndex!);\n          }\n        }, message);\n      }\n    }\n  }\n  startRead(): void {\n    this.trace('startRead called');\n    this.readStarted = true;\n    for (const underlyingCall of this.underlyingCalls) {\n      if (underlyingCall?.state === 'ACTIVE') {\n        underlyingCall.call.startRead();\n      }\n    }\n  }\n  halfClose(): void {\n    this.trace('halfClose called');\n    const halfCloseIndex = this.getNextBufferIndex();\n    this.writeBuffer.push({\n      entryType: 'HALF_CLOSE',\n      allocated: false\n    });\n    for (const call of this.underlyingCalls) {\n      if (call?.state === 'ACTIVE' && call.nextMessageToSend === halfCloseIndex) {\n        call.nextMessageToSend += 1;\n        call.call.halfClose();\n      }\n    }\n  }\n  setCredentials(newCredentials: CallCredentials): void {\n    throw new Error(\"Method not implemented.\");\n  }\n  getMethod(): string {\n    return this.methodName;\n  }\n  getHost(): string {\n    return this.host;\n  }\n}"]},"metadata":{},"sourceType":"script","externalDependencies":[]}