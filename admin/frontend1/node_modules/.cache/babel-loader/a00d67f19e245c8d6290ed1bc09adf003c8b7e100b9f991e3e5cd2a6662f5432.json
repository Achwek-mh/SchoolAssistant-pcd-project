{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Subchannel = void 0;\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst backoff_timeout_1 = require(\"./backoff-timeout\");\nconst logging = require(\"./logging\");\nconst constants_1 = require(\"./constants\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst channelz_1 = require(\"./channelz\");\nconst TRACER_NAME = 'subchannel';\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\n * have a constant for the max signed 32 bit integer, so this is a simple way\n * to calculate it */\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nclass Subchannel {\n  /**\n   * A class representing a connection to a single backend.\n   * @param channelTarget The target string for the channel as a whole\n   * @param subchannelAddress The address for the backend that this subchannel\n   *     will connect to\n   * @param options The channel options, plus any specific subchannel options\n   *     for this subchannel\n   * @param credentials The channel credentials used to establish this\n   *     connection\n   */\n  constructor(channelTarget, subchannelAddress, options, credentials, connector) {\n    var _a;\n    this.channelTarget = channelTarget;\n    this.subchannelAddress = subchannelAddress;\n    this.options = options;\n    this.credentials = credentials;\n    this.connector = connector;\n    /**\n     * The subchannel's current connectivity state. Invariant: `session` === `null`\n     * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.\n     */\n    this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\n    /**\n     * The underlying http2 session used to make requests.\n     */\n    this.transport = null;\n    /**\n     * Indicates that the subchannel should transition from TRANSIENT_FAILURE to\n     * CONNECTING instead of IDLE when the backoff timeout ends.\n     */\n    this.continueConnecting = false;\n    /**\n     * A list of listener functions that will be called whenever the connectivity\n     * state changes. Will be modified by `addConnectivityStateListener` and\n     * `removeConnectivityStateListener`\n     */\n    this.stateListeners = [];\n    /**\n     * Tracks channels and subchannel pools with references to this subchannel\n     */\n    this.refcount = 0;\n    // Channelz info\n    this.channelzEnabled = true;\n    this.callTracker = new channelz_1.ChannelzCallTracker();\n    this.childrenTracker = new channelz_1.ChannelzChildrenTracker();\n    // Channelz socket info\n    this.streamTracker = new channelz_1.ChannelzCallTracker();\n    const backoffOptions = {\n      initialDelay: options['grpc.initial_reconnect_backoff_ms'],\n      maxDelay: options['grpc.max_reconnect_backoff_ms']\n    };\n    this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {\n      this.handleBackoffTimer();\n    }, backoffOptions);\n    this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);\n    this.keepaliveTime = (_a = options['grpc.keepalive_time_ms']) !== null && _a !== void 0 ? _a : -1;\n    if (options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n    this.channelzTrace = new channelz_1.ChannelzTrace();\n    this.channelzRef = (0, channelz_1.registerChannelzSubchannel)(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', 'Subchannel created');\n    }\n    this.trace('Subchannel constructed with options ' + JSON.stringify(options, undefined, 2));\n  }\n  getChannelzInfo() {\n    return {\n      state: this.connectivityState,\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      children: this.childrenTracker.getChildLists(),\n      target: this.subchannelAddressString\n    };\n  }\n  trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  refTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'subchannel_refcount', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  handleBackoffTimer() {\n    if (this.continueConnecting) {\n      this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);\n    } else {\n      this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.IDLE);\n    }\n  }\n  /**\n   * Start a backoff timer with the current nextBackoff timeout\n   */\n  startBackoff() {\n    this.backoffTimeout.runOnce();\n  }\n  stopBackoff() {\n    this.backoffTimeout.stop();\n    this.backoffTimeout.reset();\n  }\n  startConnectingInternal() {\n    let options = this.options;\n    if (options['grpc.keepalive_time_ms']) {\n      const adjustedKeepaliveTime = Math.min(this.keepaliveTime, KEEPALIVE_MAX_TIME_MS);\n      options = Object.assign(Object.assign({}, options), {\n        'grpc.keepalive_time_ms': adjustedKeepaliveTime\n      });\n    }\n    this.connector.connect(this.subchannelAddress, this.credentials, options).then(transport => {\n      if (this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.READY)) {\n        this.transport = transport;\n        if (this.channelzEnabled) {\n          this.childrenTracker.refChild(transport.getChannelzRef());\n        }\n        transport.addDisconnectListener(tooManyPings => {\n          this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n          if (tooManyPings && this.keepaliveTime > 0) {\n            this.keepaliveTime *= 2;\n            logging.log(constants_1.LogVerbosity.ERROR, `Connection to ${(0, uri_parser_1.uriToString)(this.channelTarget)} at ${this.subchannelAddressString} rejected by server because of excess pings. Increasing ping interval to ${this.keepaliveTime} ms`);\n          }\n        });\n      }\n    }, error => {\n      this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n    });\n  }\n  /**\n   * Initiate a state transition from any element of oldStates to the new\n   * state. If the current connectivityState is not in oldStates, do nothing.\n   * @param oldStates The set of states to transition from\n   * @param newState The state to transition to\n   * @returns True if the state changed, false otherwise\n   */\n  transitionToState(oldStates, newState) {\n    var _a, _b;\n    if (oldStates.indexOf(this.connectivityState) === -1) {\n      return false;\n    }\n    this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n    }\n    const previousState = this.connectivityState;\n    this.connectivityState = newState;\n    switch (newState) {\n      case connectivity_state_1.ConnectivityState.READY:\n        this.stopBackoff();\n        break;\n      case connectivity_state_1.ConnectivityState.CONNECTING:\n        this.startBackoff();\n        this.startConnectingInternal();\n        this.continueConnecting = false;\n        break;\n      case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:\n        if (this.channelzEnabled && this.transport) {\n          this.childrenTracker.unrefChild(this.transport.getChannelzRef());\n        }\n        (_a = this.transport) === null || _a === void 0 ? void 0 : _a.shutdown();\n        this.transport = null;\n        /* If the backoff timer has already ended by the time we get to the\n         * TRANSIENT_FAILURE state, we want to immediately transition out of\n         * TRANSIENT_FAILURE as though the backoff timer is ending right now */\n        if (!this.backoffTimeout.isRunning()) {\n          process.nextTick(() => {\n            this.handleBackoffTimer();\n          });\n        }\n        break;\n      case connectivity_state_1.ConnectivityState.IDLE:\n        if (this.channelzEnabled && this.transport) {\n          this.childrenTracker.unrefChild(this.transport.getChannelzRef());\n        }\n        (_b = this.transport) === null || _b === void 0 ? void 0 : _b.shutdown();\n        this.transport = null;\n        break;\n      default:\n        throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);\n    }\n    /* We use a shallow copy of the stateListeners array in case a listener\n     * is removed during this iteration */\n    for (const listener of [...this.stateListeners]) {\n      listener(this, previousState, newState, this.keepaliveTime);\n    }\n    return true;\n  }\n  ref() {\n    this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount + 1));\n    this.refcount += 1;\n  }\n  unref() {\n    this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount - 1));\n    this.refcount -= 1;\n    if (this.refcount === 0) {\n      if (this.channelzEnabled) {\n        this.channelzTrace.addTrace('CT_INFO', 'Shutting down');\n      }\n      this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING, connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n      if (this.channelzEnabled) {\n        (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n      }\n    }\n  }\n  unrefIfOneRef() {\n    if (this.refcount === 1) {\n      this.unref();\n      return true;\n    }\n    return false;\n  }\n  createCall(metadata, host, method, listener) {\n    if (!this.transport) {\n      throw new Error('Cannot create call, subchannel not READY');\n    }\n    let statsTracker;\n    if (this.channelzEnabled) {\n      this.callTracker.addCallStarted();\n      this.streamTracker.addCallStarted();\n      statsTracker = {\n        onCallEnd: status => {\n          if (status.code === constants_1.Status.OK) {\n            this.callTracker.addCallSucceeded();\n          } else {\n            this.callTracker.addCallFailed();\n          }\n        }\n      };\n    } else {\n      statsTracker = {};\n    }\n    return this.transport.createCall(metadata, host, method, listener, statsTracker);\n  }\n  /**\n   * If the subchannel is currently IDLE, start connecting and switch to the\n   * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,\n   * the next time it would transition to IDLE, start connecting again instead.\n   * Otherwise, do nothing.\n   */\n  startConnecting() {\n    /* First, try to transition from IDLE to connecting. If that doesn't happen\n     * because the state is not currently IDLE, check if it is\n     * TRANSIENT_FAILURE, and if so indicate that it should go back to\n     * connecting after the backoff timer ends. Otherwise do nothing */\n    if (!this.transitionToState([connectivity_state_1.ConnectivityState.IDLE], connectivity_state_1.ConnectivityState.CONNECTING)) {\n      if (this.connectivityState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n        this.continueConnecting = true;\n      }\n    }\n  }\n  /**\n   * Get the subchannel's current connectivity state.\n   */\n  getConnectivityState() {\n    return this.connectivityState;\n  }\n  /**\n   * Add a listener function to be called whenever the subchannel's\n   * connectivity state changes.\n   * @param listener\n   */\n  addConnectivityStateListener(listener) {\n    this.stateListeners.push(listener);\n  }\n  /**\n   * Remove a listener previously added with `addConnectivityStateListener`\n   * @param listener A reference to a function previously passed to\n   *     `addConnectivityStateListener`\n   */\n  removeConnectivityStateListener(listener) {\n    const listenerIndex = this.stateListeners.indexOf(listener);\n    if (listenerIndex > -1) {\n      this.stateListeners.splice(listenerIndex, 1);\n    }\n  }\n  /**\n   * Reset the backoff timeout, and immediately start connecting if in backoff.\n   */\n  resetBackoff() {\n    this.backoffTimeout.reset();\n    this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);\n  }\n  getAddress() {\n    return this.subchannelAddressString;\n  }\n  getChannelzRef() {\n    return this.channelzRef;\n  }\n  getRealSubchannel() {\n    return this;\n  }\n  throttleKeepalive(newKeepaliveTime) {\n    if (newKeepaliveTime > this.keepaliveTime) {\n      this.keepaliveTime = newKeepaliveTime;\n    }\n  }\n}\nexports.Subchannel = Subchannel;","map":{"version":3,"mappings":"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","names":["TRACER_NAME","KEEPALIVE_MAX_TIME_MS","Subchannel","constructor","channelTarget","subchannelAddress","options","credentials","connector","connectivity_state_1","IDLE","channelz_1","backoffOptions","initialDelay","maxDelay","backoffTimeout","backoff_timeout_1","handleBackoffTimer","subchannelAddressString","keepaliveTime","channelzEnabled","channelzTrace","channelzRef","getChannelzInfo","addTrace","trace","JSON","stringify","undefined","state","connectivityState","callTracker","children","childrenTracker","getChildLists","target","text","logging","constants_1","DEBUG","id","refTrace","continueConnecting","transitionToState","TRANSIENT_FAILURE","CONNECTING","startBackoff","runOnce","stopBackoff","stop","reset","startConnectingInternal","adjustedKeepaliveTime","Math","min","connect","then","transport","READY","refChild","getChannelzRef","addDisconnectListener","tooManyPings","log","ERROR","error","oldStates","newState","indexOf","previousState","unrefChild","shutdown","isRunning","process","nextTick","Error","listener","stateListeners","ref","refcount","unref","unrefIfOneRef","createCall","metadata","host","method","statsTracker","addCallStarted","streamTracker","onCallEnd","status","code","OK","addCallSucceeded","addCallFailed","startConnecting","getConnectivityState","addConnectivityStateListener","push","removeConnectivityStateListener","listenerIndex","splice","resetBackoff","getAddress","getRealSubchannel","throttleKeepalive","newKeepaliveTime","exports"],"sources":["/home/achwak/node_modules/@grpc/grpc-js/src/subchannel.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { ChannelCredentials } from './channel-credentials';\nimport { Metadata } from './metadata';\nimport { ChannelOptions } from './channel-options';\nimport { ConnectivityState } from './connectivity-state';\nimport { BackoffTimeout, BackoffOptions } from './backoff-timeout';\nimport * as logging from './logging';\nimport { LogVerbosity, Status } from './constants';\nimport { GrpcUri, uriToString } from './uri-parser';\nimport {\n  SubchannelAddress,\n  subchannelAddressToString,\n} from './subchannel-address';\nimport { SubchannelRef, ChannelzTrace, ChannelzChildrenTracker, SubchannelInfo, registerChannelzSubchannel, ChannelzCallTracker, unregisterChannelzRef } from './channelz';\nimport { ConnectivityStateListener } from './subchannel-interface';\nimport { SubchannelCallInterceptingListener } from './subchannel-call';\nimport { SubchannelCall } from './subchannel-call';\nimport { CallEventTracker, SubchannelConnector, Transport } from './transport';\n\nconst TRACER_NAME = 'subchannel';\n\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\n * have a constant for the max signed 32 bit integer, so this is a simple way\n * to calculate it */\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\n\nexport class Subchannel {\n  /**\n   * The subchannel's current connectivity state. Invariant: `session` === `null`\n   * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.\n   */\n  private connectivityState: ConnectivityState = ConnectivityState.IDLE;\n  /**\n   * The underlying http2 session used to make requests.\n   */\n  private transport: Transport | null = null;\n  /**\n   * Indicates that the subchannel should transition from TRANSIENT_FAILURE to\n   * CONNECTING instead of IDLE when the backoff timeout ends.\n   */\n  private continueConnecting = false;\n  /**\n   * A list of listener functions that will be called whenever the connectivity\n   * state changes. Will be modified by `addConnectivityStateListener` and\n   * `removeConnectivityStateListener`\n   */\n  private stateListeners: ConnectivityStateListener[] = [];\n\n  private backoffTimeout: BackoffTimeout;\n\n  private keepaliveTime: number;\n  /**\n   * Tracks channels and subchannel pools with references to this subchannel\n   */\n  private refcount = 0;\n\n  /**\n   * A string representation of the subchannel address, for logging/tracing\n   */\n  private subchannelAddressString: string;\n\n  // Channelz info\n  private readonly channelzEnabled: boolean = true;\n  private channelzRef: SubchannelRef;\n  private channelzTrace: ChannelzTrace;\n  private callTracker = new ChannelzCallTracker();\n  private childrenTracker = new ChannelzChildrenTracker();\n\n  // Channelz socket info\n  private streamTracker = new ChannelzCallTracker();\n\n  /**\n   * A class representing a connection to a single backend.\n   * @param channelTarget The target string for the channel as a whole\n   * @param subchannelAddress The address for the backend that this subchannel\n   *     will connect to\n   * @param options The channel options, plus any specific subchannel options\n   *     for this subchannel\n   * @param credentials The channel credentials used to establish this\n   *     connection\n   */\n  constructor(\n    private channelTarget: GrpcUri,\n    private subchannelAddress: SubchannelAddress,\n    private options: ChannelOptions,\n    private credentials: ChannelCredentials,\n    private connector: SubchannelConnector\n  ) {\n    const backoffOptions: BackoffOptions = {\n      initialDelay: options['grpc.initial_reconnect_backoff_ms'],\n      maxDelay: options['grpc.max_reconnect_backoff_ms'],\n    };\n    this.backoffTimeout = new BackoffTimeout(() => {\n      this.handleBackoffTimer();\n    }, backoffOptions);\n    this.subchannelAddressString = subchannelAddressToString(subchannelAddress);\n\n    this.keepaliveTime = options['grpc.keepalive_time_ms'] ?? -1;\n\n    if (options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n    this.channelzTrace = new ChannelzTrace();\n    this.channelzRef = registerChannelzSubchannel(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', 'Subchannel created');\n    }\n    this.trace('Subchannel constructed with options ' + JSON.stringify(options, undefined, 2));\n  }\n\n  private getChannelzInfo(): SubchannelInfo {\n    return {\n      state: this.connectivityState,\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      children: this.childrenTracker.getChildLists(),\n      target: this.subchannelAddressString\n    };\n  }\n\n  private trace(text: string): void {\n    logging.trace(LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  private refTrace(text: string): void {\n    logging.trace(LogVerbosity.DEBUG, 'subchannel_refcount', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  private handleBackoffTimer() {\n    if (this.continueConnecting) {\n      this.transitionToState(\n        [ConnectivityState.TRANSIENT_FAILURE],\n        ConnectivityState.CONNECTING\n      );\n    } else {\n      this.transitionToState(\n        [ConnectivityState.TRANSIENT_FAILURE],\n        ConnectivityState.IDLE\n      );\n    }\n  }\n\n  /**\n   * Start a backoff timer with the current nextBackoff timeout\n   */\n  private startBackoff() {\n    this.backoffTimeout.runOnce();\n  }\n\n  private stopBackoff() {\n    this.backoffTimeout.stop();\n    this.backoffTimeout.reset();\n  }\n\n  private startConnectingInternal() {\n    let options = this.options;\n    if (options['grpc.keepalive_time_ms']) {\n      const adjustedKeepaliveTime = Math.min(this.keepaliveTime, KEEPALIVE_MAX_TIME_MS);\n      options = {...options, 'grpc.keepalive_time_ms': adjustedKeepaliveTime};\n    }\n    this.connector.connect(this.subchannelAddress, this.credentials, options).then(\n      transport => {\n        if (this.transitionToState([ConnectivityState.CONNECTING], ConnectivityState.READY)) {\n          this.transport = transport;\n          if (this.channelzEnabled) {\n            this.childrenTracker.refChild(transport.getChannelzRef());\n          }\n          transport.addDisconnectListener((tooManyPings) => {\n            this.transitionToState([ConnectivityState.READY], ConnectivityState.IDLE);\n            if (tooManyPings && this.keepaliveTime > 0) {\n              this.keepaliveTime *= 2;\n              logging.log(\n                LogVerbosity.ERROR,\n                `Connection to ${uriToString(this.channelTarget)} at ${\n                  this.subchannelAddressString\n                } rejected by server because of excess pings. Increasing ping interval to ${\n                  this.keepaliveTime\n                } ms`\n              );\n            }\n          });\n        }\n      },\n      error => {\n        this.transitionToState([ConnectivityState.CONNECTING], ConnectivityState.TRANSIENT_FAILURE);\n      }\n    )\n  }\n\n  /**\n   * Initiate a state transition from any element of oldStates to the new\n   * state. If the current connectivityState is not in oldStates, do nothing.\n   * @param oldStates The set of states to transition from\n   * @param newState The state to transition to\n   * @returns True if the state changed, false otherwise\n   */\n  private transitionToState(\n    oldStates: ConnectivityState[],\n    newState: ConnectivityState\n  ): boolean {\n    if (oldStates.indexOf(this.connectivityState) === -1) {\n      return false;\n    }\n    this.trace(\n      ConnectivityState[this.connectivityState] +\n        ' -> ' +\n        ConnectivityState[newState]\n    );\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', ConnectivityState[this.connectivityState] + ' -> ' + ConnectivityState[newState]);\n    }\n    const previousState = this.connectivityState;\n    this.connectivityState = newState;\n    switch (newState) {\n      case ConnectivityState.READY:\n        this.stopBackoff();\n        break;\n      case ConnectivityState.CONNECTING:\n        this.startBackoff();\n        this.startConnectingInternal();\n        this.continueConnecting = false;\n        break;\n      case ConnectivityState.TRANSIENT_FAILURE:\n        if (this.channelzEnabled && this.transport) {\n          this.childrenTracker.unrefChild(this.transport.getChannelzRef());\n        }\n        this.transport?.shutdown();\n        this.transport = null;\n        /* If the backoff timer has already ended by the time we get to the\n         * TRANSIENT_FAILURE state, we want to immediately transition out of\n         * TRANSIENT_FAILURE as though the backoff timer is ending right now */\n        if (!this.backoffTimeout.isRunning()) {\n          process.nextTick(() => {\n            this.handleBackoffTimer();\n          });\n        }\n        break;\n      case ConnectivityState.IDLE:\n        if (this.channelzEnabled && this.transport) {\n          this.childrenTracker.unrefChild(this.transport.getChannelzRef());\n        }\n        this.transport?.shutdown();\n        this.transport = null;\n        break;\n      default:\n        throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);\n    }\n    /* We use a shallow copy of the stateListeners array in case a listener\n     * is removed during this iteration */\n    for (const listener of [...this.stateListeners]) {\n      listener(this, previousState, newState, this.keepaliveTime);\n    }\n    return true;\n  }\n\n  ref() {\n    this.refTrace(\n      'refcount ' +\n        this.refcount +\n        ' -> ' +\n        (this.refcount + 1)\n    );\n    this.refcount += 1;\n  }\n\n  unref() {\n    this.refTrace(\n      'refcount ' +\n        this.refcount +\n        ' -> ' +\n        (this.refcount - 1)\n    );\n    this.refcount -= 1;\n    if (this.refcount === 0) {\n      if (this.channelzEnabled) {\n        this.channelzTrace.addTrace('CT_INFO', 'Shutting down');\n      }\n      this.transitionToState(\n        [ConnectivityState.CONNECTING, ConnectivityState.READY],\n        ConnectivityState.IDLE\n      );\n      if (this.channelzEnabled) {\n        unregisterChannelzRef(this.channelzRef);\n      }\n    }\n  }\n\n  unrefIfOneRef(): boolean {\n    if (this.refcount === 1) {\n      this.unref();\n      return true;\n    }\n    return false;\n  }\n\n  createCall(metadata: Metadata, host: string, method: string, listener: SubchannelCallInterceptingListener): SubchannelCall {\n    if (!this.transport) {\n      throw new Error('Cannot create call, subchannel not READY');\n    }\n    let statsTracker: Partial<CallEventTracker>;\n    if (this.channelzEnabled) {\n      this.callTracker.addCallStarted();\n      this.streamTracker.addCallStarted();\n      statsTracker = {\n        onCallEnd: status => {\n          if (status.code === Status.OK) {\n            this.callTracker.addCallSucceeded();\n          } else {\n            this.callTracker.addCallFailed();\n          }\n        }\n      }\n    } else {\n      statsTracker = {};\n    }\n    return this.transport.createCall(metadata, host, method, listener, statsTracker);\n  }\n\n  /**\n   * If the subchannel is currently IDLE, start connecting and switch to the\n   * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,\n   * the next time it would transition to IDLE, start connecting again instead.\n   * Otherwise, do nothing.\n   */\n  startConnecting() {\n    /* First, try to transition from IDLE to connecting. If that doesn't happen\n     * because the state is not currently IDLE, check if it is\n     * TRANSIENT_FAILURE, and if so indicate that it should go back to\n     * connecting after the backoff timer ends. Otherwise do nothing */\n    if (\n      !this.transitionToState(\n        [ConnectivityState.IDLE],\n        ConnectivityState.CONNECTING\n      )\n    ) {\n      if (this.connectivityState === ConnectivityState.TRANSIENT_FAILURE) {\n        this.continueConnecting = true;\n      }\n    }\n  }\n\n  /**\n   * Get the subchannel's current connectivity state.\n   */\n  getConnectivityState() {\n    return this.connectivityState;\n  }\n\n  /**\n   * Add a listener function to be called whenever the subchannel's\n   * connectivity state changes.\n   * @param listener\n   */\n  addConnectivityStateListener(listener: ConnectivityStateListener) {\n    this.stateListeners.push(listener);\n  }\n\n  /**\n   * Remove a listener previously added with `addConnectivityStateListener`\n   * @param listener A reference to a function previously passed to\n   *     `addConnectivityStateListener`\n   */\n  removeConnectivityStateListener(listener: ConnectivityStateListener) {\n    const listenerIndex = this.stateListeners.indexOf(listener);\n    if (listenerIndex > -1) {\n      this.stateListeners.splice(listenerIndex, 1);\n    }\n  }\n\n  /**\n   * Reset the backoff timeout, and immediately start connecting if in backoff.\n   */\n  resetBackoff() {\n    this.backoffTimeout.reset();\n    this.transitionToState(\n      [ConnectivityState.TRANSIENT_FAILURE],\n      ConnectivityState.CONNECTING\n    );\n  }\n\n  getAddress(): string {\n    return this.subchannelAddressString;\n  }\n\n  getChannelzRef(): SubchannelRef {\n    return this.channelzRef;\n  }\n\n  getRealSubchannel(): this {\n    return this;\n  }\n\n  throttleKeepalive(newKeepaliveTime: number) {\n    if (newKeepaliveTime > this.keepaliveTime) {\n      this.keepaliveTime = newKeepaliveTime;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}