{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2020 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MaxMessageSizeFilterFactory = exports.MaxMessageSizeFilter = void 0;\nconst filter_1 = require(\"./filter\");\nconst constants_1 = require(\"./constants\");\nconst metadata_1 = require(\"./metadata\");\nclass MaxMessageSizeFilter extends filter_1.BaseFilter {\n  constructor(options) {\n    super();\n    this.options = options;\n    this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n    this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n    if ('grpc.max_send_message_length' in options) {\n      this.maxSendMessageSize = options['grpc.max_send_message_length'];\n    }\n    if ('grpc.max_receive_message_length' in options) {\n      this.maxReceiveMessageSize = options['grpc.max_receive_message_length'];\n    }\n  }\n  async sendMessage(message) {\n    /* A configured size of -1 means that there is no limit, so skip the check\n     * entirely */\n    if (this.maxSendMessageSize === -1) {\n      return message;\n    } else {\n      const concreteMessage = await message;\n      if (concreteMessage.message.length > this.maxSendMessageSize) {\n        throw {\n          code: constants_1.Status.RESOURCE_EXHAUSTED,\n          details: `Sent message larger than max (${concreteMessage.message.length} vs. ${this.maxSendMessageSize})`,\n          metadata: new metadata_1.Metadata()\n        };\n      } else {\n        return concreteMessage;\n      }\n    }\n  }\n  async receiveMessage(message) {\n    /* A configured size of -1 means that there is no limit, so skip the check\n     * entirely */\n    if (this.maxReceiveMessageSize === -1) {\n      return message;\n    } else {\n      const concreteMessage = await message;\n      if (concreteMessage.length > this.maxReceiveMessageSize) {\n        throw {\n          code: constants_1.Status.RESOURCE_EXHAUSTED,\n          details: `Received message larger than max (${concreteMessage.length} vs. ${this.maxReceiveMessageSize})`,\n          metadata: new metadata_1.Metadata()\n        };\n      } else {\n        return concreteMessage;\n      }\n    }\n  }\n}\nexports.MaxMessageSizeFilter = MaxMessageSizeFilter;\nclass MaxMessageSizeFilterFactory {\n  constructor(options) {\n    this.options = options;\n  }\n  createFilter() {\n    return new MaxMessageSizeFilter(this.options);\n  }\n}\nexports.MaxMessageSizeFilterFactory = MaxMessageSizeFilterFactory;","map":{"version":3,"mappings":";;AAAA;;;;;;;;;;;;;;;;;;;;AAiBA;AAEA;AAMA;AAEA,MAAaA,oBAAqB,SAAQC,mBAAU;EAGlDC,YACmBC,OAAuB;IAExC,KAAK,EAAE;IAFU,YAAO,GAAPA,OAAO;IAHlB,uBAAkB,GAAWC,2CAA+B;IAC5D,0BAAqB,GAAWA,8CAAkC;IAKxE,IAAI,8BAA8B,IAAID,OAAO,EAAE;MAC7C,IAAI,CAACE,kBAAkB,GAAGF,OAAO,CAAC,8BAA8B,CAAE;;IAEpE,IAAI,iCAAiC,IAAIA,OAAO,EAAE;MAChD,IAAI,CAACG,qBAAqB,GAAGH,OAAO,CAAC,iCAAiC,CAAE;;EAE5E;EAEA,MAAMI,WAAW,CAACC,OAA6B;IAC7C;;IAEA,IAAI,IAAI,CAACH,kBAAkB,KAAK,CAAC,CAAC,EAAE;MAClC,OAAOG,OAAO;KACf,MAAM;MACL,MAAMC,eAAe,GAAG,MAAMD,OAAO;MACrC,IAAIC,eAAe,CAACD,OAAO,CAACE,MAAM,GAAG,IAAI,CAACL,kBAAkB,EAAE;QAC5D,MAAM;UACJM,IAAI,EAAEP,kBAAM,CAACQ,kBAAkB;UAC/BC,OAAO,EAAE,iCAAiCJ,eAAe,CAACD,OAAO,CAACE,MAAM,QAAQ,IAAI,CAACL,kBAAkB,GAAG;UAC1GS,QAAQ,EAAE,IAAIC,mBAAQ;SACvB;OACF,MAAM;QACL,OAAON,eAAe;;;EAG5B;EAEA,MAAMO,cAAc,CAACR,OAAwB;IAC3C;;IAEA,IAAI,IAAI,CAACF,qBAAqB,KAAK,CAAC,CAAC,EAAE;MACrC,OAAOE,OAAO;KACf,MAAM;MACL,MAAMC,eAAe,GAAG,MAAMD,OAAO;MACrC,IAAIC,eAAe,CAACC,MAAM,GAAG,IAAI,CAACJ,qBAAqB,EAAE;QACvD,MAAM;UACJK,IAAI,EAAEP,kBAAM,CAACQ,kBAAkB;UAC/BC,OAAO,EAAE,qCAAqCJ,eAAe,CAACC,MAAM,QAAQ,IAAI,CAACJ,qBAAqB,GAAG;UACzGQ,QAAQ,EAAE,IAAIC,mBAAQ;SACvB;OACF,MAAM;QACL,OAAON,eAAe;;;EAG5B;;AAnDFQ;AAsDA,MAAaC,2BAA2B;EAEtChB,YAA6BC,OAAuB;IAAvB,YAAO,GAAPA,OAAO;EAAmB;EAEvDgB,YAAY;IACV,OAAO,IAAInB,oBAAoB,CAAC,IAAI,CAACG,OAAO,CAAC;EAC/C;;AANFc","names":["MaxMessageSizeFilter","filter_1","constructor","options","constants_1","maxSendMessageSize","maxReceiveMessageSize","sendMessage","message","concreteMessage","length","code","RESOURCE_EXHAUSTED","details","metadata","metadata_1","receiveMessage","exports","MaxMessageSizeFilterFactory","createFilter"],"sources":["/home/achwak/node_modules/@grpc/grpc-js/src/max-message-size-filter.ts"],"sourcesContent":["/*\n * Copyright 2020 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { BaseFilter, Filter, FilterFactory } from './filter';\nimport { WriteObject } from './call-interface';\nimport {\n  Status,\n  DEFAULT_MAX_SEND_MESSAGE_LENGTH,\n  DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH,\n} from './constants';\nimport { ChannelOptions } from './channel-options';\nimport { Metadata } from './metadata';\n\nexport class MaxMessageSizeFilter extends BaseFilter implements Filter {\n  private maxSendMessageSize: number = DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n  private maxReceiveMessageSize: number = DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n  constructor(\n    private readonly options: ChannelOptions\n  ) {\n    super();\n    if ('grpc.max_send_message_length' in options) {\n      this.maxSendMessageSize = options['grpc.max_send_message_length']!;\n    }\n    if ('grpc.max_receive_message_length' in options) {\n      this.maxReceiveMessageSize = options['grpc.max_receive_message_length']!;\n    }\n  }\n\n  async sendMessage(message: Promise<WriteObject>): Promise<WriteObject> {\n    /* A configured size of -1 means that there is no limit, so skip the check\n     * entirely */\n    if (this.maxSendMessageSize === -1) {\n      return message;\n    } else {\n      const concreteMessage = await message;\n      if (concreteMessage.message.length > this.maxSendMessageSize) {\n        throw {\n          code: Status.RESOURCE_EXHAUSTED,\n          details: `Sent message larger than max (${concreteMessage.message.length} vs. ${this.maxSendMessageSize})`,\n          metadata: new Metadata()\n        };\n      } else {\n        return concreteMessage;\n      }\n    }\n  }\n\n  async receiveMessage(message: Promise<Buffer>): Promise<Buffer> {\n    /* A configured size of -1 means that there is no limit, so skip the check\n     * entirely */\n    if (this.maxReceiveMessageSize === -1) {\n      return message;\n    } else {\n      const concreteMessage = await message;\n      if (concreteMessage.length > this.maxReceiveMessageSize) {\n        throw {\n          code: Status.RESOURCE_EXHAUSTED,\n          details: `Received message larger than max (${concreteMessage.length} vs. ${this.maxReceiveMessageSize})`,\n          metadata: new Metadata()\n        };\n      } else {\n        return concreteMessage;\n      }\n    }\n  }\n}\n\nexport class MaxMessageSizeFilterFactory\n  implements FilterFactory<MaxMessageSizeFilter> {\n  constructor(private readonly options: ChannelOptions) {}\n\n  createFilter(): MaxMessageSizeFilter {\n    return new MaxMessageSizeFilter(this.options);\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}