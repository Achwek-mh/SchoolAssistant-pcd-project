{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extractAndSelectServiceConfig = exports.validateServiceConfig = exports.validateRetryThrottling = void 0;\n/* This file implements gRFC A2 and the service config spec:\n * https://github.com/grpc/proposal/blob/master/A2-service-configs-in-dns.md\n * https://github.com/grpc/grpc/blob/master/doc/service_config.md. Each\n * function here takes an object with unknown structure and returns its\n * specific object type if the input has the right structure, and throws an\n * error otherwise. */\n/* The any type is purposely used here. All functions validate their input at\n * runtime */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst os = require(\"os\");\nconst constants_1 = require(\"./constants\");\nconst load_balancer_1 = require(\"./load-balancer\");\n/**\n * Recognizes a number with up to 9 digits after the decimal point, followed by\n * an \"s\", representing a number of seconds.\n */\nconst DURATION_REGEX = /^\\d+(\\.\\d{1,9})?s$/;\n/**\n * Client language name used for determining whether this client matches a\n * `ServiceConfigCanaryConfig`'s `clientLanguage` list.\n */\nconst CLIENT_LANGUAGE_STRING = 'node';\nfunction validateName(obj) {\n  if (!('service' in obj) || typeof obj.service !== 'string') {\n    throw new Error('Invalid method config name: invalid service');\n  }\n  const result = {\n    service: obj.service\n  };\n  if ('method' in obj) {\n    if (typeof obj.method === 'string') {\n      result.method = obj.method;\n    } else {\n      throw new Error('Invalid method config name: invalid method');\n    }\n  }\n  return result;\n}\nfunction validateRetryPolicy(obj) {\n  if (!('maxAttempts' in obj) || !Number.isInteger(obj.maxAttempts) || obj.maxAttempts < 2) {\n    throw new Error('Invalid method config retry policy: maxAttempts must be an integer at least 2');\n  }\n  if (!('initialBackoff' in obj) || typeof obj.initialBackoff !== 'string' || !DURATION_REGEX.test(obj.initialBackoff)) {\n    throw new Error('Invalid method config retry policy: initialBackoff must be a string consisting of a positive integer followed by s');\n  }\n  if (!('maxBackoff' in obj) || typeof obj.maxBackoff !== 'string' || !DURATION_REGEX.test(obj.maxBackoff)) {\n    throw new Error('Invalid method config retry policy: maxBackoff must be a string consisting of a positive integer followed by s');\n  }\n  if (!('backoffMultiplier' in obj) || typeof obj.backoffMultiplier !== 'number' || obj.backoffMultiplier <= 0) {\n    throw new Error('Invalid method config retry policy: backoffMultiplier must be a number greater than 0');\n  }\n  if (!('retryableStatusCodes' in obj && Array.isArray(obj.retryableStatusCodes))) {\n    throw new Error('Invalid method config retry policy: retryableStatusCodes is required');\n  }\n  if (obj.retryableStatusCodes.length === 0) {\n    throw new Error('Invalid method config retry policy: retryableStatusCodes must be non-empty');\n  }\n  for (const value of obj.retryableStatusCodes) {\n    if (typeof value === 'number') {\n      if (!Object.values(constants_1.Status).includes(value)) {\n        throw new Error('Invalid method config retry policy: retryableStatusCodes value not in status code range');\n      }\n    } else if (typeof value === 'string') {\n      if (!Object.values(constants_1.Status).includes(value.toUpperCase())) {\n        throw new Error('Invalid method config retry policy: retryableStatusCodes value not a status code name');\n      }\n    } else {\n      throw new Error('Invalid method config retry policy: retryableStatusCodes value must be a string or number');\n    }\n  }\n  return {\n    maxAttempts: obj.maxAttempts,\n    initialBackoff: obj.initialBackoff,\n    maxBackoff: obj.maxBackoff,\n    backoffMultiplier: obj.backoffMultiplier,\n    retryableStatusCodes: obj.retryableStatusCodes\n  };\n}\nfunction validateHedgingPolicy(obj) {\n  if (!('maxAttempts' in obj) || !Number.isInteger(obj.maxAttempts) || obj.maxAttempts < 2) {\n    throw new Error('Invalid method config hedging policy: maxAttempts must be an integer at least 2');\n  }\n  if ('hedgingDelay' in obj && (typeof obj.hedgingDelay !== 'string' || !DURATION_REGEX.test(obj.hedgingDelay))) {\n    throw new Error('Invalid method config hedging policy: hedgingDelay must be a string consisting of a positive integer followed by s');\n  }\n  if ('nonFatalStatusCodes' in obj && Array.isArray(obj.nonFatalStatusCodes)) {\n    for (const value of obj.nonFatalStatusCodes) {\n      if (typeof value === 'number') {\n        if (!Object.values(constants_1.Status).includes(value)) {\n          throw new Error('Invlid method config hedging policy: nonFatalStatusCodes value not in status code range');\n        }\n      } else if (typeof value === 'string') {\n        if (!Object.values(constants_1.Status).includes(value.toUpperCase())) {\n          throw new Error('Invlid method config hedging policy: nonFatalStatusCodes value not a status code name');\n        }\n      } else {\n        throw new Error('Invlid method config hedging policy: nonFatalStatusCodes value must be a string or number');\n      }\n    }\n  }\n  const result = {\n    maxAttempts: obj.maxAttempts\n  };\n  if (obj.hedgingDelay) {\n    result.hedgingDelay = obj.hedgingDelay;\n  }\n  if (obj.nonFatalStatusCodes) {\n    result.nonFatalStatusCodes = obj.nonFatalStatusCodes;\n  }\n  return result;\n}\nfunction validateMethodConfig(obj) {\n  var _a;\n  const result = {\n    name: []\n  };\n  if (!('name' in obj) || !Array.isArray(obj.name)) {\n    throw new Error('Invalid method config: invalid name array');\n  }\n  for (const name of obj.name) {\n    result.name.push(validateName(name));\n  }\n  if ('waitForReady' in obj) {\n    if (typeof obj.waitForReady !== 'boolean') {\n      throw new Error('Invalid method config: invalid waitForReady');\n    }\n    result.waitForReady = obj.waitForReady;\n  }\n  if ('timeout' in obj) {\n    if (typeof obj.timeout === 'object') {\n      if (!('seconds' in obj.timeout) || !(typeof obj.timeout.seconds === 'number')) {\n        throw new Error('Invalid method config: invalid timeout.seconds');\n      }\n      if (!('nanos' in obj.timeout) || !(typeof obj.timeout.nanos === 'number')) {\n        throw new Error('Invalid method config: invalid timeout.nanos');\n      }\n      result.timeout = obj.timeout;\n    } else if (typeof obj.timeout === 'string' && DURATION_REGEX.test(obj.timeout)) {\n      const timeoutParts = obj.timeout.substring(0, obj.timeout.length - 1).split('.');\n      result.timeout = {\n        seconds: timeoutParts[0] | 0,\n        nanos: ((_a = timeoutParts[1]) !== null && _a !== void 0 ? _a : 0) | 0\n      };\n    } else {\n      throw new Error('Invalid method config: invalid timeout');\n    }\n  }\n  if ('maxRequestBytes' in obj) {\n    if (typeof obj.maxRequestBytes !== 'number') {\n      throw new Error('Invalid method config: invalid maxRequestBytes');\n    }\n    result.maxRequestBytes = obj.maxRequestBytes;\n  }\n  if ('maxResponseBytes' in obj) {\n    if (typeof obj.maxResponseBytes !== 'number') {\n      throw new Error('Invalid method config: invalid maxRequestBytes');\n    }\n    result.maxResponseBytes = obj.maxResponseBytes;\n  }\n  if ('retryPolicy' in obj) {\n    if ('hedgingPolicy' in obj) {\n      throw new Error('Invalid method config: retryPolicy and hedgingPolicy cannot both be specified');\n    } else {\n      result.retryPolicy = validateRetryPolicy(obj.retryPolicy);\n    }\n  } else if ('hedgingPolicy' in obj) {\n    result.hedgingPolicy = validateHedgingPolicy(obj.hedgingPolicy);\n  }\n  return result;\n}\nfunction validateRetryThrottling(obj) {\n  if (!('maxTokens' in obj) || typeof obj.maxTokens !== 'number' || obj.maxTokens <= 0 || obj.maxTokens > 1000) {\n    throw new Error('Invalid retryThrottling: maxTokens must be a number in (0, 1000]');\n  }\n  if (!('tokenRatio' in obj) || typeof obj.tokenRatio !== 'number' || obj.tokenRatio <= 0) {\n    throw new Error('Invalid retryThrottling: tokenRatio must be a number greater than 0');\n  }\n  return {\n    maxTokens: +obj.maxTokens.toFixed(3),\n    tokenRatio: +obj.tokenRatio.toFixed(3)\n  };\n}\nexports.validateRetryThrottling = validateRetryThrottling;\nfunction validateServiceConfig(obj) {\n  const result = {\n    loadBalancingConfig: [],\n    methodConfig: []\n  };\n  if ('loadBalancingPolicy' in obj) {\n    if (typeof obj.loadBalancingPolicy === 'string') {\n      result.loadBalancingPolicy = obj.loadBalancingPolicy;\n    } else {\n      throw new Error('Invalid service config: invalid loadBalancingPolicy');\n    }\n  }\n  if ('loadBalancingConfig' in obj) {\n    if (Array.isArray(obj.loadBalancingConfig)) {\n      for (const config of obj.loadBalancingConfig) {\n        result.loadBalancingConfig.push((0, load_balancer_1.validateLoadBalancingConfig)(config));\n      }\n    } else {\n      throw new Error('Invalid service config: invalid loadBalancingConfig');\n    }\n  }\n  if ('methodConfig' in obj) {\n    if (Array.isArray(obj.methodConfig)) {\n      for (const methodConfig of obj.methodConfig) {\n        result.methodConfig.push(validateMethodConfig(methodConfig));\n      }\n    }\n  }\n  if ('retryThrottling' in obj) {\n    result.retryThrottling = validateRetryThrottling(obj.retryThrottling);\n  }\n  // Validate method name uniqueness\n  const seenMethodNames = [];\n  for (const methodConfig of result.methodConfig) {\n    for (const name of methodConfig.name) {\n      for (const seenName of seenMethodNames) {\n        if (name.service === seenName.service && name.method === seenName.method) {\n          throw new Error(`Invalid service config: duplicate name ${name.service}/${name.method}`);\n        }\n      }\n      seenMethodNames.push(name);\n    }\n  }\n  return result;\n}\nexports.validateServiceConfig = validateServiceConfig;\nfunction validateCanaryConfig(obj) {\n  if (!('serviceConfig' in obj)) {\n    throw new Error('Invalid service config choice: missing service config');\n  }\n  const result = {\n    serviceConfig: validateServiceConfig(obj.serviceConfig)\n  };\n  if ('clientLanguage' in obj) {\n    if (Array.isArray(obj.clientLanguage)) {\n      result.clientLanguage = [];\n      for (const lang of obj.clientLanguage) {\n        if (typeof lang === 'string') {\n          result.clientLanguage.push(lang);\n        } else {\n          throw new Error('Invalid service config choice: invalid clientLanguage');\n        }\n      }\n    } else {\n      throw new Error('Invalid service config choice: invalid clientLanguage');\n    }\n  }\n  if ('clientHostname' in obj) {\n    if (Array.isArray(obj.clientHostname)) {\n      result.clientHostname = [];\n      for (const lang of obj.clientHostname) {\n        if (typeof lang === 'string') {\n          result.clientHostname.push(lang);\n        } else {\n          throw new Error('Invalid service config choice: invalid clientHostname');\n        }\n      }\n    } else {\n      throw new Error('Invalid service config choice: invalid clientHostname');\n    }\n  }\n  if ('percentage' in obj) {\n    if (typeof obj.percentage === 'number' && 0 <= obj.percentage && obj.percentage <= 100) {\n      result.percentage = obj.percentage;\n    } else {\n      throw new Error('Invalid service config choice: invalid percentage');\n    }\n  }\n  // Validate that no unexpected fields are present\n  const allowedFields = ['clientLanguage', 'percentage', 'clientHostname', 'serviceConfig'];\n  for (const field in obj) {\n    if (!allowedFields.includes(field)) {\n      throw new Error(`Invalid service config choice: unexpected field ${field}`);\n    }\n  }\n  return result;\n}\nfunction validateAndSelectCanaryConfig(obj, percentage) {\n  if (!Array.isArray(obj)) {\n    throw new Error('Invalid service config list');\n  }\n  for (const config of obj) {\n    const validatedConfig = validateCanaryConfig(config);\n    /* For each field, we check if it is present, then only discard the\n     * config if the field value does not match the current client */\n    if (typeof validatedConfig.percentage === 'number' && percentage > validatedConfig.percentage) {\n      continue;\n    }\n    if (Array.isArray(validatedConfig.clientHostname)) {\n      let hostnameMatched = false;\n      for (const hostname of validatedConfig.clientHostname) {\n        if (hostname === os.hostname()) {\n          hostnameMatched = true;\n        }\n      }\n      if (!hostnameMatched) {\n        continue;\n      }\n    }\n    if (Array.isArray(validatedConfig.clientLanguage)) {\n      let languageMatched = false;\n      for (const language of validatedConfig.clientLanguage) {\n        if (language === CLIENT_LANGUAGE_STRING) {\n          languageMatched = true;\n        }\n      }\n      if (!languageMatched) {\n        continue;\n      }\n    }\n    return validatedConfig.serviceConfig;\n  }\n  throw new Error('No matching service config found');\n}\n/**\n * Find the \"grpc_config\" record among the TXT records, parse its value as JSON, validate its contents,\n * and select a service config with selection fields that all match this client. Most of these steps\n * can fail with an error; the caller must handle any errors thrown this way.\n * @param txtRecord The TXT record array that is output from a successful call to dns.resolveTxt\n * @param percentage A number chosen from the range [0, 100) that is used to select which config to use\n * @return The service configuration to use, given the percentage value, or null if the service config\n *     data has a valid format but none of the options match the current client.\n */\nfunction extractAndSelectServiceConfig(txtRecord, percentage) {\n  for (const record of txtRecord) {\n    if (record.length > 0 && record[0].startsWith('grpc_config=')) {\n      /* Treat the list of strings in this record as a single string and remove\n       * \"grpc_config=\" from the beginning. The rest should be a JSON string */\n      const recordString = record.join('').substring('grpc_config='.length);\n      const recordJson = JSON.parse(recordString);\n      return validateAndSelectCanaryConfig(recordJson, percentage);\n    }\n  }\n  return null;\n}\nexports.extractAndSelectServiceConfig = extractAndSelectServiceConfig;","map":{"version":3,"mappings":"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","names":["DURATION_REGEX","CLIENT_LANGUAGE_STRING","validateName","obj","service","Error","result","method","validateRetryPolicy","Number","isInteger","maxAttempts","initialBackoff","test","maxBackoff","backoffMultiplier","Array","isArray","retryableStatusCodes","length","value","Object","values","constants_1","includes","toUpperCase","validateHedgingPolicy","hedgingDelay","nonFatalStatusCodes","validateMethodConfig","name","push","waitForReady","timeout","seconds","nanos","timeoutParts","substring","split","maxRequestBytes","maxResponseBytes","retryPolicy","hedgingPolicy","validateRetryThrottling","maxTokens","tokenRatio","toFixed","exports","validateServiceConfig","loadBalancingConfig","methodConfig","loadBalancingPolicy","config","retryThrottling","seenMethodNames","seenName","validateCanaryConfig","serviceConfig","clientLanguage","lang","clientHostname","percentage","allowedFields","field","validateAndSelectCanaryConfig","validatedConfig","hostnameMatched","hostname","os","languageMatched","language","extractAndSelectServiceConfig","txtRecord","record","startsWith","recordString","join","recordJson","JSON","parse"],"sources":["/home/achwak/node_modules/@grpc/grpc-js/src/service-config.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n/* This file implements gRFC A2 and the service config spec:\n * https://github.com/grpc/proposal/blob/master/A2-service-configs-in-dns.md\n * https://github.com/grpc/grpc/blob/master/doc/service_config.md. Each\n * function here takes an object with unknown structure and returns its\n * specific object type if the input has the right structure, and throws an\n * error otherwise. */\n\n/* The any type is purposely used here. All functions validate their input at\n * runtime */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport * as os from 'os';\nimport { Status } from './constants';\nimport { Duration } from './duration';\nimport {\n  LoadBalancingConfig,\n  validateLoadBalancingConfig,\n} from './load-balancer';\n\nexport interface MethodConfigName {\n  service: string;\n  method?: string;\n}\n\nexport interface RetryPolicy {\n  maxAttempts: number;\n  initialBackoff: string;\n  maxBackoff: string;\n  backoffMultiplier: number;\n  retryableStatusCodes: (Status | string)[];\n}\n\nexport interface HedgingPolicy {\n  maxAttempts: number;\n  hedgingDelay?: string;\n  nonFatalStatusCodes?: (Status | string)[];\n}\n\nexport interface MethodConfig {\n  name: MethodConfigName[];\n  waitForReady?: boolean;\n  timeout?: Duration;\n  maxRequestBytes?: number;\n  maxResponseBytes?: number;\n  retryPolicy?: RetryPolicy;\n  hedgingPolicy?: HedgingPolicy;\n}\n\nexport interface RetryThrottling {\n  maxTokens: number;\n  tokenRatio: number;\n}\n\nexport interface ServiceConfig {\n  loadBalancingPolicy?: string;\n  loadBalancingConfig: LoadBalancingConfig[];\n  methodConfig: MethodConfig[];\n  retryThrottling?: RetryThrottling;\n}\n\nexport interface ServiceConfigCanaryConfig {\n  clientLanguage?: string[];\n  percentage?: number;\n  clientHostname?: string[];\n  serviceConfig: ServiceConfig;\n}\n\n/**\n * Recognizes a number with up to 9 digits after the decimal point, followed by\n * an \"s\", representing a number of seconds.\n */\nconst DURATION_REGEX = /^\\d+(\\.\\d{1,9})?s$/;\n\n/**\n * Client language name used for determining whether this client matches a\n * `ServiceConfigCanaryConfig`'s `clientLanguage` list.\n */\nconst CLIENT_LANGUAGE_STRING = 'node';\n\nfunction validateName(obj: any): MethodConfigName {\n  if (!('service' in obj) || typeof obj.service !== 'string') {\n    throw new Error('Invalid method config name: invalid service');\n  }\n  const result: MethodConfigName = {\n    service: obj.service,\n  };\n  if ('method' in obj) {\n    if (typeof obj.method === 'string') {\n      result.method = obj.method;\n    } else {\n      throw new Error('Invalid method config name: invalid method');\n    }\n  }\n  return result;\n}\n\nfunction validateRetryPolicy(obj: any): RetryPolicy {\n  if (!('maxAttempts' in obj) || !Number.isInteger(obj.maxAttempts) || obj.maxAttempts < 2) {\n    throw new Error('Invalid method config retry policy: maxAttempts must be an integer at least 2');\n  }\n  if (!('initialBackoff' in obj) || typeof obj.initialBackoff !== 'string' || !DURATION_REGEX.test(obj.initialBackoff)) {\n    throw new Error('Invalid method config retry policy: initialBackoff must be a string consisting of a positive integer followed by s');\n  }\n  if (!('maxBackoff' in obj) || typeof obj.maxBackoff !== 'string' || !DURATION_REGEX.test(obj.maxBackoff)) {\n    throw new Error('Invalid method config retry policy: maxBackoff must be a string consisting of a positive integer followed by s');\n  }\n  if (!('backoffMultiplier' in obj) || typeof obj.backoffMultiplier !== 'number' || obj.backoffMultiplier <= 0) {\n    throw new Error('Invalid method config retry policy: backoffMultiplier must be a number greater than 0');\n  }\n  if (!(('retryableStatusCodes' in obj) && Array.isArray(obj.retryableStatusCodes))) {\n    throw new Error('Invalid method config retry policy: retryableStatusCodes is required');\n  }\n  if (obj.retryableStatusCodes.length === 0) {\n    throw new Error('Invalid method config retry policy: retryableStatusCodes must be non-empty');\n  }\n  for (const value of obj.retryableStatusCodes) {\n    if (typeof value === 'number') {\n      if (!Object.values(Status).includes(value)) {\n        throw new Error('Invalid method config retry policy: retryableStatusCodes value not in status code range');\n      }\n    } else if (typeof value === 'string') {\n      if (!Object.values(Status).includes(value.toUpperCase())) {\n        throw new Error('Invalid method config retry policy: retryableStatusCodes value not a status code name');\n      }\n    } else {\n      throw new Error('Invalid method config retry policy: retryableStatusCodes value must be a string or number');\n    }\n  }\n  return {\n    maxAttempts: obj.maxAttempts,\n    initialBackoff: obj.initialBackoff,\n    maxBackoff: obj.maxBackoff,\n    backoffMultiplier: obj.backoffMultiplier,\n    retryableStatusCodes: obj.retryableStatusCodes\n  };\n}\n\nfunction validateHedgingPolicy(obj: any): HedgingPolicy {\n  if (!('maxAttempts' in obj) || !Number.isInteger(obj.maxAttempts) || obj.maxAttempts < 2) {\n    throw new Error('Invalid method config hedging policy: maxAttempts must be an integer at least 2');\n  }\n  if (('hedgingDelay' in obj) && (typeof obj.hedgingDelay !== 'string' || !DURATION_REGEX.test(obj.hedgingDelay))) {\n    throw new Error('Invalid method config hedging policy: hedgingDelay must be a string consisting of a positive integer followed by s');\n  }\n  if (('nonFatalStatusCodes' in obj) && Array.isArray(obj.nonFatalStatusCodes)) {\n    for (const value of obj.nonFatalStatusCodes) {\n      if (typeof value === 'number') {\n        if (!Object.values(Status).includes(value)) {\n          throw new Error('Invlid method config hedging policy: nonFatalStatusCodes value not in status code range');\n        }\n      } else if (typeof value === 'string') {\n        if (!Object.values(Status).includes(value.toUpperCase())) {\n          throw new Error('Invlid method config hedging policy: nonFatalStatusCodes value not a status code name');\n        }\n      } else {\n        throw new Error('Invlid method config hedging policy: nonFatalStatusCodes value must be a string or number');\n      }\n    }\n  }\n  const result: HedgingPolicy = {\n    maxAttempts: obj.maxAttempts\n  }\n  if (obj.hedgingDelay) {\n    result.hedgingDelay = obj.hedgingDelay;\n  }\n  if (obj.nonFatalStatusCodes) {\n    result.nonFatalStatusCodes = obj.nonFatalStatusCodes;\n  }\n  return result;\n}\n\nfunction validateMethodConfig(obj: any): MethodConfig {\n  const result: MethodConfig = {\n    name: [],\n  };\n  if (!('name' in obj) || !Array.isArray(obj.name)) {\n    throw new Error('Invalid method config: invalid name array');\n  }\n  for (const name of obj.name) {\n    result.name.push(validateName(name));\n  }\n  if ('waitForReady' in obj) {\n    if (typeof obj.waitForReady !== 'boolean') {\n      throw new Error('Invalid method config: invalid waitForReady');\n    }\n    result.waitForReady = obj.waitForReady;\n  }\n  if ('timeout' in obj) {\n    if (typeof obj.timeout === 'object') {\n      if (\n        !('seconds' in obj.timeout) ||\n        !(typeof obj.timeout.seconds === 'number')\n      ) {\n        throw new Error('Invalid method config: invalid timeout.seconds');\n      }\n      if (\n        !('nanos' in obj.timeout) ||\n        !(typeof obj.timeout.nanos === 'number')\n      ) {\n        throw new Error('Invalid method config: invalid timeout.nanos');\n      }\n      result.timeout = obj.timeout;\n    } else if (\n      typeof obj.timeout === 'string' &&\n      DURATION_REGEX.test(obj.timeout)\n    ) {\n      const timeoutParts = obj.timeout\n        .substring(0, obj.timeout.length - 1)\n        .split('.');\n      result.timeout = {\n        seconds: timeoutParts[0] | 0,\n        nanos: (timeoutParts[1] ?? 0) | 0,\n      };\n    } else {\n      throw new Error('Invalid method config: invalid timeout');\n    }\n  }\n  if ('maxRequestBytes' in obj) {\n    if (typeof obj.maxRequestBytes !== 'number') {\n      throw new Error('Invalid method config: invalid maxRequestBytes');\n    }\n    result.maxRequestBytes = obj.maxRequestBytes;\n  }\n  if ('maxResponseBytes' in obj) {\n    if (typeof obj.maxResponseBytes !== 'number') {\n      throw new Error('Invalid method config: invalid maxRequestBytes');\n    }\n    result.maxResponseBytes = obj.maxResponseBytes;\n  }\n  if ('retryPolicy' in obj) {\n    if ('hedgingPolicy' in obj) {\n      throw new Error('Invalid method config: retryPolicy and hedgingPolicy cannot both be specified');\n    } else {\n      result.retryPolicy = validateRetryPolicy(obj.retryPolicy);\n    }\n  } else if ('hedgingPolicy' in obj) {\n    result.hedgingPolicy = validateHedgingPolicy(obj.hedgingPolicy);\n  }\n  return result;\n}\n\nexport function validateRetryThrottling(obj: any): RetryThrottling {\n  if (!('maxTokens' in obj) || typeof obj.maxTokens !== 'number' || obj.maxTokens <=0 || obj.maxTokens > 1000) {\n    throw new Error('Invalid retryThrottling: maxTokens must be a number in (0, 1000]');\n  }\n  if (!('tokenRatio' in obj) || typeof obj.tokenRatio !== 'number' || obj.tokenRatio <= 0) {\n    throw new Error('Invalid retryThrottling: tokenRatio must be a number greater than 0');\n  }\n  return {\n    maxTokens: +(obj.maxTokens as number).toFixed(3),\n    tokenRatio: +(obj.tokenRatio as number).toFixed(3)\n  };\n}\n\nexport function validateServiceConfig(obj: any): ServiceConfig {\n  const result: ServiceConfig = {\n    loadBalancingConfig: [],\n    methodConfig: [],\n  };\n  if ('loadBalancingPolicy' in obj) {\n    if (typeof obj.loadBalancingPolicy === 'string') {\n      result.loadBalancingPolicy = obj.loadBalancingPolicy;\n    } else {\n      throw new Error('Invalid service config: invalid loadBalancingPolicy');\n    }\n  }\n  if ('loadBalancingConfig' in obj) {\n    if (Array.isArray(obj.loadBalancingConfig)) {\n      for (const config of obj.loadBalancingConfig) {\n        result.loadBalancingConfig.push(validateLoadBalancingConfig(config));\n      }\n    } else {\n      throw new Error('Invalid service config: invalid loadBalancingConfig');\n    }\n  }\n  if ('methodConfig' in obj) {\n    if (Array.isArray(obj.methodConfig)) {\n      for (const methodConfig of obj.methodConfig) {\n        result.methodConfig.push(validateMethodConfig(methodConfig));\n      }\n    }\n  }\n  if ('retryThrottling' in obj) {\n    result.retryThrottling = validateRetryThrottling(obj.retryThrottling);\n  }\n  // Validate method name uniqueness\n  const seenMethodNames: MethodConfigName[] = [];\n  for (const methodConfig of result.methodConfig) {\n    for (const name of methodConfig.name) {\n      for (const seenName of seenMethodNames) {\n        if (\n          name.service === seenName.service &&\n          name.method === seenName.method\n        ) {\n          throw new Error(\n            `Invalid service config: duplicate name ${name.service}/${name.method}`\n          );\n        }\n      }\n      seenMethodNames.push(name);\n    }\n  }\n  return result;\n}\n\nfunction validateCanaryConfig(obj: any): ServiceConfigCanaryConfig {\n  if (!('serviceConfig' in obj)) {\n    throw new Error('Invalid service config choice: missing service config');\n  }\n  const result: ServiceConfigCanaryConfig = {\n    serviceConfig: validateServiceConfig(obj.serviceConfig),\n  };\n  if ('clientLanguage' in obj) {\n    if (Array.isArray(obj.clientLanguage)) {\n      result.clientLanguage = [];\n      for (const lang of obj.clientLanguage) {\n        if (typeof lang === 'string') {\n          result.clientLanguage.push(lang);\n        } else {\n          throw new Error(\n            'Invalid service config choice: invalid clientLanguage'\n          );\n        }\n      }\n    } else {\n      throw new Error('Invalid service config choice: invalid clientLanguage');\n    }\n  }\n  if ('clientHostname' in obj) {\n    if (Array.isArray(obj.clientHostname)) {\n      result.clientHostname = [];\n      for (const lang of obj.clientHostname) {\n        if (typeof lang === 'string') {\n          result.clientHostname.push(lang);\n        } else {\n          throw new Error(\n            'Invalid service config choice: invalid clientHostname'\n          );\n        }\n      }\n    } else {\n      throw new Error('Invalid service config choice: invalid clientHostname');\n    }\n  }\n  if ('percentage' in obj) {\n    if (\n      typeof obj.percentage === 'number' &&\n      0 <= obj.percentage &&\n      obj.percentage <= 100\n    ) {\n      result.percentage = obj.percentage;\n    } else {\n      throw new Error('Invalid service config choice: invalid percentage');\n    }\n  }\n  // Validate that no unexpected fields are present\n  const allowedFields = [\n    'clientLanguage',\n    'percentage',\n    'clientHostname',\n    'serviceConfig',\n  ];\n  for (const field in obj) {\n    if (!allowedFields.includes(field)) {\n      throw new Error(\n        `Invalid service config choice: unexpected field ${field}`\n      );\n    }\n  }\n  return result;\n}\n\nfunction validateAndSelectCanaryConfig(\n  obj: any,\n  percentage: number\n): ServiceConfig {\n  if (!Array.isArray(obj)) {\n    throw new Error('Invalid service config list');\n  }\n  for (const config of obj) {\n    const validatedConfig = validateCanaryConfig(config);\n    /* For each field, we check if it is present, then only discard the\n     * config if the field value does not match the current client */\n    if (\n      typeof validatedConfig.percentage === 'number' &&\n      percentage > validatedConfig.percentage\n    ) {\n      continue;\n    }\n    if (Array.isArray(validatedConfig.clientHostname)) {\n      let hostnameMatched = false;\n      for (const hostname of validatedConfig.clientHostname) {\n        if (hostname === os.hostname()) {\n          hostnameMatched = true;\n        }\n      }\n      if (!hostnameMatched) {\n        continue;\n      }\n    }\n    if (Array.isArray(validatedConfig.clientLanguage)) {\n      let languageMatched = false;\n      for (const language of validatedConfig.clientLanguage) {\n        if (language === CLIENT_LANGUAGE_STRING) {\n          languageMatched = true;\n        }\n      }\n      if (!languageMatched) {\n        continue;\n      }\n    }\n    return validatedConfig.serviceConfig;\n  }\n  throw new Error('No matching service config found');\n}\n\n/**\n * Find the \"grpc_config\" record among the TXT records, parse its value as JSON, validate its contents,\n * and select a service config with selection fields that all match this client. Most of these steps\n * can fail with an error; the caller must handle any errors thrown this way.\n * @param txtRecord The TXT record array that is output from a successful call to dns.resolveTxt\n * @param percentage A number chosen from the range [0, 100) that is used to select which config to use\n * @return The service configuration to use, given the percentage value, or null if the service config\n *     data has a valid format but none of the options match the current client.\n */\nexport function extractAndSelectServiceConfig(\n  txtRecord: string[][],\n  percentage: number\n): ServiceConfig | null {\n  for (const record of txtRecord) {\n    if (record.length > 0 && record[0].startsWith('grpc_config=')) {\n      /* Treat the list of strings in this record as a single string and remove\n       * \"grpc_config=\" from the beginning. The rest should be a JSON string */\n      const recordString = record.join('').substring('grpc_config='.length);\n      const recordJson: any = JSON.parse(recordString);\n      return validateAndSelectCanaryConfig(recordJson, percentage);\n    }\n  }\n  return null;\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}