{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2023 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Http2SubchannelConnector = void 0;\nconst http2 = require(\"http2\");\nconst tls_1 = require(\"tls\");\nconst channelz_1 = require(\"./channelz\");\nconst constants_1 = require(\"./constants\");\nconst http_proxy_1 = require(\"./http_proxy\");\nconst logging = require(\"./logging\");\nconst resolver_1 = require(\"./resolver\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst net = require(\"net\");\nconst subchannel_call_1 = require(\"./subchannel-call\");\nconst call_number_1 = require(\"./call-number\");\nconst TRACER_NAME = 'transport';\nconst FLOW_CONTROL_TRACER_NAME = 'transport_flowctrl';\nconst clientVersion = require('../../package.json').version;\nconst {\n  HTTP2_HEADER_AUTHORITY,\n  HTTP2_HEADER_CONTENT_TYPE,\n  HTTP2_HEADER_METHOD,\n  HTTP2_HEADER_PATH,\n  HTTP2_HEADER_TE,\n  HTTP2_HEADER_USER_AGENT\n} = http2.constants;\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\n * have a constant for the max signed 32 bit integer, so this is a simple way\n * to calculate it */\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nconst KEEPALIVE_TIMEOUT_MS = 20000;\nconst tooManyPingsData = Buffer.from('too_many_pings', 'ascii');\nclass Http2Transport {\n  constructor(session, subchannelAddress, options) {\n    this.session = session;\n    /**\n     * The amount of time in between sending pings\n     */\n    this.keepaliveTimeMs = -1;\n    /**\n     * The amount of time to wait for an acknowledgement after sending a ping\n     */\n    this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;\n    /**\n     * Timer reference tracking when the most recent ping will be considered lost\n     */\n    this.keepaliveTimeoutId = null;\n    /**\n     * Indicates whether keepalive pings should be sent without any active calls\n     */\n    this.keepaliveWithoutCalls = false;\n    this.activeCalls = new Set();\n    this.disconnectListeners = [];\n    this.disconnectHandled = false;\n    this.channelzEnabled = true;\n    /**\n     * Name of the remote server, if it is not the same as the subchannel\n     * address, i.e. if connecting through an HTTP CONNECT proxy.\n     */\n    this.remoteName = null;\n    this.streamTracker = new channelz_1.ChannelzCallTracker();\n    this.keepalivesSent = 0;\n    this.messagesSent = 0;\n    this.messagesReceived = 0;\n    this.lastMessageSentTimestamp = null;\n    this.lastMessageReceivedTimestamp = null;\n    // Build user-agent string.\n    this.userAgent = [options['grpc.primary_user_agent'], `grpc-node-js/${clientVersion}`, options['grpc.secondary_user_agent']].filter(e => e).join(' '); // remove falsey values first\n    if ('grpc.keepalive_time_ms' in options) {\n      this.keepaliveTimeMs = options['grpc.keepalive_time_ms'];\n    }\n    if ('grpc.keepalive_timeout_ms' in options) {\n      this.keepaliveTimeoutMs = options['grpc.keepalive_timeout_ms'];\n    }\n    if ('grpc.keepalive_permit_without_calls' in options) {\n      this.keepaliveWithoutCalls = options['grpc.keepalive_permit_without_calls'] === 1;\n    } else {\n      this.keepaliveWithoutCalls = false;\n    }\n    this.keepaliveIntervalId = setTimeout(() => {}, 0);\n    clearTimeout(this.keepaliveIntervalId);\n    if (this.keepaliveWithoutCalls) {\n      this.startKeepalivePings();\n    }\n    this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);\n    if (options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n    this.channelzRef = (0, channelz_1.registerChannelzSocket)(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);\n    session.once('close', () => {\n      this.trace('session closed');\n      this.stopKeepalivePings();\n      this.handleDisconnect();\n    });\n    session.once('goaway', (errorCode, lastStreamID, opaqueData) => {\n      let tooManyPings = false;\n      /* See the last paragraph of\n       * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */\n      if (errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM && opaqueData.equals(tooManyPingsData)) {\n        tooManyPings = true;\n      }\n      this.trace('connection closed by GOAWAY with code ' + errorCode);\n      this.reportDisconnectToOwner(tooManyPings);\n    });\n    session.once('error', error => {\n      /* Do nothing here. Any error should also trigger a close event, which is\n       * where we want to handle that.  */\n      this.trace('connection closed with error ' + error.message);\n    });\n    if (logging.isTracerEnabled(TRACER_NAME)) {\n      session.on('remoteSettings', settings => {\n        this.trace('new settings received' + (this.session !== session ? ' on the old connection' : '') + ': ' + JSON.stringify(settings));\n      });\n      session.on('localSettings', settings => {\n        this.trace('local settings acknowledged by remote' + (this.session !== session ? ' on the old connection' : '') + ': ' + JSON.stringify(settings));\n      });\n    }\n  }\n  getChannelzInfo() {\n    var _a, _b, _c;\n    const sessionSocket = this.session.socket;\n    const remoteAddress = sessionSocket.remoteAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n    const localAddress = sessionSocket.localAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.localAddress, sessionSocket.localPort) : null;\n    let tlsInfo;\n    if (this.session.encrypted) {\n      const tlsSocket = sessionSocket;\n      const cipherInfo = tlsSocket.getCipher();\n      const certificate = tlsSocket.getCertificate();\n      const peerCertificate = tlsSocket.getPeerCertificate();\n      tlsInfo = {\n        cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,\n        cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n        localCertificate: certificate && 'raw' in certificate ? certificate.raw : null,\n        remoteCertificate: peerCertificate && 'raw' in peerCertificate ? peerCertificate.raw : null\n      };\n    } else {\n      tlsInfo = null;\n    }\n    const socketInfo = {\n      remoteAddress: remoteAddress,\n      localAddress: localAddress,\n      security: tlsInfo,\n      remoteName: this.remoteName,\n      streamsStarted: this.streamTracker.callsStarted,\n      streamsSucceeded: this.streamTracker.callsSucceeded,\n      streamsFailed: this.streamTracker.callsFailed,\n      messagesSent: this.messagesSent,\n      messagesReceived: this.messagesReceived,\n      keepAlivesSent: this.keepalivesSent,\n      lastLocalStreamCreatedTimestamp: this.streamTracker.lastCallStartedTimestamp,\n      lastRemoteStreamCreatedTimestamp: null,\n      lastMessageSentTimestamp: this.lastMessageSentTimestamp,\n      lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,\n      localFlowControlWindow: (_b = this.session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,\n      remoteFlowControlWindow: (_c = this.session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null\n    };\n    return socketInfo;\n  }\n  trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  keepaliveTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'keepalive', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  flowControlTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, FLOW_CONTROL_TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  internalsTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'transport_internals', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  /**\n   * Indicate to the owner of this object that this transport should no longer\n   * be used. That happens if the connection drops, or if the server sends a\n   * GOAWAY.\n   * @param tooManyPings If true, this was triggered by a GOAWAY with data\n   * indicating that the session was closed becaues the client sent too many\n   * pings.\n   * @returns\n   */\n  reportDisconnectToOwner(tooManyPings) {\n    if (this.disconnectHandled) {\n      return;\n    }\n    this.disconnectHandled = true;\n    this.disconnectListeners.forEach(listener => listener(tooManyPings));\n  }\n  /**\n   * Handle connection drops, but not GOAWAYs.\n   */\n  handleDisconnect() {\n    this.reportDisconnectToOwner(false);\n    /* Give calls an event loop cycle to finish naturally before reporting the\n     * disconnnection to them. */\n    setImmediate(() => {\n      for (const call of this.activeCalls) {\n        call.onDisconnect();\n      }\n    });\n  }\n  addDisconnectListener(listener) {\n    this.disconnectListeners.push(listener);\n  }\n  clearKeepaliveTimeout() {\n    if (!this.keepaliveTimeoutId) {\n      return;\n    }\n    clearTimeout(this.keepaliveTimeoutId);\n    this.keepaliveTimeoutId = null;\n  }\n  sendPing() {\n    var _a, _b;\n    if (this.channelzEnabled) {\n      this.keepalivesSent += 1;\n    }\n    this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');\n    if (!this.keepaliveTimeoutId) {\n      this.keepaliveTimeoutId = setTimeout(() => {\n        this.keepaliveTrace('Ping timeout passed without response');\n        this.handleDisconnect();\n      }, this.keepaliveTimeoutMs);\n      (_b = (_a = this.keepaliveTimeoutId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    try {\n      this.session.ping((err, duration, payload) => {\n        this.keepaliveTrace('Received ping response');\n        this.clearKeepaliveTimeout();\n      });\n    } catch (e) {\n      /* If we fail to send a ping, the connection is no longer functional, so\n       * we should discard it. */\n      this.handleDisconnect();\n    }\n  }\n  startKeepalivePings() {\n    var _a, _b;\n    if (this.keepaliveTimeMs < 0) {\n      return;\n    }\n    this.keepaliveIntervalId = setInterval(() => {\n      this.sendPing();\n    }, this.keepaliveTimeMs);\n    (_b = (_a = this.keepaliveIntervalId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    /* Don't send a ping immediately because whatever caused us to start\n     * sending pings should also involve some network activity. */\n  }\n  /**\n   * Stop keepalive pings when terminating a connection. This discards the\n   * outstanding ping timeout, so it should not be called if the same\n   * connection will still be used.\n   */\n  stopKeepalivePings() {\n    clearInterval(this.keepaliveIntervalId);\n    this.clearKeepaliveTimeout();\n  }\n  removeActiveCall(call) {\n    this.activeCalls.delete(call);\n    if (this.activeCalls.size === 0) {\n      this.session.unref();\n      if (!this.keepaliveWithoutCalls) {\n        this.stopKeepalivePings();\n      }\n    }\n  }\n  addActiveCall(call) {\n    if (this.activeCalls.size === 0) {\n      this.session.ref();\n      if (!this.keepaliveWithoutCalls) {\n        this.startKeepalivePings();\n      }\n    }\n    this.activeCalls.add(call);\n  }\n  createCall(metadata, host, method, listener, subchannelCallStatsTracker) {\n    const headers = metadata.toHttp2Headers();\n    headers[HTTP2_HEADER_AUTHORITY] = host;\n    headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\n    headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';\n    headers[HTTP2_HEADER_METHOD] = 'POST';\n    headers[HTTP2_HEADER_PATH] = method;\n    headers[HTTP2_HEADER_TE] = 'trailers';\n    let http2Stream;\n    /* In theory, if an error is thrown by session.request because session has\n     * become unusable (e.g. because it has received a goaway), this subchannel\n     * should soon see the corresponding close or goaway event anyway and leave\n     * READY. But we have seen reports that this does not happen\n     * (https://github.com/googleapis/nodejs-firestore/issues/1023#issuecomment-653204096)\n     * so for defense in depth, we just discard the session when we see an\n     * error here.\n     */\n    try {\n      http2Stream = this.session.request(headers);\n    } catch (e) {\n      this.handleDisconnect();\n      throw e;\n    }\n    this.flowControlTrace('local window size: ' + this.session.state.localWindowSize + ' remote window size: ' + this.session.state.remoteWindowSize);\n    this.internalsTrace('session.closed=' + this.session.closed + ' session.destroyed=' + this.session.destroyed + ' session.socket.destroyed=' + this.session.socket.destroyed);\n    let eventTracker;\n    let call;\n    if (this.channelzEnabled) {\n      this.streamTracker.addCallStarted();\n      eventTracker = {\n        addMessageSent: () => {\n          var _a;\n          this.messagesSent += 1;\n          this.lastMessageSentTimestamp = new Date();\n          (_a = subchannelCallStatsTracker.addMessageSent) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n        },\n        addMessageReceived: () => {\n          var _a;\n          this.messagesReceived += 1;\n          this.lastMessageReceivedTimestamp = new Date();\n          (_a = subchannelCallStatsTracker.addMessageReceived) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n        },\n        onCallEnd: status => {\n          var _a;\n          (_a = subchannelCallStatsTracker.onCallEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, status);\n          this.removeActiveCall(call);\n        },\n        onStreamEnd: success => {\n          var _a;\n          if (success) {\n            this.streamTracker.addCallSucceeded();\n          } else {\n            this.streamTracker.addCallFailed();\n          }\n          (_a = subchannelCallStatsTracker.onStreamEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, success);\n        }\n      };\n    } else {\n      eventTracker = {\n        addMessageSent: () => {\n          var _a;\n          (_a = subchannelCallStatsTracker.addMessageSent) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n        },\n        addMessageReceived: () => {\n          var _a;\n          (_a = subchannelCallStatsTracker.addMessageReceived) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n        },\n        onCallEnd: status => {\n          var _a;\n          (_a = subchannelCallStatsTracker.onCallEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, status);\n          this.removeActiveCall(call);\n        },\n        onStreamEnd: success => {\n          var _a;\n          (_a = subchannelCallStatsTracker.onStreamEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, success);\n        }\n      };\n    }\n    call = new subchannel_call_1.Http2SubchannelCall(http2Stream, eventTracker, listener, this, (0, call_number_1.getNextCallNumber)());\n    this.addActiveCall(call);\n    return call;\n  }\n  getChannelzRef() {\n    return this.channelzRef;\n  }\n  getPeerName() {\n    return this.subchannelAddressString;\n  }\n  shutdown() {\n    this.session.close();\n    (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n  }\n}\nclass Http2SubchannelConnector {\n  constructor(channelTarget) {\n    this.channelTarget = channelTarget;\n    this.session = null;\n    this.isShutdown = false;\n  }\n  trace(text) {}\n  createSession(address, credentials, options, proxyConnectionResult) {\n    if (this.isShutdown) {\n      return Promise.reject();\n    }\n    return new Promise((resolve, reject) => {\n      var _a, _b, _c;\n      let remoteName;\n      if (proxyConnectionResult.realTarget) {\n        remoteName = (0, uri_parser_1.uriToString)(proxyConnectionResult.realTarget);\n        this.trace('creating HTTP/2 session through proxy to ' + (0, uri_parser_1.uriToString)(proxyConnectionResult.realTarget));\n      } else {\n        remoteName = null;\n        this.trace('creating HTTP/2 session to ' + (0, subchannel_address_1.subchannelAddressToString)(address));\n      }\n      const targetAuthority = (0, resolver_1.getDefaultAuthority)((_a = proxyConnectionResult.realTarget) !== null && _a !== void 0 ? _a : this.channelTarget);\n      let connectionOptions = credentials._getConnectionOptions() || {};\n      connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;\n      if ('grpc-node.max_session_memory' in options) {\n        connectionOptions.maxSessionMemory = options['grpc-node.max_session_memory'];\n      } else {\n        /* By default, set a very large max session memory limit, to effectively\n         * disable enforcement of the limit. Some testing indicates that Node's\n         * behavior degrades badly when this limit is reached, so we solve that\n         * by disabling the check entirely. */\n        connectionOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n      }\n      let addressScheme = 'http://';\n      if ('secureContext' in connectionOptions) {\n        addressScheme = 'https://';\n        // If provided, the value of grpc.ssl_target_name_override should be used\n        // to override the target hostname when checking server identity.\n        // This option is used for testing only.\n        if (options['grpc.ssl_target_name_override']) {\n          const sslTargetNameOverride = options['grpc.ssl_target_name_override'];\n          connectionOptions.checkServerIdentity = (host, cert) => {\n            return (0, tls_1.checkServerIdentity)(sslTargetNameOverride, cert);\n          };\n          connectionOptions.servername = sslTargetNameOverride;\n        } else {\n          const authorityHostname = (_c = (_b = (0, uri_parser_1.splitHostPort)(targetAuthority)) === null || _b === void 0 ? void 0 : _b.host) !== null && _c !== void 0 ? _c : 'localhost';\n          // We want to always set servername to support SNI\n          connectionOptions.servername = authorityHostname;\n        }\n        if (proxyConnectionResult.socket) {\n          /* This is part of the workaround for\n           * https://github.com/nodejs/node/issues/32922. Without that bug,\n           * proxyConnectionResult.socket would always be a plaintext socket and\n           * this would say\n           * connectionOptions.socket = proxyConnectionResult.socket; */\n          connectionOptions.createConnection = (authority, option) => {\n            return proxyConnectionResult.socket;\n          };\n        }\n      } else {\n        /* In all but the most recent versions of Node, http2.connect does not use\n         * the options when establishing plaintext connections, so we need to\n         * establish that connection explicitly. */\n        connectionOptions.createConnection = (authority, option) => {\n          if (proxyConnectionResult.socket) {\n            return proxyConnectionResult.socket;\n          } else {\n            /* net.NetConnectOpts is declared in a way that is more restrictive\n             * than what net.connect will actually accept, so we use the type\n             * assertion to work around that. */\n            return net.connect(address);\n          }\n        };\n      }\n      connectionOptions = Object.assign(Object.assign({}, connectionOptions), address);\n      /* http2.connect uses the options here:\n       * https://github.com/nodejs/node/blob/70c32a6d190e2b5d7b9ff9d5b6a459d14e8b7d59/lib/internal/http2/core.js#L3028-L3036\n       * The spread operator overides earlier values with later ones, so any port\n       * or host values in the options will be used rather than any values extracted\n       * from the first argument. In addition, the path overrides the host and port,\n       * as documented for plaintext connections here:\n       * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener\n       * and for TLS connections here:\n       * https://nodejs.org/api/tls.html#tls_tls_connect_options_callback. In\n       * earlier versions of Node, http2.connect passes these options to\n       * tls.connect but not net.connect, so in the insecure case we still need\n       * to set the createConnection option above to create the connection\n       * explicitly. We cannot do that in the TLS case because http2.connect\n       * passes necessary additional options to tls.connect.\n       * The first argument just needs to be parseable as a URL and the scheme\n       * determines whether the connection will be established over TLS or not.\n       */\n      const session = http2.connect(addressScheme + targetAuthority, connectionOptions);\n      this.session = session;\n      session.unref();\n      session.once('connect', () => {\n        session.removeAllListeners();\n        resolve(new Http2Transport(session, address, options));\n        this.session = null;\n      });\n      session.once('close', () => {\n        this.session = null;\n        reject();\n      });\n      session.once('error', error => {\n        this.trace('connection failed with error ' + error.message);\n      });\n    });\n  }\n  connect(address, credentials, options) {\n    var _a, _b;\n    if (this.isShutdown) {\n      return Promise.reject();\n    }\n    /* Pass connection options through to the proxy so that it's able to\n     * upgrade it's connection to support tls if needed.\n     * This is a workaround for https://github.com/nodejs/node/issues/32922\n     * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\n    const connectionOptions = credentials._getConnectionOptions() || {};\n    if ('secureContext' in connectionOptions) {\n      connectionOptions.ALPNProtocols = ['h2'];\n      // If provided, the value of grpc.ssl_target_name_override should be used\n      // to override the target hostname when checking server identity.\n      // This option is used for testing only.\n      if (options['grpc.ssl_target_name_override']) {\n        const sslTargetNameOverride = options['grpc.ssl_target_name_override'];\n        connectionOptions.checkServerIdentity = (host, cert) => {\n          return (0, tls_1.checkServerIdentity)(sslTargetNameOverride, cert);\n        };\n        connectionOptions.servername = sslTargetNameOverride;\n      } else {\n        if ('grpc.http_connect_target' in options) {\n          /* This is more or less how servername will be set in createSession\n           * if a connection is successfully established through the proxy.\n           * If the proxy is not used, these connectionOptions are discarded\n           * anyway */\n          const targetPath = (0, resolver_1.getDefaultAuthority)((_a = (0, uri_parser_1.parseUri)(options['grpc.http_connect_target'])) !== null && _a !== void 0 ? _a : {\n            path: 'localhost'\n          });\n          const hostPort = (0, uri_parser_1.splitHostPort)(targetPath);\n          connectionOptions.servername = (_b = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _b !== void 0 ? _b : targetPath;\n        }\n      }\n    }\n    return (0, http_proxy_1.getProxiedConnection)(address, options, connectionOptions).then(result => this.createSession(address, credentials, options, result));\n  }\n  shutdown() {\n    var _a;\n    this.isShutdown = true;\n    (_a = this.session) === null || _a === void 0 ? void 0 : _a.close();\n    this.session = null;\n  }\n}\nexports.Http2SubchannelConnector = Http2SubchannelConnector;","map":{"version":3,"mappings":"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","names":["TRACER_NAME","FLOW_CONTROL_TRACER_NAME","clientVersion","require","version","HTTP2_HEADER_AUTHORITY","HTTP2_HEADER_CONTENT_TYPE","HTTP2_HEADER_METHOD","HTTP2_HEADER_PATH","HTTP2_HEADER_TE","HTTP2_HEADER_USER_AGENT","http2","constants","KEEPALIVE_MAX_TIME_MS","KEEPALIVE_TIMEOUT_MS","tooManyPingsData","Buffer","from","Http2Transport","constructor","session","subchannelAddress","options","Set","channelz_1","userAgent","filter","e","join","keepaliveTimeMs","keepaliveTimeoutMs","keepaliveWithoutCalls","keepaliveIntervalId","setTimeout","clearTimeout","startKeepalivePings","subchannelAddressString","channelzEnabled","channelzRef","getChannelzInfo","once","trace","stopKeepalivePings","handleDisconnect","errorCode","lastStreamID","opaqueData","tooManyPings","NGHTTP2_ENHANCE_YOUR_CALM","equals","reportDisconnectToOwner","error","message","logging","isTracerEnabled","on","settings","JSON","stringify","sessionSocket","socket","remoteAddress","remotePort","localAddress","localPort","tlsInfo","encrypted","tlsSocket","cipherInfo","getCipher","certificate","getCertificate","peerCertificate","getPeerCertificate","cipherSuiteStandardName","standardName","cipherSuiteOtherName","name","localCertificate","raw","remoteCertificate","socketInfo","security","remoteName","streamsStarted","streamTracker","callsStarted","streamsSucceeded","callsSucceeded","streamsFailed","callsFailed","messagesSent","messagesReceived","keepAlivesSent","keepalivesSent","lastLocalStreamCreatedTimestamp","lastCallStartedTimestamp","lastRemoteStreamCreatedTimestamp","lastMessageSentTimestamp","lastMessageReceivedTimestamp","localFlowControlWindow","state","localWindowSize","remoteFlowControlWindow","remoteWindowSize","text","constants_1","DEBUG","id","keepaliveTrace","flowControlTrace","internalsTrace","disconnectHandled","disconnectListeners","forEach","listener","setImmediate","call","activeCalls","onDisconnect","addDisconnectListener","push","clearKeepaliveTimeout","keepaliveTimeoutId","sendPing","unref","ping","err","duration","payload","setInterval","clearInterval","removeActiveCall","delete","size","addActiveCall","ref","add","createCall","metadata","host","method","subchannelCallStatsTracker","headers","toHttp2Headers","http2Stream","request","closed","destroyed","eventTracker","addCallStarted","addMessageSent","Date","addMessageReceived","onCallEnd","status","onStreamEnd","success","addCallSucceeded","addCallFailed","subchannel_call_1","getChannelzRef","getPeerName","shutdown","close","Http2SubchannelConnector","channelTarget","createSession","address","credentials","proxyConnectionResult","isShutdown","Promise","reject","resolve","realTarget","targetAuthority","connectionOptions","_getConnectionOptions","maxSendHeaderBlockLength","Number","MAX_SAFE_INTEGER","maxSessionMemory","addressScheme","sslTargetNameOverride","checkServerIdentity","cert","servername","authorityHostname","createConnection","authority","option","net","connect","removeAllListeners","ALPNProtocols","targetPath","path","hostPort","then","result","exports"],"sources":["/home/achwak/node_modules/@grpc/grpc-js/src/transport.ts"],"sourcesContent":["/*\n * Copyright 2023 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport * as http2 from 'http2';\nimport { checkServerIdentity, CipherNameAndProtocol, ConnectionOptions, PeerCertificate, TLSSocket } from 'tls';\nimport { StatusObject } from './call-interface';\nimport { ChannelCredentials } from './channel-credentials';\nimport { ChannelOptions } from './channel-options';\nimport { ChannelzCallTracker, registerChannelzSocket, SocketInfo, SocketRef, TlsInfo, unregisterChannelzRef } from './channelz';\nimport { LogVerbosity } from './constants';\nimport { getProxiedConnection, ProxyConnectionResult } from './http_proxy';\nimport * as logging from './logging';\nimport { getDefaultAuthority } from './resolver';\nimport { stringToSubchannelAddress, SubchannelAddress, subchannelAddressToString } from './subchannel-address';\nimport { GrpcUri, parseUri, splitHostPort, uriToString } from './uri-parser';\nimport * as net from 'net';\nimport { Http2SubchannelCall, SubchannelCall, SubchannelCallInterceptingListener } from './subchannel-call';\nimport { Metadata } from './metadata';\nimport { getNextCallNumber } from './call-number';\n\nconst TRACER_NAME = 'transport';\nconst FLOW_CONTROL_TRACER_NAME = 'transport_flowctrl';\n\nconst clientVersion = require('../../package.json').version;\n\nconst {\n  HTTP2_HEADER_AUTHORITY,\n  HTTP2_HEADER_CONTENT_TYPE,\n  HTTP2_HEADER_METHOD,\n  HTTP2_HEADER_PATH,\n  HTTP2_HEADER_TE,\n  HTTP2_HEADER_USER_AGENT,\n} = http2.constants;\n\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\n * have a constant for the max signed 32 bit integer, so this is a simple way\n * to calculate it */\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nconst KEEPALIVE_TIMEOUT_MS = 20000;\n\nexport interface CallEventTracker {\n  addMessageSent(): void;\n  addMessageReceived(): void;\n  onCallEnd(status: StatusObject): void;\n  onStreamEnd(success: boolean): void;\n}\n\nexport interface TransportDisconnectListener {\n  (tooManyPings: boolean): void;\n}\n\nexport interface Transport {\n  getChannelzRef(): SocketRef;\n  getPeerName(): string;\n  createCall(metadata: Metadata, host: string, method: string, listener: SubchannelCallInterceptingListener, subchannelCallStatsTracker: Partial<CallEventTracker>): SubchannelCall;\n  addDisconnectListener(listener: TransportDisconnectListener): void;\n  shutdown(): void;\n}\n\nconst tooManyPingsData: Buffer = Buffer.from('too_many_pings', 'ascii');\n\nclass Http2Transport implements Transport {\n  /**\n   * The amount of time in between sending pings\n   */\n  private keepaliveTimeMs: number = -1;\n  /**\n   * The amount of time to wait for an acknowledgement after sending a ping\n   */\n  private keepaliveTimeoutMs: number = KEEPALIVE_TIMEOUT_MS;\n  /**\n   * Timer reference for timeout that indicates when to send the next ping\n   */\n  private keepaliveIntervalId: NodeJS.Timer;\n  /**\n   * Timer reference tracking when the most recent ping will be considered lost\n   */\n  private keepaliveTimeoutId: NodeJS.Timer | null = null;\n  /**\n   * Indicates whether keepalive pings should be sent without any active calls\n   */\n  private keepaliveWithoutCalls = false;\n\n  private userAgent: string;\n\n  private activeCalls: Set<Http2SubchannelCall> = new Set();\n\n  private subchannelAddressString: string;\n\n  private disconnectListeners: TransportDisconnectListener[] = [];\n\n  private disconnectHandled = false;\n\n  // Channelz info\n  private channelzRef: SocketRef;\n  private readonly channelzEnabled: boolean = true;\n  /**\n   * Name of the remote server, if it is not the same as the subchannel\n   * address, i.e. if connecting through an HTTP CONNECT proxy.\n   */\n  private remoteName: string | null = null;\n  private streamTracker = new ChannelzCallTracker();\n  private keepalivesSent = 0;\n  private messagesSent = 0;\n  private messagesReceived = 0;\n  private lastMessageSentTimestamp: Date | null = null;\n  private lastMessageReceivedTimestamp: Date | null = null;\n\n  constructor(\n    private session: http2.ClientHttp2Session,\n    subchannelAddress: SubchannelAddress,\n    options: ChannelOptions\n  ) {\n    // Build user-agent string.\n    this.userAgent = [\n      options['grpc.primary_user_agent'],\n      `grpc-node-js/${clientVersion}`,\n      options['grpc.secondary_user_agent'],\n    ]\n      .filter((e) => e)\n      .join(' '); // remove falsey values first\n    \n    if ('grpc.keepalive_time_ms' in options) {\n      this.keepaliveTimeMs = options['grpc.keepalive_time_ms']!;\n    }\n    if ('grpc.keepalive_timeout_ms' in options) {\n      this.keepaliveTimeoutMs = options['grpc.keepalive_timeout_ms']!;\n    }\n    if ('grpc.keepalive_permit_without_calls' in options) {\n      this.keepaliveWithoutCalls =\n        options['grpc.keepalive_permit_without_calls'] === 1;\n    } else {\n      this.keepaliveWithoutCalls = false;\n    }\n    this.keepaliveIntervalId = setTimeout(() => {}, 0);\n    clearTimeout(this.keepaliveIntervalId);\n    if (this.keepaliveWithoutCalls) {\n      this.startKeepalivePings();\n    }\n\n    this.subchannelAddressString = subchannelAddressToString(subchannelAddress);\n\n    if (options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n    this.channelzRef = registerChannelzSocket(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);\n\n    session.once('close', () => {\n      this.trace('session closed');\n      this.stopKeepalivePings();\n      this.handleDisconnect();\n    });\n    session.once('goaway', (errorCode: number, lastStreamID: number, opaqueData: Buffer) => {\n      let tooManyPings = false;\n      /* See the last paragraph of\n       * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */\n      if (\n        errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM &&\n        opaqueData.equals(tooManyPingsData)\n      ) {\n        tooManyPings = true;\n      }\n      this.trace(\n        'connection closed by GOAWAY with code ' +\n          errorCode\n      );\n      this.reportDisconnectToOwner(tooManyPings);\n    });\n    session.once('error', error => {\n      /* Do nothing here. Any error should also trigger a close event, which is\n       * where we want to handle that.  */\n      this.trace(\n        'connection closed with error ' +\n          (error as Error).message\n      );\n    });\n    if (logging.isTracerEnabled(TRACER_NAME)) {\n      session.on('remoteSettings', (settings: http2.Settings) => {\n        this.trace(\n          'new settings received' +\n            (this.session !== session ? ' on the old connection' : '') +\n            ': ' +\n            JSON.stringify(settings)\n        );\n      });\n      session.on('localSettings', (settings: http2.Settings) => {\n        this.trace(\n          'local settings acknowledged by remote' +\n            (this.session !== session ? ' on the old connection' : '') +\n            ': ' +\n            JSON.stringify(settings)\n        );\n      });\n    }\n  }\n\n  private getChannelzInfo(): SocketInfo {\n    const sessionSocket = this.session.socket;\n    const remoteAddress = sessionSocket.remoteAddress ? stringToSubchannelAddress(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n    const localAddress = sessionSocket.localAddress ? stringToSubchannelAddress(sessionSocket.localAddress, sessionSocket.localPort) : null;\n    let tlsInfo: TlsInfo | null;\n    if (this.session.encrypted) {\n      const tlsSocket: TLSSocket = sessionSocket as TLSSocket;\n      const cipherInfo: CipherNameAndProtocol & {standardName?: string} = tlsSocket.getCipher();\n      const certificate = tlsSocket.getCertificate();\n      const peerCertificate = tlsSocket.getPeerCertificate();\n      tlsInfo = {\n        cipherSuiteStandardName: cipherInfo.standardName ?? null,\n        cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n        localCertificate: (certificate && 'raw' in certificate) ? certificate.raw : null,\n        remoteCertificate: (peerCertificate && 'raw' in peerCertificate) ? peerCertificate.raw : null\n      };\n    } else {\n      tlsInfo = null;\n    }\n    const socketInfo: SocketInfo = {\n      remoteAddress: remoteAddress,\n      localAddress: localAddress,\n      security: tlsInfo,\n      remoteName: this.remoteName,\n      streamsStarted: this.streamTracker.callsStarted,\n      streamsSucceeded: this.streamTracker.callsSucceeded,\n      streamsFailed: this.streamTracker.callsFailed,\n      messagesSent: this.messagesSent,\n      messagesReceived: this.messagesReceived,\n      keepAlivesSent: this.keepalivesSent,\n      lastLocalStreamCreatedTimestamp: this.streamTracker.lastCallStartedTimestamp,\n      lastRemoteStreamCreatedTimestamp: null,\n      lastMessageSentTimestamp: this.lastMessageSentTimestamp,\n      lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,\n      localFlowControlWindow: this.session.state.localWindowSize ?? null,\n      remoteFlowControlWindow: this.session.state.remoteWindowSize ?? null\n    };\n    return socketInfo;\n  }\n\n  private trace(text: string): void {\n    logging.trace(LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  private keepaliveTrace(text: string): void {\n    logging.trace(LogVerbosity.DEBUG, 'keepalive', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  private flowControlTrace(text: string): void {\n    logging.trace(LogVerbosity.DEBUG, FLOW_CONTROL_TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  private internalsTrace(text: string): void {\n    logging.trace(LogVerbosity.DEBUG, 'transport_internals', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  /**\n   * Indicate to the owner of this object that this transport should no longer\n   * be used. That happens if the connection drops, or if the server sends a\n   * GOAWAY.\n   * @param tooManyPings If true, this was triggered by a GOAWAY with data\n   * indicating that the session was closed becaues the client sent too many\n   * pings.\n   * @returns \n   */\n  private reportDisconnectToOwner(tooManyPings: boolean) {\n    if (this.disconnectHandled) {\n      return;\n    }\n    this.disconnectHandled = true;\n    this.disconnectListeners.forEach(listener => listener(tooManyPings));\n  }\n\n  /**\n   * Handle connection drops, but not GOAWAYs.\n   */\n  private handleDisconnect() {\n    this.reportDisconnectToOwner(false);\n    /* Give calls an event loop cycle to finish naturally before reporting the\n     * disconnnection to them. */\n    setImmediate(() => {\n      for (const call of this.activeCalls) {\n        call.onDisconnect();\n      }\n    });\n  }\n\n  addDisconnectListener(listener: TransportDisconnectListener): void {\n    this.disconnectListeners.push(listener);\n  }\n\n  private clearKeepaliveTimeout() {\n    if (!this.keepaliveTimeoutId) {\n      return;\n    }\n    clearTimeout(this.keepaliveTimeoutId);\n    this.keepaliveTimeoutId = null;\n  }\n\n  private sendPing() {\n    if (this.channelzEnabled) {\n      this.keepalivesSent += 1;\n    }\n    this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');\n    if (!this.keepaliveTimeoutId) {\n      this.keepaliveTimeoutId = setTimeout(() => {\n        this.keepaliveTrace('Ping timeout passed without response');\n        this.handleDisconnect();\n      }, this.keepaliveTimeoutMs);\n      this.keepaliveTimeoutId.unref?.();\n    }\n    try {\n      this.session!.ping(\n        (err: Error | null, duration: number, payload: Buffer) => {\n          this.keepaliveTrace('Received ping response');\n          this.clearKeepaliveTimeout();\n        }\n      );\n    } catch (e) {\n      /* If we fail to send a ping, the connection is no longer functional, so\n       * we should discard it. */\n      this.handleDisconnect();\n    }\n  }\n\n  private startKeepalivePings() {\n    if (this.keepaliveTimeMs < 0) {\n      return;\n    }\n    this.keepaliveIntervalId = setInterval(() => {\n      this.sendPing();\n    }, this.keepaliveTimeMs);\n    this.keepaliveIntervalId.unref?.();\n    /* Don't send a ping immediately because whatever caused us to start\n     * sending pings should also involve some network activity. */\n  }\n\n  /**\n   * Stop keepalive pings when terminating a connection. This discards the\n   * outstanding ping timeout, so it should not be called if the same\n   * connection will still be used.\n   */\n  private stopKeepalivePings() {\n    clearInterval(this.keepaliveIntervalId);\n    this.clearKeepaliveTimeout();\n  }\n\n  private removeActiveCall(call: Http2SubchannelCall) {\n    this.activeCalls.delete(call);\n    if (this.activeCalls.size === 0) {\n      this.session.unref();\n      if (!this.keepaliveWithoutCalls) {\n        this.stopKeepalivePings();\n      }\n    }\n  }\n\n  private addActiveCall(call: Http2SubchannelCall) {\n    if (this.activeCalls.size === 0) {\n      this.session.ref();\n      if (!this.keepaliveWithoutCalls) {\n        this.startKeepalivePings();\n      }\n    }\n    this.activeCalls.add(call);\n  }\n\n  createCall(metadata: Metadata, host: string, method: string, listener: SubchannelCallInterceptingListener, subchannelCallStatsTracker: Partial<CallEventTracker>): Http2SubchannelCall {\n    const headers = metadata.toHttp2Headers();\n    headers[HTTP2_HEADER_AUTHORITY] = host;\n    headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\n    headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';\n    headers[HTTP2_HEADER_METHOD] = 'POST';\n    headers[HTTP2_HEADER_PATH] = method;\n    headers[HTTP2_HEADER_TE] = 'trailers';\n    let http2Stream: http2.ClientHttp2Stream;\n    /* In theory, if an error is thrown by session.request because session has\n     * become unusable (e.g. because it has received a goaway), this subchannel\n     * should soon see the corresponding close or goaway event anyway and leave\n     * READY. But we have seen reports that this does not happen\n     * (https://github.com/googleapis/nodejs-firestore/issues/1023#issuecomment-653204096)\n     * so for defense in depth, we just discard the session when we see an\n     * error here.\n     */\n    try {\n      http2Stream = this.session!.request(headers);\n    } catch (e) {\n      this.handleDisconnect();\n      throw e;\n    }\n    this.flowControlTrace(\n      'local window size: ' +\n        this.session.state.localWindowSize +\n        ' remote window size: ' +\n        this.session.state.remoteWindowSize\n    );\n    this.internalsTrace(\n      'session.closed=' + \n      this.session.closed + \n      ' session.destroyed=' + \n      this.session.destroyed + \n      ' session.socket.destroyed=' + \n      this.session.socket.destroyed);\n    let eventTracker: CallEventTracker;\n    let call: Http2SubchannelCall;\n    if (this.channelzEnabled) {\n      this.streamTracker.addCallStarted();\n      eventTracker = {\n        addMessageSent: () => {\n          this.messagesSent += 1;\n          this.lastMessageSentTimestamp = new Date();\n          subchannelCallStatsTracker.addMessageSent?.();\n        },\n        addMessageReceived: () => {\n          this.messagesReceived += 1;\n          this.lastMessageReceivedTimestamp = new Date();\n          subchannelCallStatsTracker.addMessageReceived?.();\n        },\n        onCallEnd: status => {\n          subchannelCallStatsTracker.onCallEnd?.(status);\n          this.removeActiveCall(call);\n        },\n        onStreamEnd: success => {\n          if (success) {\n            this.streamTracker.addCallSucceeded();\n          } else {\n            this.streamTracker.addCallFailed();\n          }\n          subchannelCallStatsTracker.onStreamEnd?.(success);\n        }\n      }\n    } else {\n      eventTracker = {\n        addMessageSent: () => {\n          subchannelCallStatsTracker.addMessageSent?.();\n        },\n        addMessageReceived: () => {\n          subchannelCallStatsTracker.addMessageReceived?.();\n        },\n        onCallEnd: (status) => {\n          subchannelCallStatsTracker.onCallEnd?.(status);\n          this.removeActiveCall(call);\n        },\n        onStreamEnd: (success) => {\n          subchannelCallStatsTracker.onStreamEnd?.(success);\n        }\n      }\n    }\n    call = new Http2SubchannelCall(http2Stream, eventTracker, listener, this, getNextCallNumber());\n    this.addActiveCall(call);\n    return call;\n  }\n\n  getChannelzRef(): SocketRef {\n    return this.channelzRef;\n  }\n\n  getPeerName() {\n    return this.subchannelAddressString;\n  }\n\n  shutdown() {\n    this.session.close();\n    unregisterChannelzRef(this.channelzRef);\n  }\n}\n\nexport interface SubchannelConnector {\n  connect(address: SubchannelAddress, credentials: ChannelCredentials, options: ChannelOptions): Promise<Transport>;\n  shutdown(): void;\n}\n\nexport class Http2SubchannelConnector implements SubchannelConnector {\n  private session: http2.ClientHttp2Session | null = null;\n  private isShutdown = false;\n  constructor(private channelTarget: GrpcUri) {}\n  private trace(text: string) {\n\n  }\n  private createSession(address: SubchannelAddress, credentials: ChannelCredentials, options: ChannelOptions, proxyConnectionResult: ProxyConnectionResult): Promise<Http2Transport> {\n    if (this.isShutdown) {\n      return Promise.reject();\n    }\n    return new Promise<Http2Transport>((resolve, reject) => {\n      let remoteName: string | null;\n      if (proxyConnectionResult.realTarget) {\n        remoteName = uriToString(proxyConnectionResult.realTarget);\n        this.trace('creating HTTP/2 session through proxy to ' + uriToString(proxyConnectionResult.realTarget));\n      } else {\n        remoteName = null;\n        this.trace('creating HTTP/2 session to ' + subchannelAddressToString(address));\n      }\n      const targetAuthority = getDefaultAuthority(\n        proxyConnectionResult.realTarget ?? this.channelTarget\n      );\n      let connectionOptions: http2.SecureClientSessionOptions =\n        credentials._getConnectionOptions() || {};\n      connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;\n      if ('grpc-node.max_session_memory' in options) {\n        connectionOptions.maxSessionMemory = options[\n          'grpc-node.max_session_memory'\n        ];\n      } else {\n        /* By default, set a very large max session memory limit, to effectively\n         * disable enforcement of the limit. Some testing indicates that Node's\n         * behavior degrades badly when this limit is reached, so we solve that\n         * by disabling the check entirely. */\n        connectionOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n      }\n      let addressScheme = 'http://';\n      if ('secureContext' in connectionOptions) {\n        addressScheme = 'https://';\n        // If provided, the value of grpc.ssl_target_name_override should be used\n        // to override the target hostname when checking server identity.\n        // This option is used for testing only.\n        if (options['grpc.ssl_target_name_override']) {\n          const sslTargetNameOverride = options[\n            'grpc.ssl_target_name_override'\n          ]!;\n          connectionOptions.checkServerIdentity = (\n            host: string,\n            cert: PeerCertificate\n          ): Error | undefined => {\n            return checkServerIdentity(sslTargetNameOverride, cert);\n          };\n          connectionOptions.servername = sslTargetNameOverride;\n        } else {\n          const authorityHostname =\n            splitHostPort(targetAuthority)?.host ?? 'localhost';\n          // We want to always set servername to support SNI\n          connectionOptions.servername = authorityHostname;\n        }\n        if (proxyConnectionResult.socket) {\n          /* This is part of the workaround for\n           * https://github.com/nodejs/node/issues/32922. Without that bug,\n           * proxyConnectionResult.socket would always be a plaintext socket and\n           * this would say\n           * connectionOptions.socket = proxyConnectionResult.socket; */\n          connectionOptions.createConnection = (authority, option) => {\n            return proxyConnectionResult.socket!;\n          };\n        }\n      } else {\n        /* In all but the most recent versions of Node, http2.connect does not use\n         * the options when establishing plaintext connections, so we need to\n         * establish that connection explicitly. */\n        connectionOptions.createConnection = (authority, option) => {\n          if (proxyConnectionResult.socket) {\n            return proxyConnectionResult.socket;\n          } else {\n            /* net.NetConnectOpts is declared in a way that is more restrictive\n             * than what net.connect will actually accept, so we use the type\n             * assertion to work around that. */\n            return net.connect(address);\n          }\n        };\n      }\n  \n      connectionOptions = {\n        ...connectionOptions,\n        ...address,\n      };\n  \n      /* http2.connect uses the options here:\n       * https://github.com/nodejs/node/blob/70c32a6d190e2b5d7b9ff9d5b6a459d14e8b7d59/lib/internal/http2/core.js#L3028-L3036\n       * The spread operator overides earlier values with later ones, so any port\n       * or host values in the options will be used rather than any values extracted\n       * from the first argument. In addition, the path overrides the host and port,\n       * as documented for plaintext connections here:\n       * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener\n       * and for TLS connections here:\n       * https://nodejs.org/api/tls.html#tls_tls_connect_options_callback. In\n       * earlier versions of Node, http2.connect passes these options to\n       * tls.connect but not net.connect, so in the insecure case we still need\n       * to set the createConnection option above to create the connection\n       * explicitly. We cannot do that in the TLS case because http2.connect\n       * passes necessary additional options to tls.connect.\n       * The first argument just needs to be parseable as a URL and the scheme\n       * determines whether the connection will be established over TLS or not.\n       */\n      const session = http2.connect(\n        addressScheme + targetAuthority,\n        connectionOptions\n      );\n      this.session = session;\n      session.unref();\n      session.once('connect', () => {\n        session.removeAllListeners();\n        resolve(new Http2Transport(session, address, options));\n        this.session = null;\n      });\n      session.once('close', () => {\n        this.session = null;\n        reject();\n      });\n      session.once('error', error => {\n        this.trace('connection failed with error ' + (error as Error).message)\n      });\n    });\n  }\n  connect(address: SubchannelAddress, credentials: ChannelCredentials, options: ChannelOptions): Promise<Http2Transport> {\n    if (this.isShutdown) {\n      return Promise.reject();\n    }\n    /* Pass connection options through to the proxy so that it's able to\n     * upgrade it's connection to support tls if needed.\n     * This is a workaround for https://github.com/nodejs/node/issues/32922\n     * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\n    const connectionOptions: ConnectionOptions =\n      credentials._getConnectionOptions() || {};\n\n    if ('secureContext' in connectionOptions) {\n      connectionOptions.ALPNProtocols = ['h2'];\n      // If provided, the value of grpc.ssl_target_name_override should be used\n      // to override the target hostname when checking server identity.\n      // This option is used for testing only.\n      if (options['grpc.ssl_target_name_override']) {\n        const sslTargetNameOverride = options[\n          'grpc.ssl_target_name_override'\n        ]!;\n        connectionOptions.checkServerIdentity = (\n          host: string,\n          cert: PeerCertificate\n        ): Error | undefined => {\n          return checkServerIdentity(sslTargetNameOverride, cert);\n        };\n        connectionOptions.servername = sslTargetNameOverride;\n      } else {\n        if ('grpc.http_connect_target' in options) {\n          /* This is more or less how servername will be set in createSession\n           * if a connection is successfully established through the proxy.\n           * If the proxy is not used, these connectionOptions are discarded\n           * anyway */\n          const targetPath = getDefaultAuthority(\n            parseUri(options['grpc.http_connect_target'] as string) ?? {\n              path: 'localhost',\n            }\n          );\n          const hostPort = splitHostPort(targetPath);\n          connectionOptions.servername = hostPort?.host ?? targetPath;\n        }\n      }\n    }\n\n    return getProxiedConnection(\n      address,\n      options,\n      connectionOptions\n    ).then(\n      result => this.createSession(address, credentials, options, result)\n    );\n  }\n\n  shutdown(): void {\n    this.isShutdown = true;\n    this.session?.close();\n    this.session = null;\n  }\n}"]},"metadata":{},"sourceType":"script","externalDependencies":[]}