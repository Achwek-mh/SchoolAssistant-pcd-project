{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BackoffTimeout = void 0;\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */\nfunction uniformRandom(min, max) {\n  return Math.random() * (max - min) + min;\n}\nclass BackoffTimeout {\n  constructor(callback, options) {\n    this.callback = callback;\n    /**\n     * The delay time at the start, and after each reset.\n     */\n    this.initialDelay = INITIAL_BACKOFF_MS;\n    /**\n     * The exponential backoff multiplier.\n     */\n    this.multiplier = BACKOFF_MULTIPLIER;\n    /**\n     * The maximum delay time\n     */\n    this.maxDelay = MAX_BACKOFF_MS;\n    /**\n     * The maximum fraction by which the delay time can randomly vary after\n     * applying the multiplier.\n     */\n    this.jitter = BACKOFF_JITTER;\n    /**\n     * Indicates whether the timer is currently running.\n     */\n    this.running = false;\n    /**\n     * Indicates whether the timer should keep the Node process running if no\n     * other async operation is doing so.\n     */\n    this.hasRef = true;\n    /**\n     * The time that the currently running timer was started. Only valid if\n     * running is true.\n     */\n    this.startTime = new Date();\n    if (options) {\n      if (options.initialDelay) {\n        this.initialDelay = options.initialDelay;\n      }\n      if (options.multiplier) {\n        this.multiplier = options.multiplier;\n      }\n      if (options.jitter) {\n        this.jitter = options.jitter;\n      }\n      if (options.maxDelay) {\n        this.maxDelay = options.maxDelay;\n      }\n    }\n    this.nextDelay = this.initialDelay;\n    this.timerId = setTimeout(() => {}, 0);\n    clearTimeout(this.timerId);\n  }\n  runTimer(delay) {\n    var _a, _b;\n    clearTimeout(this.timerId);\n    this.timerId = setTimeout(() => {\n      this.callback();\n      this.running = false;\n    }, delay);\n    if (!this.hasRef) {\n      (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n  }\n  /**\n   * Call the callback after the current amount of delay time\n   */\n  runOnce() {\n    this.running = true;\n    this.startTime = new Date();\n    this.runTimer(this.nextDelay);\n    const nextBackoff = Math.min(this.nextDelay * this.multiplier, this.maxDelay);\n    const jitterMagnitude = nextBackoff * this.jitter;\n    this.nextDelay = nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);\n  }\n  /**\n   * Stop the timer. The callback will not be called until `runOnce` is called\n   * again.\n   */\n  stop() {\n    clearTimeout(this.timerId);\n    this.running = false;\n  }\n  /**\n   * Reset the delay time to its initial value. If the timer is still running,\n   * retroactively apply that reset to the current timer.\n   */\n  reset() {\n    this.nextDelay = this.initialDelay;\n    if (this.running) {\n      const now = new Date();\n      const newEndTime = this.startTime;\n      newEndTime.setMilliseconds(newEndTime.getMilliseconds() + this.nextDelay);\n      clearTimeout(this.timerId);\n      if (now < newEndTime) {\n        this.runTimer(newEndTime.getTime() - now.getTime());\n      } else {\n        this.running = false;\n      }\n    }\n  }\n  /**\n   * Check whether the timer is currently running.\n   */\n  isRunning() {\n    return this.running;\n  }\n  /**\n   * Set that while the timer is running, it should keep the Node process\n   * running.\n   */\n  ref() {\n    var _a, _b;\n    this.hasRef = true;\n    (_b = (_a = this.timerId).ref) === null || _b === void 0 ? void 0 : _b.call(_a);\n  }\n  /**\n   * Set that while the timer is running, it should not keep the Node process\n   * running.\n   */\n  unref() {\n    var _a, _b;\n    this.hasRef = false;\n    (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n  }\n}\nexports.BackoffTimeout = BackoffTimeout;","map":{"version":3,"mappings":"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","names":["INITIAL_BACKOFF_MS","BACKOFF_MULTIPLIER","MAX_BACKOFF_MS","BACKOFF_JITTER","uniformRandom","min","max","Math","random","BackoffTimeout","constructor","callback","options","Date","initialDelay","multiplier","jitter","maxDelay","nextDelay","timerId","setTimeout","clearTimeout","runTimer","delay","running","hasRef","unref","runOnce","startTime","nextBackoff","jitterMagnitude","stop","reset","now","newEndTime","setMilliseconds","getMilliseconds","getTime","isRunning","ref","exports"],"sources":["/home/achwak/node_modules/@grpc/grpc-js/src/backoff-timeout.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */\nfunction uniformRandom(min: number, max: number) {\n  return Math.random() * (max - min) + min;\n}\n\nexport interface BackoffOptions {\n  initialDelay?: number;\n  multiplier?: number;\n  jitter?: number;\n  maxDelay?: number;\n}\n\nexport class BackoffTimeout {\n  /**\n   * The delay time at the start, and after each reset.\n   */\n  private readonly initialDelay: number = INITIAL_BACKOFF_MS;\n  /**\n   * The exponential backoff multiplier.\n   */\n  private readonly multiplier: number = BACKOFF_MULTIPLIER;\n  /**\n   * The maximum delay time\n   */\n  private readonly maxDelay: number = MAX_BACKOFF_MS;\n  /**\n   * The maximum fraction by which the delay time can randomly vary after\n   * applying the multiplier.\n   */\n  private readonly jitter: number = BACKOFF_JITTER;\n  /**\n   * The delay time for the next time the timer runs.\n   */\n  private nextDelay: number;\n  /**\n   * The handle of the underlying timer. If running is false, this value refers\n   * to an object representing a timer that has ended, but it can still be\n   * interacted with without error.\n   */\n  private timerId: NodeJS.Timer;\n  /**\n   * Indicates whether the timer is currently running.\n   */\n  private running = false;\n  /**\n   * Indicates whether the timer should keep the Node process running if no\n   * other async operation is doing so.\n   */\n  private hasRef = true;\n  /**\n   * The time that the currently running timer was started. Only valid if\n   * running is true.\n   */\n  private startTime: Date = new Date();\n\n  constructor(private callback: () => void, options?: BackoffOptions) {\n    if (options) {\n      if (options.initialDelay) {\n        this.initialDelay = options.initialDelay;\n      }\n      if (options.multiplier) {\n        this.multiplier = options.multiplier;\n      }\n      if (options.jitter) {\n        this.jitter = options.jitter;\n      }\n      if (options.maxDelay) {\n        this.maxDelay = options.maxDelay;\n      }\n    }\n    this.nextDelay = this.initialDelay;\n    this.timerId = setTimeout(() => {}, 0);\n    clearTimeout(this.timerId);\n  }\n\n  private runTimer(delay: number) {\n    clearTimeout(this.timerId);\n    this.timerId = setTimeout(() => {\n      this.callback();\n      this.running = false;\n    }, delay);\n    if (!this.hasRef) {\n      this.timerId.unref?.();\n    }\n  }\n\n  /**\n   * Call the callback after the current amount of delay time\n   */\n  runOnce() {\n    this.running = true;\n    this.startTime = new Date();\n    this.runTimer(this.nextDelay);\n    const nextBackoff = Math.min(\n      this.nextDelay * this.multiplier,\n      this.maxDelay\n    );\n    const jitterMagnitude = nextBackoff * this.jitter;\n    this.nextDelay =\n      nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);\n  }\n\n  /**\n   * Stop the timer. The callback will not be called until `runOnce` is called\n   * again.\n   */\n  stop() {\n    clearTimeout(this.timerId);\n    this.running = false;\n  }\n\n  /**\n   * Reset the delay time to its initial value. If the timer is still running,\n   * retroactively apply that reset to the current timer.\n   */\n  reset() {\n    this.nextDelay = this.initialDelay;\n    if (this.running) {\n      const now = new Date();\n      const newEndTime = this.startTime;\n      newEndTime.setMilliseconds(newEndTime.getMilliseconds() + this.nextDelay);\n      clearTimeout(this.timerId);\n      if (now < newEndTime) {\n        this.runTimer(newEndTime.getTime() - now.getTime());\n      } else {\n        this.running = false;\n      }\n    }\n  }\n\n  /**\n   * Check whether the timer is currently running.\n   */\n  isRunning() {\n    return this.running;\n  }\n\n  /**\n   * Set that while the timer is running, it should keep the Node process\n   * running.\n   */\n  ref() {\n    this.hasRef = true;\n    this.timerId.ref?.();\n  }\n\n  /**\n   * Set that while the timer is running, it should not keep the Node process\n   * running.\n   */\n  unref() {\n    this.hasRef = false;\n    this.timerId.unref?.();\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}