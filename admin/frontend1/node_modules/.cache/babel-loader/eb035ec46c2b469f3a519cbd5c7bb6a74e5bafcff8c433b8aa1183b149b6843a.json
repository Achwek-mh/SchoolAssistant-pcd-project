{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InternalChannel = void 0;\nconst channel_credentials_1 = require(\"./channel-credentials\");\nconst resolving_load_balancer_1 = require(\"./resolving-load-balancer\");\nconst subchannel_pool_1 = require(\"./subchannel-pool\");\nconst picker_1 = require(\"./picker\");\nconst constants_1 = require(\"./constants\");\nconst filter_stack_1 = require(\"./filter-stack\");\nconst compression_filter_1 = require(\"./compression-filter\");\nconst resolver_1 = require(\"./resolver\");\nconst logging_1 = require(\"./logging\");\nconst max_message_size_filter_1 = require(\"./max-message-size-filter\");\nconst http_proxy_1 = require(\"./http_proxy\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst channelz_1 = require(\"./channelz\");\nconst load_balancing_call_1 = require(\"./load-balancing-call\");\nconst deadline_1 = require(\"./deadline\");\nconst resolving_call_1 = require(\"./resolving-call\");\nconst call_number_1 = require(\"./call-number\");\nconst control_plane_status_1 = require(\"./control-plane-status\");\nconst retrying_call_1 = require(\"./retrying-call\");\nconst subchannel_interface_1 = require(\"./subchannel-interface\");\n/**\n * See https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_args\n */\nconst MAX_TIMEOUT_TIME = 2147483647;\nconst RETRY_THROTTLER_MAP = new Map();\nconst DEFAULT_RETRY_BUFFER_SIZE_BYTES = 1 << 24; // 16 MB\nconst DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES = 1 << 20; // 1 MB\nclass ChannelSubchannelWrapper extends subchannel_interface_1.BaseSubchannelWrapper {\n  constructor(childSubchannel, channel) {\n    super(childSubchannel);\n    this.channel = channel;\n    this.refCount = 0;\n    this.subchannelStateListener = (subchannel, previousState, newState, keepaliveTime) => {\n      channel.throttleKeepalive(keepaliveTime);\n    };\n    childSubchannel.addConnectivityStateListener(this.subchannelStateListener);\n  }\n  ref() {\n    this.child.ref();\n    this.refCount += 1;\n  }\n  unref() {\n    this.child.unref();\n    this.refCount -= 1;\n    if (this.refCount <= 0) {\n      this.child.removeConnectivityStateListener(this.subchannelStateListener);\n      this.channel.removeWrappedSubchannel(this);\n    }\n  }\n}\nclass InternalChannel {\n  constructor(target, credentials, options) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    this.credentials = credentials;\n    this.options = options;\n    this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\n    this.currentPicker = new picker_1.UnavailablePicker();\n    /**\n     * Calls queued up to get a call config. Should only be populated before the\n     * first time the resolver returns a result, which includes the ConfigSelector.\n     */\n    this.configSelectionQueue = [];\n    this.pickQueue = [];\n    this.connectivityStateWatchers = [];\n    this.configSelector = null;\n    /**\n     * This is the error from the name resolver if it failed most recently. It\n     * is only used to end calls that start while there is no config selector\n     * and the name resolver is in backoff, so it should be nulled if\n     * configSelector becomes set or the channel state becomes anything other\n     * than TRANSIENT_FAILURE.\n     */\n    this.currentResolutionError = null;\n    this.wrappedSubchannels = new Set();\n    // Channelz info\n    this.channelzEnabled = true;\n    this.callTracker = new channelz_1.ChannelzCallTracker();\n    this.childrenTracker = new channelz_1.ChannelzChildrenTracker();\n    if (typeof target !== 'string') {\n      throw new TypeError('Channel target must be a string');\n    }\n    if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {\n      throw new TypeError('Channel credentials must be a ChannelCredentials object');\n    }\n    if (options) {\n      if (typeof options !== 'object') {\n        throw new TypeError('Channel options must be an object');\n      }\n    }\n    this.originalTarget = target;\n    const originalTargetUri = (0, uri_parser_1.parseUri)(target);\n    if (originalTargetUri === null) {\n      throw new Error(`Could not parse target name \"${target}\"`);\n    }\n    /* This ensures that the target has a scheme that is registered with the\n     * resolver */\n    const defaultSchemeMapResult = (0, resolver_1.mapUriDefaultScheme)(originalTargetUri);\n    if (defaultSchemeMapResult === null) {\n      throw new Error(`Could not find a default scheme for target name \"${target}\"`);\n    }\n    this.callRefTimer = setInterval(() => {}, MAX_TIMEOUT_TIME);\n    (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    if (this.options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n    this.channelzTrace = new channelz_1.ChannelzTrace();\n    this.channelzRef = (0, channelz_1.registerChannelzChannel)(target, () => this.getChannelzInfo(), this.channelzEnabled);\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', 'Channel created');\n    }\n    if (this.options['grpc.default_authority']) {\n      this.defaultAuthority = this.options['grpc.default_authority'];\n    } else {\n      this.defaultAuthority = (0, resolver_1.getDefaultAuthority)(defaultSchemeMapResult);\n    }\n    const proxyMapResult = (0, http_proxy_1.mapProxyName)(defaultSchemeMapResult, options);\n    this.target = proxyMapResult.target;\n    this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);\n    /* The global boolean parameter to getSubchannelPool has the inverse meaning to what\n     * the grpc.use_local_subchannel_pool channel option means. */\n    this.subchannelPool = (0, subchannel_pool_1.getSubchannelPool)(((_c = options['grpc.use_local_subchannel_pool']) !== null && _c !== void 0 ? _c : 0) === 0);\n    this.retryBufferTracker = new retrying_call_1.MessageBufferTracker((_d = options['grpc.retry_buffer_size']) !== null && _d !== void 0 ? _d : DEFAULT_RETRY_BUFFER_SIZE_BYTES, (_e = options['grpc.per_rpc_retry_buffer_size']) !== null && _e !== void 0 ? _e : DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES);\n    this.keepaliveTime = (_f = options['grpc.keepalive_time_ms']) !== null && _f !== void 0 ? _f : -1;\n    const channelControlHelper = {\n      createSubchannel: (subchannelAddress, subchannelArgs) => {\n        const subchannel = this.subchannelPool.getOrCreateSubchannel(this.target, subchannelAddress, Object.assign({}, this.options, subchannelArgs), this.credentials);\n        subchannel.throttleKeepalive(this.keepaliveTime);\n        if (this.channelzEnabled) {\n          this.channelzTrace.addTrace('CT_INFO', 'Created subchannel or used existing subchannel', subchannel.getChannelzRef());\n        }\n        const wrappedSubchannel = new ChannelSubchannelWrapper(subchannel, this);\n        this.wrappedSubchannels.add(wrappedSubchannel);\n        return wrappedSubchannel;\n      },\n      updateState: (connectivityState, picker) => {\n        this.currentPicker = picker;\n        const queueCopy = this.pickQueue.slice();\n        this.pickQueue = [];\n        this.callRefTimerUnref();\n        for (const call of queueCopy) {\n          call.doPick();\n        }\n        this.updateState(connectivityState);\n      },\n      requestReresolution: () => {\n        // This should never be called.\n        throw new Error('Resolving load balancer should never call requestReresolution');\n      },\n      addChannelzChild: child => {\n        if (this.channelzEnabled) {\n          this.childrenTracker.refChild(child);\n        }\n      },\n      removeChannelzChild: child => {\n        if (this.channelzEnabled) {\n          this.childrenTracker.unrefChild(child);\n        }\n      }\n    };\n    this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(this.target, channelControlHelper, options, (serviceConfig, configSelector) => {\n      if (serviceConfig.retryThrottling) {\n        RETRY_THROTTLER_MAP.set(this.getTarget(), new retrying_call_1.RetryThrottler(serviceConfig.retryThrottling.maxTokens, serviceConfig.retryThrottling.tokenRatio, RETRY_THROTTLER_MAP.get(this.getTarget())));\n      } else {\n        RETRY_THROTTLER_MAP.delete(this.getTarget());\n      }\n      if (this.channelzEnabled) {\n        this.channelzTrace.addTrace('CT_INFO', 'Address resolution succeeded');\n      }\n      this.configSelector = configSelector;\n      this.currentResolutionError = null;\n      /* We process the queue asynchronously to ensure that the corresponding\n       * load balancer update has completed. */\n      process.nextTick(() => {\n        const localQueue = this.configSelectionQueue;\n        this.configSelectionQueue = [];\n        this.callRefTimerUnref();\n        for (const call of localQueue) {\n          call.getConfig();\n        }\n        this.configSelectionQueue = [];\n      });\n    }, status => {\n      if (this.channelzEnabled) {\n        this.channelzTrace.addTrace('CT_WARNING', 'Address resolution failed with code ' + status.code + ' and details \"' + status.details + '\"');\n      }\n      if (this.configSelectionQueue.length > 0) {\n        this.trace('Name resolution failed with calls queued for config selection');\n      }\n      if (this.configSelector === null) {\n        this.currentResolutionError = Object.assign(Object.assign({}, (0, control_plane_status_1.restrictControlPlaneStatusCode)(status.code, status.details)), {\n          metadata: status.metadata\n        });\n      }\n      const localQueue = this.configSelectionQueue;\n      this.configSelectionQueue = [];\n      this.callRefTimerUnref();\n      for (const call of localQueue) {\n        call.reportResolverError(status);\n      }\n    });\n    this.filterStackFactory = new filter_stack_1.FilterStackFactory([new max_message_size_filter_1.MaxMessageSizeFilterFactory(this.options), new compression_filter_1.CompressionFilterFactory(this, this.options)]);\n    this.trace('Channel constructed with options ' + JSON.stringify(options, undefined, 2));\n    const error = new Error();\n    (0, logging_1.trace)(constants_1.LogVerbosity.DEBUG, 'channel_stacktrace', '(' + this.channelzRef.id + ') ' + 'Channel constructed \\n' + ((_g = error.stack) === null || _g === void 0 ? void 0 : _g.substring(error.stack.indexOf('\\n') + 1)));\n  }\n  getChannelzInfo() {\n    return {\n      target: this.originalTarget,\n      state: this.connectivityState,\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      children: this.childrenTracker.getChildLists()\n    };\n  }\n  trace(text, verbosityOverride) {\n    (0, logging_1.trace)(verbosityOverride !== null && verbosityOverride !== void 0 ? verbosityOverride : constants_1.LogVerbosity.DEBUG, 'channel', '(' + this.channelzRef.id + ') ' + (0, uri_parser_1.uriToString)(this.target) + ' ' + text);\n  }\n  callRefTimerRef() {\n    var _a, _b, _c, _d;\n    // If the hasRef function does not exist, always run the code\n    if (!((_b = (_a = this.callRefTimer).hasRef) === null || _b === void 0 ? void 0 : _b.call(_a))) {\n      this.trace('callRefTimer.ref | configSelectionQueue.length=' + this.configSelectionQueue.length + ' pickQueue.length=' + this.pickQueue.length);\n      (_d = (_c = this.callRefTimer).ref) === null || _d === void 0 ? void 0 : _d.call(_c);\n    }\n  }\n  callRefTimerUnref() {\n    var _a, _b;\n    // If the hasRef function does not exist, always run the code\n    if (!this.callRefTimer.hasRef || this.callRefTimer.hasRef()) {\n      this.trace('callRefTimer.unref | configSelectionQueue.length=' + this.configSelectionQueue.length + ' pickQueue.length=' + this.pickQueue.length);\n      (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n  }\n  removeConnectivityStateWatcher(watcherObject) {\n    const watcherIndex = this.connectivityStateWatchers.findIndex(value => value === watcherObject);\n    if (watcherIndex >= 0) {\n      this.connectivityStateWatchers.splice(watcherIndex, 1);\n    }\n  }\n  updateState(newState) {\n    (0, logging_1.trace)(constants_1.LogVerbosity.DEBUG, 'connectivity_state', '(' + this.channelzRef.id + ') ' + (0, uri_parser_1.uriToString)(this.target) + ' ' + connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n    }\n    this.connectivityState = newState;\n    const watchersCopy = this.connectivityStateWatchers.slice();\n    for (const watcherObject of watchersCopy) {\n      if (newState !== watcherObject.currentState) {\n        if (watcherObject.timer) {\n          clearTimeout(watcherObject.timer);\n        }\n        this.removeConnectivityStateWatcher(watcherObject);\n        watcherObject.callback();\n      }\n    }\n    if (newState !== connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n      this.currentResolutionError = null;\n    }\n  }\n  throttleKeepalive(newKeepaliveTime) {\n    if (newKeepaliveTime > this.keepaliveTime) {\n      this.keepaliveTime = newKeepaliveTime;\n      for (const wrappedSubchannel of this.wrappedSubchannels) {\n        wrappedSubchannel.throttleKeepalive(newKeepaliveTime);\n      }\n    }\n  }\n  removeWrappedSubchannel(wrappedSubchannel) {\n    this.wrappedSubchannels.delete(wrappedSubchannel);\n  }\n  doPick(metadata, extraPickInfo) {\n    return this.currentPicker.pick({\n      metadata: metadata,\n      extraPickInfo: extraPickInfo\n    });\n  }\n  queueCallForPick(call) {\n    this.pickQueue.push(call);\n    this.callRefTimerRef();\n  }\n  getConfig(method, metadata) {\n    this.resolvingLoadBalancer.exitIdle();\n    if (this.configSelector) {\n      return {\n        type: 'SUCCESS',\n        config: this.configSelector(method, metadata)\n      };\n    } else {\n      if (this.currentResolutionError) {\n        return {\n          type: 'ERROR',\n          error: this.currentResolutionError\n        };\n      } else {\n        return {\n          type: 'NONE'\n        };\n      }\n    }\n  }\n  queueCallForConfig(call) {\n    this.configSelectionQueue.push(call);\n    this.callRefTimerRef();\n  }\n  createLoadBalancingCall(callConfig, method, host, credentials, deadline) {\n    const callNumber = (0, call_number_1.getNextCallNumber)();\n    this.trace('createLoadBalancingCall [' + callNumber + '] method=\"' + method + '\"');\n    return new load_balancing_call_1.LoadBalancingCall(this, callConfig, method, host, credentials, deadline, callNumber);\n  }\n  createRetryingCall(callConfig, method, host, credentials, deadline) {\n    const callNumber = (0, call_number_1.getNextCallNumber)();\n    this.trace('createRetryingCall [' + callNumber + '] method=\"' + method + '\"');\n    return new retrying_call_1.RetryingCall(this, callConfig, method, host, credentials, deadline, callNumber, this.retryBufferTracker, RETRY_THROTTLER_MAP.get(this.getTarget()));\n  }\n  createInnerCall(callConfig, method, host, credentials, deadline) {\n    // Create a RetryingCall if retries are enabled\n    if (this.options['grpc.enable_retries'] === 0) {\n      return this.createLoadBalancingCall(callConfig, method, host, credentials, deadline);\n    } else {\n      return this.createRetryingCall(callConfig, method, host, credentials, deadline);\n    }\n  }\n  createResolvingCall(method, deadline, host, parentCall, propagateFlags) {\n    const callNumber = (0, call_number_1.getNextCallNumber)();\n    this.trace('createResolvingCall [' + callNumber + '] method=\"' + method + '\", deadline=' + (0, deadline_1.deadlineToString)(deadline));\n    const finalOptions = {\n      deadline: deadline,\n      flags: propagateFlags !== null && propagateFlags !== void 0 ? propagateFlags : constants_1.Propagate.DEFAULTS,\n      host: host !== null && host !== void 0 ? host : this.defaultAuthority,\n      parentCall: parentCall\n    };\n    const call = new resolving_call_1.ResolvingCall(this, method, finalOptions, this.filterStackFactory.clone(), this.credentials._getCallCredentials(), callNumber);\n    if (this.channelzEnabled) {\n      this.callTracker.addCallStarted();\n      call.addStatusWatcher(status => {\n        if (status.code === constants_1.Status.OK) {\n          this.callTracker.addCallSucceeded();\n        } else {\n          this.callTracker.addCallFailed();\n        }\n      });\n    }\n    return call;\n  }\n  close() {\n    this.resolvingLoadBalancer.destroy();\n    this.updateState(connectivity_state_1.ConnectivityState.SHUTDOWN);\n    clearInterval(this.callRefTimer);\n    if (this.channelzEnabled) {\n      (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n    }\n    this.subchannelPool.unrefUnusedSubchannels();\n  }\n  getTarget() {\n    return (0, uri_parser_1.uriToString)(this.target);\n  }\n  getConnectivityState(tryToConnect) {\n    const connectivityState = this.connectivityState;\n    if (tryToConnect) {\n      this.resolvingLoadBalancer.exitIdle();\n    }\n    return connectivityState;\n  }\n  watchConnectivityState(currentState, deadline, callback) {\n    if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {\n      throw new Error('Channel has been shut down');\n    }\n    let timer = null;\n    if (deadline !== Infinity) {\n      const deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);\n      const now = new Date();\n      if (deadline === -Infinity || deadlineDate <= now) {\n        process.nextTick(callback, new Error('Deadline passed without connectivity state change'));\n        return;\n      }\n      timer = setTimeout(() => {\n        this.removeConnectivityStateWatcher(watcherObject);\n        callback(new Error('Deadline passed without connectivity state change'));\n      }, deadlineDate.getTime() - now.getTime());\n    }\n    const watcherObject = {\n      currentState,\n      callback,\n      timer\n    };\n    this.connectivityStateWatchers.push(watcherObject);\n  }\n  /**\n   * Get the channelz reference object for this channel. The returned value is\n   * garbage if channelz is disabled for this channel.\n   * @returns\n   */\n  getChannelzRef() {\n    return this.channelzRef;\n  }\n  createCall(method, deadline, host, parentCall, propagateFlags) {\n    if (typeof method !== 'string') {\n      throw new TypeError('Channel#createCall: method must be a string');\n    }\n    if (!(typeof deadline === 'number' || deadline instanceof Date)) {\n      throw new TypeError('Channel#createCall: deadline must be a number or Date');\n    }\n    if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {\n      throw new Error('Channel has been shut down');\n    }\n    return this.createResolvingCall(method, deadline, host, parentCall, propagateFlags);\n  }\n}\nexports.InternalChannel = InternalChannel;","map":{"version":3,"mappings":"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","names":["MAX_TIMEOUT_TIME","RETRY_THROTTLER_MAP","Map","DEFAULT_RETRY_BUFFER_SIZE_BYTES","DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES","ChannelSubchannelWrapper","subchannel_interface_1","constructor","childSubchannel","channel","subchannelStateListener","subchannel","previousState","newState","keepaliveTime","throttleKeepalive","addConnectivityStateListener","ref","child","refCount","unref","removeConnectivityStateListener","removeWrappedSubchannel","InternalChannel","target","credentials","options","connectivity_state_1","IDLE","picker_1","Set","channelz_1","TypeError","channel_credentials_1","originalTarget","originalTargetUri","Error","defaultSchemeMapResult","callRefTimer","setInterval","channelzEnabled","channelzTrace","channelzRef","getChannelzInfo","addTrace","defaultAuthority","proxyMapResult","Object","assign","extraOptions","subchannelPool","retryBufferTracker","retrying_call_1","channelControlHelper","createSubchannel","subchannelAddress","subchannelArgs","getOrCreateSubchannel","getChannelzRef","wrappedSubchannel","wrappedSubchannels","add","updateState","connectivityState","picker","currentPicker","queueCopy","pickQueue","slice","callRefTimerUnref","call","doPick","requestReresolution","addChannelzChild","childrenTracker","refChild","removeChannelzChild","unrefChild","resolvingLoadBalancer","resolving_load_balancer_1","serviceConfig","configSelector","retryThrottling","set","getTarget","maxTokens","tokenRatio","get","delete","currentResolutionError","process","nextTick","localQueue","configSelectionQueue","getConfig","status","code","details","length","trace","metadata","reportResolverError","filterStackFactory","filter_stack_1","max_message_size_filter_1","compression_filter_1","JSON","stringify","undefined","error","constants_1","DEBUG","id","stack","substring","indexOf","state","callTracker","children","getChildLists","text","verbosityOverride","callRefTimerRef","hasRef","removeConnectivityStateWatcher","watcherObject","watcherIndex","connectivityStateWatchers","findIndex","value","splice","watchersCopy","currentState","timer","clearTimeout","callback","TRANSIENT_FAILURE","newKeepaliveTime","extraPickInfo","pick","queueCallForPick","push","method","exitIdle","type","config","queueCallForConfig","createLoadBalancingCall","callConfig","host","deadline","callNumber","load_balancing_call_1","createRetryingCall","createInnerCall","createResolvingCall","parentCall","propagateFlags","finalOptions","flags","DEFAULTS","resolving_call_1","clone","_getCallCredentials","addCallStarted","addStatusWatcher","OK","addCallSucceeded","addCallFailed","close","destroy","SHUTDOWN","clearInterval","unrefUnusedSubchannels","getConnectivityState","tryToConnect","watchConnectivityState","Infinity","deadlineDate","Date","now","setTimeout","getTime","createCall","exports"],"sources":["/home/achwak/node_modules/@grpc/grpc-js/src/internal-channel.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { ChannelCredentials } from './channel-credentials';\nimport { ChannelOptions } from './channel-options';\nimport { ResolvingLoadBalancer } from './resolving-load-balancer';\nimport { SubchannelPool, getSubchannelPool } from './subchannel-pool';\nimport { ChannelControlHelper } from './load-balancer';\nimport { UnavailablePicker, Picker, PickResultType } from './picker';\nimport { Metadata } from './metadata';\nimport { Status, LogVerbosity, Propagate } from './constants';\nimport { FilterStackFactory } from './filter-stack';\nimport { CompressionFilterFactory } from './compression-filter';\nimport {\n  CallConfig,\n  ConfigSelector,\n  getDefaultAuthority,\n  mapUriDefaultScheme,\n} from './resolver';\nimport { trace, log } from './logging';\nimport { SubchannelAddress } from './subchannel-address';\nimport { MaxMessageSizeFilterFactory } from './max-message-size-filter';\nimport { mapProxyName } from './http_proxy';\nimport { GrpcUri, parseUri, splitHostPort, uriToString } from './uri-parser';\nimport { ServerSurfaceCall } from './server-call';\nimport { Filter } from './filter';\n\nimport { ConnectivityState } from './connectivity-state';\nimport { ChannelInfo, ChannelRef, ChannelzCallTracker, ChannelzChildrenTracker, ChannelzTrace, registerChannelzChannel, SubchannelRef, unregisterChannelzRef } from './channelz';\nimport { Subchannel } from './subchannel';\nimport { LoadBalancingCall } from './load-balancing-call';\nimport { CallCredentials } from './call-credentials';\nimport { Call, CallStreamOptions, InterceptingListener, MessageContext, StatusObject } from './call-interface';\nimport { SubchannelCall } from './subchannel-call';\nimport { Deadline, deadlineToString, getDeadlineTimeoutString } from './deadline';\nimport { ResolvingCall } from './resolving-call';\nimport { getNextCallNumber } from './call-number';\nimport { restrictControlPlaneStatusCode } from './control-plane-status';\nimport { MessageBufferTracker, RetryingCall, RetryThrottler } from './retrying-call';\nimport { BaseSubchannelWrapper, ConnectivityStateListener, SubchannelInterface } from './subchannel-interface';\n\n/**\n * See https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_args\n */\nconst MAX_TIMEOUT_TIME = 2147483647;\n\ninterface ConnectivityStateWatcher {\n  currentState: ConnectivityState;\n  timer: NodeJS.Timeout | null;\n  callback: (error?: Error) => void;\n}\n\ninterface NoneConfigResult {\n  type: 'NONE';\n}\n\ninterface SuccessConfigResult {\n  type: 'SUCCESS';\n  config: CallConfig;\n}\n\ninterface ErrorConfigResult {\n  type: 'ERROR';\n  error: StatusObject;\n}\n\ntype GetConfigResult = NoneConfigResult | SuccessConfigResult | ErrorConfigResult;\n\nconst RETRY_THROTTLER_MAP: Map<string, RetryThrottler> = new Map();\n\nconst DEFAULT_RETRY_BUFFER_SIZE_BYTES = 1<<24; // 16 MB\nconst DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES = 1<<20; // 1 MB\n\nclass ChannelSubchannelWrapper extends BaseSubchannelWrapper implements SubchannelInterface {\n  private refCount = 0;\n  private subchannelStateListener: ConnectivityStateListener;\n  constructor(childSubchannel: SubchannelInterface, private channel: InternalChannel) {\n    super(childSubchannel);\n    this.subchannelStateListener = (subchannel, previousState, newState, keepaliveTime) => {\n      channel.throttleKeepalive(keepaliveTime);\n    };\n    childSubchannel.addConnectivityStateListener(this.subchannelStateListener);\n  }\n\n  ref(): void {\n    this.child.ref();\n    this.refCount += 1;\n  }\n\n  unref(): void {\n    this.child.unref();\n    this.refCount -= 1;\n    if (this.refCount <= 0) {\n      this.child.removeConnectivityStateListener(this.subchannelStateListener);\n      this.channel.removeWrappedSubchannel(this);\n    }\n  }\n}\n\nexport class InternalChannel {\n  \n  private resolvingLoadBalancer: ResolvingLoadBalancer;\n  private subchannelPool: SubchannelPool;\n  private connectivityState: ConnectivityState = ConnectivityState.IDLE;\n  private currentPicker: Picker = new UnavailablePicker();\n  /**\n   * Calls queued up to get a call config. Should only be populated before the\n   * first time the resolver returns a result, which includes the ConfigSelector.\n   */\n  private configSelectionQueue: ResolvingCall[] = [];\n  private pickQueue: LoadBalancingCall[] = [];\n  private connectivityStateWatchers: ConnectivityStateWatcher[] = [];\n  private defaultAuthority: string;\n  private filterStackFactory: FilterStackFactory;\n  private target: GrpcUri;\n  /**\n   * This timer does not do anything on its own. Its purpose is to hold the\n   * event loop open while there are any pending calls for the channel that\n   * have not yet been assigned to specific subchannels. In other words,\n   * the invariant is that callRefTimer is reffed if and only if pickQueue\n   * is non-empty.\n   */\n  private callRefTimer: NodeJS.Timer;\n  private configSelector: ConfigSelector | null = null;\n  /**\n   * This is the error from the name resolver if it failed most recently. It\n   * is only used to end calls that start while there is no config selector\n   * and the name resolver is in backoff, so it should be nulled if\n   * configSelector becomes set or the channel state becomes anything other\n   * than TRANSIENT_FAILURE.\n   */\n  private currentResolutionError: StatusObject | null = null;\n  private retryBufferTracker: MessageBufferTracker;\n  private keepaliveTime: number;\n  private wrappedSubchannels: Set<ChannelSubchannelWrapper> = new Set();\n\n  // Channelz info\n  private readonly channelzEnabled: boolean = true;\n  private originalTarget: string;\n  private channelzRef: ChannelRef;\n  private channelzTrace: ChannelzTrace;\n  private callTracker = new ChannelzCallTracker();\n  private childrenTracker = new ChannelzChildrenTracker();\n\n  constructor(\n    target: string,\n    private readonly credentials: ChannelCredentials,\n    private readonly options: ChannelOptions\n  ) {\n    if (typeof target !== 'string') {\n      throw new TypeError('Channel target must be a string');\n    }\n    if (!(credentials instanceof ChannelCredentials)) {\n      throw new TypeError(\n        'Channel credentials must be a ChannelCredentials object'\n      );\n    }\n    if (options) {\n      if (typeof options !== 'object') {\n        throw new TypeError('Channel options must be an object');\n      }\n    }\n    this.originalTarget = target;\n    const originalTargetUri = parseUri(target);\n    if (originalTargetUri === null) {\n      throw new Error(`Could not parse target name \"${target}\"`);\n    }\n    /* This ensures that the target has a scheme that is registered with the\n     * resolver */\n    const defaultSchemeMapResult = mapUriDefaultScheme(originalTargetUri);\n    if (defaultSchemeMapResult === null) {\n      throw new Error(\n        `Could not find a default scheme for target name \"${target}\"`\n      );\n    }\n\n    this.callRefTimer = setInterval(() => {}, MAX_TIMEOUT_TIME);\n    this.callRefTimer.unref?.();\n\n    if (this.options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n\n    this.channelzTrace = new ChannelzTrace();\n    this.channelzRef = registerChannelzChannel(target, () => this.getChannelzInfo(), this.channelzEnabled);\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', 'Channel created');\n    }\n\n    if (this.options['grpc.default_authority']) {\n      this.defaultAuthority = this.options['grpc.default_authority'] as string;\n    } else {\n      this.defaultAuthority = getDefaultAuthority(defaultSchemeMapResult);\n    }\n    const proxyMapResult = mapProxyName(defaultSchemeMapResult, options);\n    this.target = proxyMapResult.target;\n    this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);\n\n    /* The global boolean parameter to getSubchannelPool has the inverse meaning to what\n     * the grpc.use_local_subchannel_pool channel option means. */\n    this.subchannelPool = getSubchannelPool(\n      (options['grpc.use_local_subchannel_pool'] ?? 0) === 0\n    );\n    this.retryBufferTracker = new MessageBufferTracker(\n      options['grpc.retry_buffer_size'] ?? DEFAULT_RETRY_BUFFER_SIZE_BYTES,\n      options['grpc.per_rpc_retry_buffer_size'] ?? DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES\n    );\n    this.keepaliveTime = options['grpc.keepalive_time_ms'] ?? -1;\n    const channelControlHelper: ChannelControlHelper = {\n      createSubchannel: (\n        subchannelAddress: SubchannelAddress,\n        subchannelArgs: ChannelOptions\n      ) => {\n        const subchannel = this.subchannelPool.getOrCreateSubchannel(\n          this.target,\n          subchannelAddress,\n          Object.assign({}, this.options, subchannelArgs),\n          this.credentials\n        );\n        subchannel.throttleKeepalive(this.keepaliveTime);\n        if (this.channelzEnabled) {\n          this.channelzTrace.addTrace('CT_INFO', 'Created subchannel or used existing subchannel', subchannel.getChannelzRef());\n        }\n        const wrappedSubchannel = new ChannelSubchannelWrapper(subchannel, this);\n        this.wrappedSubchannels.add(wrappedSubchannel);\n        return wrappedSubchannel;\n      },\n      updateState: (connectivityState: ConnectivityState, picker: Picker) => {\n        this.currentPicker = picker;\n        const queueCopy = this.pickQueue.slice();\n        this.pickQueue = [];\n        this.callRefTimerUnref();\n        for (const call of queueCopy) {\n          call.doPick();\n        }\n        this.updateState(connectivityState);\n      },\n      requestReresolution: () => {\n        // This should never be called.\n        throw new Error(\n          'Resolving load balancer should never call requestReresolution'\n        );\n      },\n      addChannelzChild: (child: ChannelRef | SubchannelRef) => {\n        if (this.channelzEnabled) {\n          this.childrenTracker.refChild(child);\n        }\n      },\n      removeChannelzChild: (child: ChannelRef | SubchannelRef) => {\n        if (this.channelzEnabled) {\n          this.childrenTracker.unrefChild(child);\n        }\n      }\n    };\n    this.resolvingLoadBalancer = new ResolvingLoadBalancer(\n      this.target,\n      channelControlHelper,\n      options,\n      (serviceConfig, configSelector) => {\n        if (serviceConfig.retryThrottling) {\n          RETRY_THROTTLER_MAP.set(this.getTarget(), new RetryThrottler(serviceConfig.retryThrottling.maxTokens, serviceConfig.retryThrottling.tokenRatio, RETRY_THROTTLER_MAP.get(this.getTarget())));\n        } else {\n          RETRY_THROTTLER_MAP.delete(this.getTarget());\n        }\n        if (this.channelzEnabled) {\n          this.channelzTrace.addTrace('CT_INFO', 'Address resolution succeeded');\n        }\n        this.configSelector = configSelector;\n        this.currentResolutionError = null;\n        /* We process the queue asynchronously to ensure that the corresponding\n         * load balancer update has completed. */\n        process.nextTick(() => {\n          const localQueue = this.configSelectionQueue;\n          this.configSelectionQueue = [];\n          this.callRefTimerUnref();\n          for (const call of localQueue) {\n            call.getConfig();\n          }\n          this.configSelectionQueue = [];\n        });\n\n      },\n      (status) => {\n        if (this.channelzEnabled) {\n          this.channelzTrace.addTrace('CT_WARNING', 'Address resolution failed with code ' + status.code + ' and details \"' + status.details + '\"');\n        }\n        if (this.configSelectionQueue.length > 0) {\n          this.trace('Name resolution failed with calls queued for config selection');\n        }\n        if (this.configSelector === null) {\n          this.currentResolutionError = {...restrictControlPlaneStatusCode(status.code, status.details), metadata: status.metadata};\n        }\n        const localQueue = this.configSelectionQueue;\n        this.configSelectionQueue = [];\n        this.callRefTimerUnref();\n        for (const call of localQueue) {\n          call.reportResolverError(status);\n        }\n      }\n    );\n    this.filterStackFactory = new FilterStackFactory([\n      new MaxMessageSizeFilterFactory(this.options),\n      new CompressionFilterFactory(this, this.options),\n    ]);\n    this.trace('Channel constructed with options ' + JSON.stringify(options, undefined, 2));\n    const error = new Error();\n    trace(LogVerbosity.DEBUG, 'channel_stacktrace', '(' + this.channelzRef.id + ') ' + 'Channel constructed \\n' + error.stack?.substring(error.stack.indexOf('\\n')+1));\n  }\n\n  private getChannelzInfo(): ChannelInfo {\n    return {\n      target: this.originalTarget,\n      state: this.connectivityState,\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      children: this.childrenTracker.getChildLists()\n    };\n  }\n\n  private trace(text: string, verbosityOverride?: LogVerbosity) {\n    trace(verbosityOverride ?? LogVerbosity.DEBUG, 'channel', '(' + this.channelzRef.id + ') ' + uriToString(this.target) + ' ' + text);\n  }\n\n  private callRefTimerRef() {\n    // If the hasRef function does not exist, always run the code\n    if (!this.callRefTimer.hasRef?.()) {\n      this.trace(\n        'callRefTimer.ref | configSelectionQueue.length=' +\n          this.configSelectionQueue.length +\n          ' pickQueue.length=' +\n          this.pickQueue.length\n      );\n      this.callRefTimer.ref?.();\n    }\n  }\n\n  private callRefTimerUnref() {\n    // If the hasRef function does not exist, always run the code\n    if (!this.callRefTimer.hasRef || this.callRefTimer.hasRef()) {\n      this.trace(\n        'callRefTimer.unref | configSelectionQueue.length=' +\n          this.configSelectionQueue.length +\n          ' pickQueue.length=' +\n          this.pickQueue.length\n      );\n      this.callRefTimer.unref?.();\n    }\n  }\n\n  private removeConnectivityStateWatcher(\n    watcherObject: ConnectivityStateWatcher\n  ) {\n    const watcherIndex = this.connectivityStateWatchers.findIndex(\n      (value) => value === watcherObject\n    );\n    if (watcherIndex >= 0) {\n      this.connectivityStateWatchers.splice(watcherIndex, 1);\n    }\n  }\n\n  private updateState(newState: ConnectivityState): void {\n    trace(\n      LogVerbosity.DEBUG,\n      'connectivity_state',\n      '(' + this.channelzRef.id + ') ' + \n        uriToString(this.target) +\n        ' ' +\n        ConnectivityState[this.connectivityState] +\n        ' -> ' +\n        ConnectivityState[newState]\n    );\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', ConnectivityState[this.connectivityState] + ' -> ' + ConnectivityState[newState]);\n    }\n    this.connectivityState = newState;\n    const watchersCopy = this.connectivityStateWatchers.slice();\n    for (const watcherObject of watchersCopy) {\n      if (newState !== watcherObject.currentState) {\n        if (watcherObject.timer) {\n          clearTimeout(watcherObject.timer);\n        }\n        this.removeConnectivityStateWatcher(watcherObject);\n        watcherObject.callback();\n      }\n    }\n    if (newState !== ConnectivityState.TRANSIENT_FAILURE) {\n      this.currentResolutionError = null;\n    }\n  }\n\n  throttleKeepalive(newKeepaliveTime: number) {\n    if (newKeepaliveTime > this.keepaliveTime) {\n      this.keepaliveTime = newKeepaliveTime;\n      for (const wrappedSubchannel of this.wrappedSubchannels) {\n        wrappedSubchannel.throttleKeepalive(newKeepaliveTime);\n      }\n    }\n  }\n\n  removeWrappedSubchannel(wrappedSubchannel: ChannelSubchannelWrapper) {\n    this.wrappedSubchannels.delete(wrappedSubchannel);\n  }\n\n  doPick(metadata: Metadata, extraPickInfo: {[key: string]: string}) {\n    return this.currentPicker.pick({metadata: metadata, extraPickInfo: extraPickInfo});\n  }\n\n  queueCallForPick(call: LoadBalancingCall) {\n    this.pickQueue.push(call);\n    this.callRefTimerRef();\n  }\n\n  getConfig(method: string, metadata: Metadata): GetConfigResult {\n    this.resolvingLoadBalancer.exitIdle();\n    if (this.configSelector) {\n      return {\n        type: 'SUCCESS',\n        config: this.configSelector(method, metadata)\n      };\n    } else {\n      if (this.currentResolutionError) {\n        return {\n          type: 'ERROR',\n          error: this.currentResolutionError\n        }\n      } else {\n        return {\n          type: 'NONE'\n        }\n      }\n    }\n  }\n\n  queueCallForConfig(call: ResolvingCall) {\n    this.configSelectionQueue.push(call);\n    this.callRefTimerRef();\n  }\n\n  createLoadBalancingCall(\n    callConfig: CallConfig,\n    method: string,\n    host: string,\n    credentials: CallCredentials,\n    deadline: Deadline\n  ): LoadBalancingCall {\n    const callNumber = getNextCallNumber();\n    this.trace(\n      'createLoadBalancingCall [' +\n        callNumber +\n        '] method=\"' +\n        method +\n        '\"'\n    );\n    return new LoadBalancingCall(this, callConfig, method, host, credentials, deadline, callNumber);\n  }\n\n  createRetryingCall(\n    callConfig: CallConfig,\n    method: string,\n    host: string,\n    credentials: CallCredentials,\n    deadline: Deadline\n  ): RetryingCall {\n    const callNumber = getNextCallNumber();\n    this.trace(\n      'createRetryingCall [' +\n        callNumber +\n        '] method=\"' +\n        method +\n        '\"'\n    );\n    return new RetryingCall(this, callConfig, method, host, credentials, deadline, callNumber, this.retryBufferTracker, RETRY_THROTTLER_MAP.get(this.getTarget()))\n  }\n\n  createInnerCall(\n    callConfig: CallConfig,\n    method: string,\n    host: string,\n    credentials: CallCredentials,\n    deadline: Deadline\n  ): Call {\n    // Create a RetryingCall if retries are enabled\n    if (this.options['grpc.enable_retries'] === 0) {\n      return this.createLoadBalancingCall(callConfig, method, host, credentials, deadline);\n    } else {\n      return this.createRetryingCall(callConfig, method, host, credentials, deadline);\n    }\n  }\n\n  createResolvingCall(\n    method: string,\n    deadline: Deadline,\n    host: string | null | undefined,\n    parentCall: ServerSurfaceCall | null,\n    propagateFlags: number | null | undefined\n  ): ResolvingCall {\n    const callNumber = getNextCallNumber();\n    this.trace(\n      'createResolvingCall [' +\n        callNumber +\n        '] method=\"' +\n        method +\n        '\", deadline=' +\n        deadlineToString(deadline)\n    );\n    const finalOptions: CallStreamOptions = {\n      deadline: deadline,\n      flags: propagateFlags ?? Propagate.DEFAULTS,\n      host: host ?? this.defaultAuthority,\n      parentCall: parentCall,\n    };\n\n    const call = new ResolvingCall(this, method, finalOptions, this.filterStackFactory.clone(), this.credentials._getCallCredentials(), callNumber);\n\n    if (this.channelzEnabled) {\n      this.callTracker.addCallStarted();\n      call.addStatusWatcher(status => {\n        if (status.code === Status.OK) {\n          this.callTracker.addCallSucceeded();\n        } else {\n          this.callTracker.addCallFailed();\n        }\n      });\n    }\n    return call;\n\n  }\n\n  close() {\n    this.resolvingLoadBalancer.destroy();\n    this.updateState(ConnectivityState.SHUTDOWN);\n    clearInterval(this.callRefTimer);\n    if (this.channelzEnabled) {\n      unregisterChannelzRef(this.channelzRef);\n    }\n\n    this.subchannelPool.unrefUnusedSubchannels();\n  }\n\n  getTarget() {\n    return uriToString(this.target);\n  }\n\n  getConnectivityState(tryToConnect: boolean) {\n    const connectivityState = this.connectivityState;\n    if (tryToConnect) {\n      this.resolvingLoadBalancer.exitIdle();\n    }\n    return connectivityState;\n  }\n\n  watchConnectivityState(\n    currentState: ConnectivityState,\n    deadline: Date | number,\n    callback: (error?: Error) => void\n  ): void {\n    if (this.connectivityState === ConnectivityState.SHUTDOWN) {\n      throw new Error('Channel has been shut down');\n    }\n    let timer = null;\n    if (deadline !== Infinity) {\n      const deadlineDate: Date =\n        deadline instanceof Date ? deadline : new Date(deadline);\n      const now = new Date();\n      if (deadline === -Infinity || deadlineDate <= now) {\n        process.nextTick(\n          callback,\n          new Error('Deadline passed without connectivity state change')\n        );\n        return;\n      }\n      timer = setTimeout(() => {\n        this.removeConnectivityStateWatcher(watcherObject);\n        callback(\n          new Error('Deadline passed without connectivity state change')\n        );\n      }, deadlineDate.getTime() - now.getTime());\n    }\n    const watcherObject = {\n      currentState,\n      callback,\n      timer,\n    };\n    this.connectivityStateWatchers.push(watcherObject);\n  }\n\n  /**\n   * Get the channelz reference object for this channel. The returned value is\n   * garbage if channelz is disabled for this channel.\n   * @returns \n   */\n  getChannelzRef() {\n    return this.channelzRef;\n  }\n\n  createCall(\n    method: string,\n    deadline: Deadline,\n    host: string | null | undefined,\n    parentCall: ServerSurfaceCall | null,\n    propagateFlags: number | null | undefined\n  ): Call {\n    if (typeof method !== 'string') {\n      throw new TypeError('Channel#createCall: method must be a string');\n    }\n    if (!(typeof deadline === 'number' || deadline instanceof Date)) {\n      throw new TypeError(\n        'Channel#createCall: deadline must be a number or Date'\n      );\n    }\n    if (this.connectivityState === ConnectivityState.SHUTDOWN) {\n      throw new Error('Channel has been shut down');\n    }\n    return this.createResolvingCall(method, deadline, host, parentCall, propagateFlags);\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}