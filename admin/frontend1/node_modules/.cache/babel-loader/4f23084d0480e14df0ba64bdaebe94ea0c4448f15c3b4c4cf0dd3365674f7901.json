{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ResolvingCall = void 0;\nconst constants_1 = require(\"./constants\");\nconst deadline_1 = require(\"./deadline\");\nconst metadata_1 = require(\"./metadata\");\nconst logging = require(\"./logging\");\nconst control_plane_status_1 = require(\"./control-plane-status\");\nconst TRACER_NAME = 'resolving_call';\nclass ResolvingCall {\n  constructor(channel, method, options, filterStackFactory, credentials, callNumber) {\n    this.channel = channel;\n    this.method = method;\n    this.filterStackFactory = filterStackFactory;\n    this.credentials = credentials;\n    this.callNumber = callNumber;\n    this.child = null;\n    this.readPending = false;\n    this.pendingMessage = null;\n    this.pendingHalfClose = false;\n    this.ended = false;\n    this.readFilterPending = false;\n    this.writeFilterPending = false;\n    this.pendingChildStatus = null;\n    this.metadata = null;\n    this.listener = null;\n    this.statusWatchers = [];\n    this.deadlineTimer = setTimeout(() => {}, 0);\n    this.filterStack = null;\n    this.deadline = options.deadline;\n    this.host = options.host;\n    if (options.parentCall) {\n      if (options.flags & constants_1.Propagate.CANCELLATION) {\n        options.parentCall.on('cancelled', () => {\n          this.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled by parent call');\n        });\n      }\n      if (options.flags & constants_1.Propagate.DEADLINE) {\n        this.trace('Propagating deadline from parent: ' + options.parentCall.getDeadline());\n        this.deadline = (0, deadline_1.minDeadline)(this.deadline, options.parentCall.getDeadline());\n      }\n    }\n    this.trace('Created');\n    this.runDeadlineTimer();\n  }\n  trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);\n  }\n  runDeadlineTimer() {\n    clearTimeout(this.deadlineTimer);\n    this.trace('Deadline: ' + (0, deadline_1.deadlineToString)(this.deadline));\n    const timeout = (0, deadline_1.getRelativeTimeout)(this.deadline);\n    if (timeout !== Infinity) {\n      this.trace('Deadline will be reached in ' + timeout + 'ms');\n      const handleDeadline = () => {\n        this.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, 'Deadline exceeded');\n      };\n      if (timeout <= 0) {\n        process.nextTick(handleDeadline);\n      } else {\n        this.deadlineTimer = setTimeout(handleDeadline, timeout);\n      }\n    }\n  }\n  outputStatus(status) {\n    if (!this.ended) {\n      this.ended = true;\n      if (!this.filterStack) {\n        this.filterStack = this.filterStackFactory.createFilter();\n      }\n      clearTimeout(this.deadlineTimer);\n      const filteredStatus = this.filterStack.receiveTrailers(status);\n      this.trace('ended with status: code=' + filteredStatus.code + ' details=\"' + filteredStatus.details + '\"');\n      this.statusWatchers.forEach(watcher => watcher(filteredStatus));\n      process.nextTick(() => {\n        var _a;\n        (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(filteredStatus);\n      });\n    }\n  }\n  sendMessageOnChild(context, message) {\n    if (!this.child) {\n      throw new Error('sendMessageonChild called with child not populated');\n    }\n    const child = this.child;\n    this.writeFilterPending = true;\n    this.filterStack.sendMessage(Promise.resolve({\n      message: message,\n      flags: context.flags\n    })).then(filteredMessage => {\n      this.writeFilterPending = false;\n      child.sendMessageWithContext(context, filteredMessage.message);\n      if (this.pendingHalfClose) {\n        child.halfClose();\n      }\n    }, status => {\n      this.cancelWithStatus(status.code, status.details);\n    });\n  }\n  getConfig() {\n    if (this.ended) {\n      return;\n    }\n    if (!this.metadata || !this.listener) {\n      throw new Error('getConfig called before start');\n    }\n    const configResult = this.channel.getConfig(this.method, this.metadata);\n    if (configResult.type === 'NONE') {\n      this.channel.queueCallForConfig(this);\n      return;\n    } else if (configResult.type === 'ERROR') {\n      if (this.metadata.getOptions().waitForReady) {\n        this.channel.queueCallForConfig(this);\n      } else {\n        this.outputStatus(configResult.error);\n      }\n      return;\n    }\n    // configResult.type === 'SUCCESS'\n    const config = configResult.config;\n    if (config.status !== constants_1.Status.OK) {\n      const {\n        code,\n        details\n      } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(config.status, 'Failed to route call to method ' + this.method);\n      this.outputStatus({\n        code: code,\n        details: details,\n        metadata: new metadata_1.Metadata()\n      });\n      return;\n    }\n    if (config.methodConfig.timeout) {\n      const configDeadline = new Date();\n      configDeadline.setSeconds(configDeadline.getSeconds() + config.methodConfig.timeout.seconds);\n      configDeadline.setMilliseconds(configDeadline.getMilliseconds() + config.methodConfig.timeout.nanos / 1000000);\n      this.deadline = (0, deadline_1.minDeadline)(this.deadline, configDeadline);\n      this.runDeadlineTimer();\n    }\n    this.filterStackFactory.push(config.dynamicFilterFactories);\n    this.filterStack = this.filterStackFactory.createFilter();\n    this.filterStack.sendMetadata(Promise.resolve(this.metadata)).then(filteredMetadata => {\n      this.child = this.channel.createInnerCall(config, this.method, this.host, this.credentials, this.deadline);\n      this.trace('Created child [' + this.child.getCallNumber() + ']');\n      this.child.start(filteredMetadata, {\n        onReceiveMetadata: metadata => {\n          this.trace('Received metadata');\n          this.listener.onReceiveMetadata(this.filterStack.receiveMetadata(metadata));\n        },\n        onReceiveMessage: message => {\n          this.trace('Received message');\n          this.readFilterPending = true;\n          this.filterStack.receiveMessage(message).then(filteredMesssage => {\n            this.trace('Finished filtering received message');\n            this.readFilterPending = false;\n            this.listener.onReceiveMessage(filteredMesssage);\n            if (this.pendingChildStatus) {\n              this.outputStatus(this.pendingChildStatus);\n            }\n          }, status => {\n            this.cancelWithStatus(status.code, status.details);\n          });\n        },\n        onReceiveStatus: status => {\n          this.trace('Received status');\n          if (this.readFilterPending) {\n            this.pendingChildStatus = status;\n          } else {\n            this.outputStatus(status);\n          }\n        }\n      });\n      if (this.readPending) {\n        this.child.startRead();\n      }\n      if (this.pendingMessage) {\n        this.sendMessageOnChild(this.pendingMessage.context, this.pendingMessage.message);\n      } else if (this.pendingHalfClose) {\n        this.child.halfClose();\n      }\n    }, status => {\n      this.outputStatus(status);\n    });\n  }\n  reportResolverError(status) {\n    var _a;\n    if ((_a = this.metadata) === null || _a === void 0 ? void 0 : _a.getOptions().waitForReady) {\n      this.channel.queueCallForConfig(this);\n    } else {\n      this.outputStatus(status);\n    }\n  }\n  cancelWithStatus(status, details) {\n    var _a;\n    this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\n    (_a = this.child) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(status, details);\n    this.outputStatus({\n      code: status,\n      details: details,\n      metadata: new metadata_1.Metadata()\n    });\n  }\n  getPeer() {\n    var _a, _b;\n    return (_b = (_a = this.child) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : this.channel.getTarget();\n  }\n  start(metadata, listener) {\n    this.trace('start called');\n    this.metadata = metadata.clone();\n    this.listener = listener;\n    this.getConfig();\n  }\n  sendMessageWithContext(context, message) {\n    this.trace('write() called with message of length ' + message.length);\n    if (this.child) {\n      this.sendMessageOnChild(context, message);\n    } else {\n      this.pendingMessage = {\n        context,\n        message\n      };\n    }\n  }\n  startRead() {\n    this.trace('startRead called');\n    if (this.child) {\n      this.child.startRead();\n    } else {\n      this.readPending = true;\n    }\n  }\n  halfClose() {\n    this.trace('halfClose called');\n    if (this.child && !this.writeFilterPending) {\n      this.child.halfClose();\n    } else {\n      this.pendingHalfClose = true;\n    }\n  }\n  setCredentials(credentials) {\n    this.credentials = this.credentials.compose(credentials);\n  }\n  addStatusWatcher(watcher) {\n    this.statusWatchers.push(watcher);\n  }\n  getCallNumber() {\n    return this.callNumber;\n  }\n}\nexports.ResolvingCall = ResolvingCall;","map":{"version":3,"mappings":";;AAAA;;;;;;;;;;;;;;;;;;;;AAmBA;AACA;AAGA;AACA;AACA;AAEA,MAAMA,WAAW,GAAG,gBAAgB;AAEpC,MAAaC,aAAa;EAiBxBC,YACmBC,OAAwB,EACxBC,MAAc,EAC/BC,OAA0B,EACTC,kBAAsC,EAC/CC,WAA4B,EAC5BC,UAAkB;IALT,YAAO,GAAPL,OAAO;IACP,WAAM,GAANC,MAAM;IAEN,uBAAkB,GAAlBE,kBAAkB;IAC3B,gBAAW,GAAXC,WAAW;IACX,eAAU,GAAVC,UAAU;IAtBZ,UAAK,GAAgB,IAAI;IACzB,gBAAW,GAAG,KAAK;IACnB,mBAAc,GAAsD,IAAI;IACxE,qBAAgB,GAAG,KAAK;IACxB,UAAK,GAAG,KAAK;IACb,sBAAiB,GAAG,KAAK;IACzB,uBAAkB,GAAG,KAAK;IAC1B,uBAAkB,GAAwB,IAAI;IAC9C,aAAQ,GAAoB,IAAI;IAChC,aAAQ,GAAgC,IAAI;IAG5C,mBAAc,GAAuC,EAAE;IACvD,kBAAa,GAAiBC,UAAU,CAAC,MAAK,CAAE,CAAC,EAAE,CAAC,CAAC;IACrD,gBAAW,GAAuB,IAAI;IAU5C,IAAI,CAACC,QAAQ,GAAGL,OAAO,CAACK,QAAQ;IAChC,IAAI,CAACC,IAAI,GAAGN,OAAO,CAACM,IAAI;IACxB,IAAIN,OAAO,CAACO,UAAU,EAAE;MACtB,IAAIP,OAAO,CAACQ,KAAK,GAAGC,qBAAS,CAACC,YAAY,EAAE;QAC1CV,OAAO,CAACO,UAAU,CAACI,EAAE,CAAC,WAAW,EAAE,MAAK;UACtC,IAAI,CAACC,gBAAgB,CAACH,kBAAM,CAACI,SAAS,EAAE,0BAA0B,CAAC;QACrE,CAAC,CAAC;;MAEJ,IAAIb,OAAO,CAACQ,KAAK,GAAGC,qBAAS,CAACK,QAAQ,EAAE;QACtC,IAAI,CAACC,KAAK,CAAC,oCAAoC,GAAGf,OAAO,CAACO,UAAU,CAACS,WAAW,EAAE,CAAC;QACnF,IAAI,CAACX,QAAQ,GAAG,0BAAW,EAAC,IAAI,CAACA,QAAQ,EAAEL,OAAO,CAACO,UAAU,CAACS,WAAW,EAAE,CAAC;;;IAGhF,IAAI,CAACD,KAAK,CAAC,SAAS,CAAC;IACrB,IAAI,CAACE,gBAAgB,EAAE;EACzB;EAEQF,KAAK,CAACG,IAAY;IACxBC,OAAO,CAACJ,KAAK,CACXN,wBAAY,CAACW,KAAK,EAClBzB,WAAW,EACX,GAAG,GAAG,IAAI,CAACQ,UAAU,GAAG,IAAI,GAAGe,IAAI,CACpC;EACH;EAEQD,gBAAgB;IACtBI,YAAY,CAAC,IAAI,CAACC,aAAa,CAAC;IAChC,IAAI,CAACP,KAAK,CAAC,YAAY,GAAG,+BAAgB,EAAC,IAAI,CAACV,QAAQ,CAAC,CAAC;IAC1D,MAAMkB,OAAO,GAAG,iCAAkB,EAAC,IAAI,CAAClB,QAAQ,CAAC;IACjD,IAAIkB,OAAO,KAAKC,QAAQ,EAAE;MACxB,IAAI,CAACT,KAAK,CAAC,8BAA8B,GAAGQ,OAAO,GAAG,IAAI,CAAC;MAC3D,MAAME,cAAc,GAAG,MAAK;QAC1B,IAAI,CAACb,gBAAgB,CACnBH,kBAAM,CAACiB,iBAAiB,EACxB,mBAAmB,CACpB;MACH,CAAC;MACD,IAAIH,OAAO,IAAI,CAAC,EAAE;QAChBI,OAAO,CAACC,QAAQ,CAACH,cAAc,CAAC;OACjC,MAAM;QACL,IAAI,CAACH,aAAa,GAAGlB,UAAU,CAACqB,cAAc,EAAEF,OAAO,CAAC;;;EAG9D;EAEQM,YAAY,CAACC,MAAoB;IACvC,IAAI,CAAC,IAAI,CAACC,KAAK,EAAE;MACf,IAAI,CAACA,KAAK,GAAG,IAAI;MACjB,IAAI,CAAC,IAAI,CAACC,WAAW,EAAE;QACrB,IAAI,CAACA,WAAW,GAAG,IAAI,CAAC/B,kBAAkB,CAACgC,YAAY,EAAE;;MAE3DZ,YAAY,CAAC,IAAI,CAACC,aAAa,CAAC;MAChC,MAAMY,cAAc,GAAG,IAAI,CAACF,WAAW,CAACG,eAAe,CAACL,MAAM,CAAC;MAC/D,IAAI,CAACf,KAAK,CAAC,0BAA0B,GAAGmB,cAAc,CAACE,IAAI,GAAG,YAAY,GAAGF,cAAc,CAACG,OAAO,GAAG,GAAG,CAAC;MAC1G,IAAI,CAACC,cAAc,CAACC,OAAO,CAACC,OAAO,IAAIA,OAAO,CAACN,cAAc,CAAC,CAAC;MAC/DP,OAAO,CAACC,QAAQ,CAAC,MAAK;;QACpB,UAAI,CAACa,QAAQ,0CAAEC,eAAe,CAACR,cAAc,CAAC;MAChD,CAAC,CAAC;;EAEN;EAEQS,kBAAkB,CAACC,OAAuB,EAAEC,OAAe;IACjE,IAAI,CAAC,IAAI,CAACC,KAAK,EAAE;MACf,MAAM,IAAIC,KAAK,CAAC,oDAAoD,CAAC;;IAEvE,MAAMD,KAAK,GAAG,IAAI,CAACA,KAAK;IACxB,IAAI,CAACE,kBAAkB,GAAG,IAAI;IAC9B,IAAI,CAAChB,WAAY,CAACiB,WAAW,CAACC,OAAO,CAACC,OAAO,CAAC;MAACN,OAAO,EAAEA,OAAO;MAAErC,KAAK,EAAEoC,OAAO,CAACpC;IAAK,CAAC,CAAC,CAAC,CAAC4C,IAAI,CAAEC,eAAe,IAAI;MAChH,IAAI,CAACL,kBAAkB,GAAG,KAAK;MAC/BF,KAAK,CAACQ,sBAAsB,CAACV,OAAO,EAAES,eAAe,CAACR,OAAO,CAAC;MAC9D,IAAI,IAAI,CAACU,gBAAgB,EAAE;QACzBT,KAAK,CAACU,SAAS,EAAE;;IAErB,CAAC,EAAG1B,MAAoB,IAAI;MAC1B,IAAI,CAAClB,gBAAgB,CAACkB,MAAM,CAACM,IAAI,EAAEN,MAAM,CAACO,OAAO,CAAC;IACpD,CAAC,CAAC;EACJ;EAEAoB,SAAS;IACP,IAAI,IAAI,CAAC1B,KAAK,EAAE;MACd;;IAEF,IAAI,CAAC,IAAI,CAAC2B,QAAQ,IAAI,CAAC,IAAI,CAACjB,QAAQ,EAAE;MACpC,MAAM,IAAIM,KAAK,CAAC,+BAA+B,CAAC;;IAElD,MAAMY,YAAY,GAAG,IAAI,CAAC7D,OAAO,CAAC2D,SAAS,CAAC,IAAI,CAAC1D,MAAM,EAAE,IAAI,CAAC2D,QAAQ,CAAC;IACvE,IAAIC,YAAY,CAACC,IAAI,KAAK,MAAM,EAAE;MAChC,IAAI,CAAC9D,OAAO,CAAC+D,kBAAkB,CAAC,IAAI,CAAC;MACrC;KACD,MAAM,IAAIF,YAAY,CAACC,IAAI,KAAK,OAAO,EAAE;MACxC,IAAI,IAAI,CAACF,QAAQ,CAACI,UAAU,EAAE,CAACC,YAAY,EAAE;QAC3C,IAAI,CAACjE,OAAO,CAAC+D,kBAAkB,CAAC,IAAI,CAAC;OACtC,MAAM;QACL,IAAI,CAAChC,YAAY,CAAC8B,YAAY,CAACK,KAAK,CAAC;;MAEvC;;IAEF;IACA,MAAMC,MAAM,GAAGN,YAAY,CAACM,MAAM;IAClC,IAAIA,MAAM,CAACnC,MAAM,KAAKrB,kBAAM,CAACyD,EAAE,EAAE;MAC/B,MAAM;QAAC9B,IAAI;QAAEC;MAAO,CAAC,GAAG,yDAA8B,EAAC4B,MAAM,CAACnC,MAAM,EAAE,iCAAiC,GAAG,IAAI,CAAC/B,MAAM,CAAC;MACtH,IAAI,CAAC8B,YAAY,CAAC;QAChBO,IAAI,EAAEA,IAAI;QACVC,OAAO,EAAEA,OAAO;QAChBqB,QAAQ,EAAE,IAAIS,mBAAQ;OACvB,CAAC;MACF;;IAGF,IAAIF,MAAM,CAACG,YAAY,CAAC7C,OAAO,EAAE;MAC/B,MAAM8C,cAAc,GAAG,IAAIC,IAAI,EAAE;MACjCD,cAAc,CAACE,UAAU,CACvBF,cAAc,CAACG,UAAU,EAAE,GAAGP,MAAM,CAACG,YAAY,CAAC7C,OAAO,CAACkD,OAAO,CAClE;MACDJ,cAAc,CAACK,eAAe,CAC5BL,cAAc,CAACM,eAAe,EAAE,GAC9BV,MAAM,CAACG,YAAY,CAAC7C,OAAO,CAACqD,KAAK,GAAG,OAAS,CAChD;MACD,IAAI,CAACvE,QAAQ,GAAG,0BAAW,EAAC,IAAI,CAACA,QAAQ,EAAEgE,cAAc,CAAC;MAC1D,IAAI,CAACpD,gBAAgB,EAAE;;IAGzB,IAAI,CAAChB,kBAAkB,CAAC4E,IAAI,CAACZ,MAAM,CAACa,sBAAsB,CAAC;IAC3D,IAAI,CAAC9C,WAAW,GAAG,IAAI,CAAC/B,kBAAkB,CAACgC,YAAY,EAAE;IACzD,IAAI,CAACD,WAAW,CAAC+C,YAAY,CAAC7B,OAAO,CAACC,OAAO,CAAC,IAAI,CAACO,QAAQ,CAAC,CAAC,CAACN,IAAI,CAAC4B,gBAAgB,IAAG;MACpF,IAAI,CAAClC,KAAK,GAAG,IAAI,CAAChD,OAAO,CAACmF,eAAe,CAAChB,MAAM,EAAE,IAAI,CAAClE,MAAM,EAAE,IAAI,CAACO,IAAI,EAAE,IAAI,CAACJ,WAAW,EAAE,IAAI,CAACG,QAAQ,CAAC;MAC1G,IAAI,CAACU,KAAK,CAAC,iBAAiB,GAAG,IAAI,CAAC+B,KAAK,CAACoC,aAAa,EAAE,GAAG,GAAG,CAAC;MAChE,IAAI,CAACpC,KAAK,CAACqC,KAAK,CAACH,gBAAgB,EAAE;QACjCI,iBAAiB,EAAE1B,QAAQ,IAAG;UAC5B,IAAI,CAAC3C,KAAK,CAAC,mBAAmB,CAAC;UAC/B,IAAI,CAAC0B,QAAS,CAAC2C,iBAAiB,CAAC,IAAI,CAACpD,WAAY,CAACqD,eAAe,CAAC3B,QAAQ,CAAC,CAAC;QAC/E,CAAC;QACD4B,gBAAgB,EAAEzC,OAAO,IAAG;UAC1B,IAAI,CAAC9B,KAAK,CAAC,kBAAkB,CAAC;UAC9B,IAAI,CAACwE,iBAAiB,GAAG,IAAI;UAC7B,IAAI,CAACvD,WAAY,CAACwD,cAAc,CAAC3C,OAAO,CAAC,CAACO,IAAI,CAACqC,gBAAgB,IAAG;YAChE,IAAI,CAAC1E,KAAK,CAAC,qCAAqC,CAAC;YACjD,IAAI,CAACwE,iBAAiB,GAAG,KAAK;YAC9B,IAAI,CAAC9C,QAAS,CAAC6C,gBAAgB,CAACG,gBAAgB,CAAC;YACjD,IAAI,IAAI,CAACC,kBAAkB,EAAE;cAC3B,IAAI,CAAC7D,YAAY,CAAC,IAAI,CAAC6D,kBAAkB,CAAC;;UAE9C,CAAC,EAAG5D,MAAoB,IAAI;YAC1B,IAAI,CAAClB,gBAAgB,CAACkB,MAAM,CAACM,IAAI,EAAEN,MAAM,CAACO,OAAO,CAAC;UACpD,CAAC,CAAC;QACJ,CAAC;QACDK,eAAe,EAAEZ,MAAM,IAAG;UACxB,IAAI,CAACf,KAAK,CAAC,iBAAiB,CAAC;UAC7B,IAAI,IAAI,CAACwE,iBAAiB,EAAE;YAC1B,IAAI,CAACG,kBAAkB,GAAG5D,MAAM;WACjC,MAAM;YACL,IAAI,CAACD,YAAY,CAACC,MAAM,CAAC;;QAE7B;OACD,CAAC;MACF,IAAI,IAAI,CAAC6D,WAAW,EAAE;QACpB,IAAI,CAAC7C,KAAK,CAAC8C,SAAS,EAAE;;MAExB,IAAI,IAAI,CAACC,cAAc,EAAE;QACvB,IAAI,CAAClD,kBAAkB,CAAC,IAAI,CAACkD,cAAc,CAACjD,OAAO,EAAE,IAAI,CAACiD,cAAc,CAAChD,OAAO,CAAC;OAClF,MAAM,IAAI,IAAI,CAACU,gBAAgB,EAAE;QAChC,IAAI,CAACT,KAAK,CAACU,SAAS,EAAE;;IAE1B,CAAC,EAAG1B,MAAoB,IAAI;MAC1B,IAAI,CAACD,YAAY,CAACC,MAAM,CAAC;IAC3B,CAAC,CAAC;EACJ;EAEAgE,mBAAmB,CAAChE,MAAoB;;IACtC,IAAI,UAAI,CAAC4B,QAAQ,0CAAEI,UAAU,GAAGC,YAAY,EAAE;MAC5C,IAAI,CAACjE,OAAO,CAAC+D,kBAAkB,CAAC,IAAI,CAAC;KACtC,MAAM;MACL,IAAI,CAAChC,YAAY,CAACC,MAAM,CAAC;;EAE7B;EACAlB,gBAAgB,CAACkB,MAAc,EAAEO,OAAe;;IAC9C,IAAI,CAACtB,KAAK,CAAC,yBAAyB,GAAGe,MAAM,GAAG,aAAa,GAAGO,OAAO,GAAG,GAAG,CAAC;IAC9E,UAAI,CAACS,KAAK,0CAAElC,gBAAgB,CAACkB,MAAM,EAAEO,OAAO,CAAC;IAC7C,IAAI,CAACR,YAAY,CAAC;MAACO,IAAI,EAAEN,MAAM;MAAEO,OAAO,EAAEA,OAAO;MAAEqB,QAAQ,EAAE,IAAIS,mBAAQ;IAAE,CAAC,CAAC;EAC/E;EACA4B,OAAO;;IACL,OAAO,gBAAI,CAACjD,KAAK,0CAAEiD,OAAO,EAAE,mCAAI,IAAI,CAACjG,OAAO,CAACkG,SAAS,EAAE;EAC1D;EACAb,KAAK,CAACzB,QAAkB,EAAEjB,QAA8B;IACtD,IAAI,CAAC1B,KAAK,CAAC,cAAc,CAAC;IAC1B,IAAI,CAAC2C,QAAQ,GAAGA,QAAQ,CAACuC,KAAK,EAAE;IAChC,IAAI,CAACxD,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACgB,SAAS,EAAE;EAClB;EACAH,sBAAsB,CAACV,OAAuB,EAAEC,OAAe;IAC7D,IAAI,CAAC9B,KAAK,CAAC,wCAAwC,GAAG8B,OAAO,CAACqD,MAAM,CAAC;IACrE,IAAI,IAAI,CAACpD,KAAK,EAAE;MACd,IAAI,CAACH,kBAAkB,CAACC,OAAO,EAAEC,OAAO,CAAC;KAC1C,MAAM;MACL,IAAI,CAACgD,cAAc,GAAG;QAACjD,OAAO;QAAEC;MAAO,CAAC;;EAE5C;EACA+C,SAAS;IACP,IAAI,CAAC7E,KAAK,CAAC,kBAAkB,CAAC;IAC9B,IAAI,IAAI,CAAC+B,KAAK,EAAE;MACd,IAAI,CAACA,KAAK,CAAC8C,SAAS,EAAE;KACvB,MAAM;MACL,IAAI,CAACD,WAAW,GAAG,IAAI;;EAE3B;EACAnC,SAAS;IACP,IAAI,CAACzC,KAAK,CAAC,kBAAkB,CAAC;IAC9B,IAAI,IAAI,CAAC+B,KAAK,IAAI,CAAC,IAAI,CAACE,kBAAkB,EAAE;MAC1C,IAAI,CAACF,KAAK,CAACU,SAAS,EAAE;KACvB,MAAM;MACL,IAAI,CAACD,gBAAgB,GAAG,IAAI;;EAEhC;EACA4C,cAAc,CAACjG,WAA4B;IACzC,IAAI,CAACA,WAAW,GAAG,IAAI,CAACA,WAAW,CAACkG,OAAO,CAAClG,WAAW,CAAC;EAC1D;EAEAmG,gBAAgB,CAAC7D,OAAuC;IACtD,IAAI,CAACF,cAAc,CAACuC,IAAI,CAACrC,OAAO,CAAC;EACnC;EAEA0C,aAAa;IACX,OAAO,IAAI,CAAC/E,UAAU;EACxB;;AAxPFmG","names":["TRACER_NAME","ResolvingCall","constructor","channel","method","options","filterStackFactory","credentials","callNumber","setTimeout","deadline","host","parentCall","flags","constants_1","CANCELLATION","on","cancelWithStatus","CANCELLED","DEADLINE","trace","getDeadline","runDeadlineTimer","text","logging","DEBUG","clearTimeout","deadlineTimer","timeout","Infinity","handleDeadline","DEADLINE_EXCEEDED","process","nextTick","outputStatus","status","ended","filterStack","createFilter","filteredStatus","receiveTrailers","code","details","statusWatchers","forEach","watcher","listener","onReceiveStatus","sendMessageOnChild","context","message","child","Error","writeFilterPending","sendMessage","Promise","resolve","then","filteredMessage","sendMessageWithContext","pendingHalfClose","halfClose","getConfig","metadata","configResult","type","queueCallForConfig","getOptions","waitForReady","error","config","OK","metadata_1","methodConfig","configDeadline","Date","setSeconds","getSeconds","seconds","setMilliseconds","getMilliseconds","nanos","push","dynamicFilterFactories","sendMetadata","filteredMetadata","createInnerCall","getCallNumber","start","onReceiveMetadata","receiveMetadata","onReceiveMessage","readFilterPending","receiveMessage","filteredMesssage","pendingChildStatus","readPending","startRead","pendingMessage","reportResolverError","getPeer","getTarget","clone","length","setCredentials","compose","addStatusWatcher","exports"],"sources":["/home/achwak/node_modules/@grpc/grpc-js/src/resolving-call.ts"],"sourcesContent":["/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { CallCredentials } from \"./call-credentials\";\nimport { Call, CallStreamOptions, InterceptingListener, MessageContext, StatusObject } from \"./call-interface\";\nimport { LogVerbosity, Propagate, Status } from \"./constants\";\nimport { Deadline, deadlineToString, getDeadlineTimeoutString, getRelativeTimeout, minDeadline } from \"./deadline\";\nimport { FilterStack, FilterStackFactory } from \"./filter-stack\";\nimport { InternalChannel } from \"./internal-channel\";\nimport { Metadata } from \"./metadata\";\nimport * as logging from './logging';\nimport { restrictControlPlaneStatusCode } from \"./control-plane-status\";\n\nconst TRACER_NAME = 'resolving_call';\n\nexport class ResolvingCall implements Call {\n  private child: Call | null = null;\n  private readPending = false;\n  private pendingMessage: {context: MessageContext, message: Buffer} | null = null;\n  private pendingHalfClose = false;\n  private ended = false;\n  private readFilterPending = false;\n  private writeFilterPending = false;\n  private pendingChildStatus: StatusObject | null = null;\n  private metadata: Metadata | null = null;\n  private listener: InterceptingListener | null = null;\n  private deadline: Deadline;\n  private host: string;\n  private statusWatchers: ((status: StatusObject) => void)[] = [];\n  private deadlineTimer: NodeJS.Timer = setTimeout(() => {}, 0);\n  private filterStack: FilterStack | null = null;\n\n  constructor(\n    private readonly channel: InternalChannel,\n    private readonly method: string,\n    options: CallStreamOptions,\n    private readonly filterStackFactory: FilterStackFactory,\n    private credentials: CallCredentials,\n    private callNumber: number\n  ) {\n    this.deadline = options.deadline;\n    this.host = options.host;\n    if (options.parentCall) {\n      if (options.flags & Propagate.CANCELLATION) {\n        options.parentCall.on('cancelled', () => {\n          this.cancelWithStatus(Status.CANCELLED, 'Cancelled by parent call');\n        });\n      }\n      if (options.flags & Propagate.DEADLINE) {\n        this.trace('Propagating deadline from parent: ' + options.parentCall.getDeadline());\n        this.deadline = minDeadline(this.deadline, options.parentCall.getDeadline());\n      }\n    }\n    this.trace('Created');\n    this.runDeadlineTimer();\n  }\n\n  private trace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      TRACER_NAME,\n      '[' + this.callNumber + '] ' + text\n    );\n  }\n\n  private runDeadlineTimer() {\n    clearTimeout(this.deadlineTimer);\n    this.trace('Deadline: ' + deadlineToString(this.deadline));\n    const timeout = getRelativeTimeout(this.deadline);\n    if (timeout !== Infinity) {\n      this.trace('Deadline will be reached in ' + timeout + 'ms');\n      const handleDeadline = () => {\n        this.cancelWithStatus(\n          Status.DEADLINE_EXCEEDED,\n          'Deadline exceeded'\n        );\n      }\n      if (timeout <= 0) {\n        process.nextTick(handleDeadline);\n      } else {\n        this.deadlineTimer = setTimeout(handleDeadline, timeout);\n      }\n    }\n  }\n\n  private outputStatus(status: StatusObject) {\n    if (!this.ended) {\n      this.ended = true;\n      if (!this.filterStack) {\n        this.filterStack = this.filterStackFactory.createFilter();\n      }\n      clearTimeout(this.deadlineTimer);\n      const filteredStatus = this.filterStack.receiveTrailers(status);\n      this.trace('ended with status: code=' + filteredStatus.code + ' details=\"' + filteredStatus.details + '\"');\n      this.statusWatchers.forEach(watcher => watcher(filteredStatus));\n      process.nextTick(() => {\n        this.listener?.onReceiveStatus(filteredStatus);\n      });\n    }\n  }\n\n  private sendMessageOnChild(context: MessageContext, message: Buffer): void {\n    if (!this.child) {\n      throw new Error('sendMessageonChild called with child not populated');\n    }\n    const child = this.child;\n    this.writeFilterPending = true;\n    this.filterStack!.sendMessage(Promise.resolve({message: message, flags: context.flags})).then((filteredMessage) => {\n      this.writeFilterPending = false;\n      child.sendMessageWithContext(context, filteredMessage.message);\n      if (this.pendingHalfClose) {\n        child.halfClose();\n      }\n    }, (status: StatusObject) => {\n      this.cancelWithStatus(status.code, status.details);\n    });\n  }\n\n  getConfig(): void {\n    if (this.ended) {\n      return;\n    }\n    if (!this.metadata || !this.listener) {\n      throw new Error('getConfig called before start');\n    }\n    const configResult = this.channel.getConfig(this.method, this.metadata);\n    if (configResult.type === 'NONE') {\n      this.channel.queueCallForConfig(this);\n      return;\n    } else if (configResult.type === 'ERROR') {\n      if (this.metadata.getOptions().waitForReady) {\n        this.channel.queueCallForConfig(this);\n      } else {\n        this.outputStatus(configResult.error);\n      }\n      return;\n    }\n    // configResult.type === 'SUCCESS'\n    const config = configResult.config;\n    if (config.status !== Status.OK) {\n      const {code, details} = restrictControlPlaneStatusCode(config.status, 'Failed to route call to method ' + this.method);\n      this.outputStatus({\n        code: code,\n        details: details,\n        metadata: new Metadata()\n      });\n      return;\n    }\n\n    if (config.methodConfig.timeout) {\n      const configDeadline = new Date();\n      configDeadline.setSeconds(\n        configDeadline.getSeconds() + config.methodConfig.timeout.seconds\n      );\n      configDeadline.setMilliseconds(\n        configDeadline.getMilliseconds() +\n          config.methodConfig.timeout.nanos / 1_000_000\n      );\n      this.deadline = minDeadline(this.deadline, configDeadline);\n      this.runDeadlineTimer();\n    }\n\n    this.filterStackFactory.push(config.dynamicFilterFactories);\n    this.filterStack = this.filterStackFactory.createFilter();\n    this.filterStack.sendMetadata(Promise.resolve(this.metadata)).then(filteredMetadata => {\n      this.child = this.channel.createInnerCall(config, this.method, this.host, this.credentials, this.deadline);\n      this.trace('Created child [' + this.child.getCallNumber() + ']')\n      this.child.start(filteredMetadata, {\n        onReceiveMetadata: metadata => {\n          this.trace('Received metadata')\n          this.listener!.onReceiveMetadata(this.filterStack!.receiveMetadata(metadata));\n        },\n        onReceiveMessage: message => {\n          this.trace('Received message');\n          this.readFilterPending = true;\n          this.filterStack!.receiveMessage(message).then(filteredMesssage => {\n            this.trace('Finished filtering received message');\n            this.readFilterPending = false;\n            this.listener!.onReceiveMessage(filteredMesssage);\n            if (this.pendingChildStatus) {\n              this.outputStatus(this.pendingChildStatus);\n            }\n          }, (status: StatusObject) => {\n            this.cancelWithStatus(status.code, status.details);\n          });\n        },\n        onReceiveStatus: status => {\n          this.trace('Received status');\n          if (this.readFilterPending) {\n            this.pendingChildStatus = status;\n          } else {\n            this.outputStatus(status);\n          }\n        }\n      });\n      if (this.readPending) {\n        this.child.startRead();\n      }\n      if (this.pendingMessage) {\n        this.sendMessageOnChild(this.pendingMessage.context, this.pendingMessage.message);\n      } else if (this.pendingHalfClose) {\n        this.child.halfClose();\n      }\n    }, (status: StatusObject) => {\n      this.outputStatus(status);\n    })\n  }\n\n  reportResolverError(status: StatusObject) {\n    if (this.metadata?.getOptions().waitForReady) {\n      this.channel.queueCallForConfig(this);\n    } else {\n      this.outputStatus(status);\n    }\n  }\n  cancelWithStatus(status: Status, details: string): void {\n    this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\n    this.child?.cancelWithStatus(status, details);\n    this.outputStatus({code: status, details: details, metadata: new Metadata()});\n  }\n  getPeer(): string {\n    return this.child?.getPeer() ?? this.channel.getTarget();\n  }\n  start(metadata: Metadata, listener: InterceptingListener): void {\n    this.trace('start called');\n    this.metadata = metadata.clone();\n    this.listener = listener;\n    this.getConfig();\n  }\n  sendMessageWithContext(context: MessageContext, message: Buffer): void {\n    this.trace('write() called with message of length ' + message.length);\n    if (this.child) {\n      this.sendMessageOnChild(context, message);\n    } else {\n      this.pendingMessage = {context, message};\n    }\n  }\n  startRead(): void {\n    this.trace('startRead called');\n    if (this.child) {\n      this.child.startRead();\n    } else {\n      this.readPending = true;\n    }\n  }\n  halfClose(): void {\n    this.trace('halfClose called');\n    if (this.child && !this.writeFilterPending) {\n      this.child.halfClose();\n    } else {\n      this.pendingHalfClose = true;\n    }\n  }\n  setCredentials(credentials: CallCredentials): void {\n    this.credentials = this.credentials.compose(credentials);\n  }\n\n  addStatusWatcher(watcher: (status: StatusObject) => void) {\n    this.statusWatchers.push(watcher);\n  }\n\n  getCallNumber(): number {\n    return this.callNumber;\n  }\n}"]},"metadata":{},"sourceType":"script","externalDependencies":[]}