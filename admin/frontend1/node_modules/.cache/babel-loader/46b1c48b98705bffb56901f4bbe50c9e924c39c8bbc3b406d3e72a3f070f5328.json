{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mapUriDefaultScheme = exports.getDefaultAuthority = exports.createResolver = exports.registerDefaultScheme = exports.registerResolver = void 0;\nconst uri_parser_1 = require(\"./uri-parser\");\nconst registeredResolvers = {};\nlet defaultScheme = null;\n/**\n * Register a resolver class to handle target names prefixed with the `prefix`\n * string. This prefix should correspond to a URI scheme name listed in the\n * [gRPC Name Resolution document](https://github.com/grpc/grpc/blob/master/doc/naming.md)\n * @param prefix\n * @param resolverClass\n */\nfunction registerResolver(scheme, resolverClass) {\n  registeredResolvers[scheme] = resolverClass;\n}\nexports.registerResolver = registerResolver;\n/**\n * Register a default resolver to handle target names that do not start with\n * any registered prefix.\n * @param resolverClass\n */\nfunction registerDefaultScheme(scheme) {\n  defaultScheme = scheme;\n}\nexports.registerDefaultScheme = registerDefaultScheme;\n/**\n * Create a name resolver for the specified target, if possible. Throws an\n * error if no such name resolver can be created.\n * @param target\n * @param listener\n */\nfunction createResolver(target, listener, options) {\n  if (target.scheme !== undefined && target.scheme in registeredResolvers) {\n    return new registeredResolvers[target.scheme](target, listener, options);\n  } else {\n    throw new Error(`No resolver could be created for target ${(0, uri_parser_1.uriToString)(target)}`);\n  }\n}\nexports.createResolver = createResolver;\n/**\n * Get the default authority for the specified target, if possible. Throws an\n * error if no registered name resolver can parse that target string.\n * @param target\n */\nfunction getDefaultAuthority(target) {\n  if (target.scheme !== undefined && target.scheme in registeredResolvers) {\n    return registeredResolvers[target.scheme].getDefaultAuthority(target);\n  } else {\n    throw new Error(`Invalid target ${(0, uri_parser_1.uriToString)(target)}`);\n  }\n}\nexports.getDefaultAuthority = getDefaultAuthority;\nfunction mapUriDefaultScheme(target) {\n  if (target.scheme === undefined || !(target.scheme in registeredResolvers)) {\n    if (defaultScheme !== null) {\n      return {\n        scheme: defaultScheme,\n        authority: undefined,\n        path: (0, uri_parser_1.uriToString)(target)\n      };\n    } else {\n      return null;\n    }\n  }\n  return target;\n}\nexports.mapUriDefaultScheme = mapUriDefaultScheme;","map":{"version":3,"mappings":";;AAAA;;;;;;;;;;;;;;;;;;;;AAoBA;AAoFA,MAAMA,mBAAmB,GAA8C,EAAE;AACzE,IAAIC,aAAa,GAAkB,IAAI;AAEvC;;;;;;;AAOA,SAAgBC,gBAAgB,CAC9BC,MAAc,EACdC,aAAkC;EAElCJ,mBAAmB,CAACG,MAAM,CAAC,GAAGC,aAAa;AAC7C;AALAC;AAOA;;;;;AAKA,SAAgBC,qBAAqB,CAACH,MAAc;EAClDF,aAAa,GAAGE,MAAM;AACxB;AAFAE;AAIA;;;;;;AAMA,SAAgBE,cAAc,CAC5BC,MAAe,EACfC,QAA0B,EAC1BC,OAAuB;EAEvB,IAAIF,MAAM,CAACL,MAAM,KAAKQ,SAAS,IAAIH,MAAM,CAACL,MAAM,IAAIH,mBAAmB,EAAE;IACvE,OAAO,IAAIA,mBAAmB,CAACQ,MAAM,CAACL,MAAM,CAAC,CAACK,MAAM,EAAEC,QAAQ,EAAEC,OAAO,CAAC;GACzE,MAAM;IACL,MAAM,IAAIE,KAAK,CACb,2CAA2C,4BAAW,EAACJ,MAAM,CAAC,EAAE,CACjE;;AAEL;AAZAH;AAcA;;;;;AAKA,SAAgBQ,mBAAmB,CAACL,MAAe;EACjD,IAAIA,MAAM,CAACL,MAAM,KAAKQ,SAAS,IAAIH,MAAM,CAACL,MAAM,IAAIH,mBAAmB,EAAE;IACvE,OAAOA,mBAAmB,CAACQ,MAAM,CAACL,MAAM,CAAC,CAACU,mBAAmB,CAACL,MAAM,CAAC;GACtE,MAAM;IACL,MAAM,IAAII,KAAK,CAAC,kBAAkB,4BAAW,EAACJ,MAAM,CAAC,EAAE,CAAC;;AAE5D;AANAH;AAQA,SAAgBS,mBAAmB,CAACN,MAAe;EACjD,IAAIA,MAAM,CAACL,MAAM,KAAKQ,SAAS,IAAI,EAAEH,MAAM,CAACL,MAAM,IAAIH,mBAAmB,CAAC,EAAE;IAC1E,IAAIC,aAAa,KAAK,IAAI,EAAE;MAC1B,OAAO;QACLE,MAAM,EAAEF,aAAa;QACrBc,SAAS,EAAEJ,SAAS;QACpBK,IAAI,EAAE,4BAAW,EAACR,MAAM;OACzB;KACF,MAAM;MACL,OAAO,IAAI;;;EAGf,OAAOA,MAAM;AACf;AAbAH","names":["registeredResolvers","defaultScheme","registerResolver","scheme","resolverClass","exports","registerDefaultScheme","createResolver","target","listener","options","undefined","Error","getDefaultAuthority","mapUriDefaultScheme","authority","path"],"sources":["/home/achwak/node_modules/@grpc/grpc-js/src/resolver.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { MethodConfig, ServiceConfig } from './service-config';\nimport { StatusObject } from './call-interface';\nimport { SubchannelAddress } from './subchannel-address';\nimport { GrpcUri, uriToString } from './uri-parser';\nimport { ChannelOptions } from './channel-options';\nimport { Metadata } from './metadata';\nimport { Status } from './constants';\nimport { Filter, FilterFactory } from './filter';\n\nexport interface CallConfig {\n  methodConfig: MethodConfig;\n  onCommitted?: () => void;\n  pickInformation: { [key: string]: string };\n  status: Status;\n  dynamicFilterFactories: FilterFactory<Filter>[];\n}\n\n/**\n * Selects a configuration for a method given the name and metadata. Defined in\n * https://github.com/grpc/proposal/blob/master/A31-xds-timeout-support-and-config-selector.md#new-functionality-in-grpc\n */\nexport interface ConfigSelector {\n  (methodName: string, metadata: Metadata): CallConfig;\n}\n\n/**\n * A listener object passed to the resolver's constructor that provides name\n * resolution updates back to the resolver's owner.\n */\nexport interface ResolverListener {\n  /**\n   * Called whenever the resolver has new name resolution results to report\n   * @param addressList The new list of backend addresses\n   * @param serviceConfig The new service configuration corresponding to the\n   *     `addressList`. Will be `null` if no service configuration was\n   *     retrieved or if the service configuration was invalid\n   * @param serviceConfigError If non-`null`, indicates that the retrieved\n   *     service configuration was invalid\n   */\n  onSuccessfulResolution(\n    addressList: SubchannelAddress[],\n    serviceConfig: ServiceConfig | null,\n    serviceConfigError: StatusObject | null,\n    configSelector: ConfigSelector | null,\n    attributes: { [key: string]: unknown }\n  ): void;\n  /**\n   * Called whenever a name resolution attempt fails.\n   * @param error Describes how resolution failed\n   */\n  onError(error: StatusObject): void;\n}\n\n/**\n * A resolver class that handles one or more of the name syntax schemes defined\n * in the [gRPC Name Resolution document](https://github.com/grpc/grpc/blob/master/doc/naming.md)\n */\nexport interface Resolver {\n  /**\n   * Indicates that the caller wants new name resolution data. Calling this\n   * function may eventually result in calling one of the `ResolverListener`\n   * functions, but that is not guaranteed. Those functions will never be\n   * called synchronously with the constructor or updateResolution.\n   */\n  updateResolution(): void;\n\n  /**\n   * Destroy the resolver. Should be called when the owning channel shuts down.\n   */\n  destroy(): void;\n}\n\nexport interface ResolverConstructor {\n  new (\n    target: GrpcUri,\n    listener: ResolverListener,\n    channelOptions: ChannelOptions\n  ): Resolver;\n  /**\n   * Get the default authority for a target. This loosely corresponds to that\n   * target's hostname. Throws an error if this resolver class cannot parse the\n   * `target`.\n   * @param target\n   */\n  getDefaultAuthority(target: GrpcUri): string;\n}\n\nconst registeredResolvers: { [scheme: string]: ResolverConstructor } = {};\nlet defaultScheme: string | null = null;\n\n/**\n * Register a resolver class to handle target names prefixed with the `prefix`\n * string. This prefix should correspond to a URI scheme name listed in the\n * [gRPC Name Resolution document](https://github.com/grpc/grpc/blob/master/doc/naming.md)\n * @param prefix\n * @param resolverClass\n */\nexport function registerResolver(\n  scheme: string,\n  resolverClass: ResolverConstructor\n) {\n  registeredResolvers[scheme] = resolverClass;\n}\n\n/**\n * Register a default resolver to handle target names that do not start with\n * any registered prefix.\n * @param resolverClass\n */\nexport function registerDefaultScheme(scheme: string) {\n  defaultScheme = scheme;\n}\n\n/**\n * Create a name resolver for the specified target, if possible. Throws an\n * error if no such name resolver can be created.\n * @param target\n * @param listener\n */\nexport function createResolver(\n  target: GrpcUri,\n  listener: ResolverListener,\n  options: ChannelOptions\n): Resolver {\n  if (target.scheme !== undefined && target.scheme in registeredResolvers) {\n    return new registeredResolvers[target.scheme](target, listener, options);\n  } else {\n    throw new Error(\n      `No resolver could be created for target ${uriToString(target)}`\n    );\n  }\n}\n\n/**\n * Get the default authority for the specified target, if possible. Throws an\n * error if no registered name resolver can parse that target string.\n * @param target\n */\nexport function getDefaultAuthority(target: GrpcUri): string {\n  if (target.scheme !== undefined && target.scheme in registeredResolvers) {\n    return registeredResolvers[target.scheme].getDefaultAuthority(target);\n  } else {\n    throw new Error(`Invalid target ${uriToString(target)}`);\n  }\n}\n\nexport function mapUriDefaultScheme(target: GrpcUri): GrpcUri | null {\n  if (target.scheme === undefined || !(target.scheme in registeredResolvers)) {\n    if (defaultScheme !== null) {\n      return {\n        scheme: defaultScheme,\n        authority: undefined,\n        path: uriToString(target),\n      };\n    } else {\n      return null;\n    }\n  }\n  return target;\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}