{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Http2SubchannelCall = void 0;\nconst http2 = require(\"http2\");\nconst os = require(\"os\");\nconst constants_1 = require(\"./constants\");\nconst metadata_1 = require(\"./metadata\");\nconst stream_decoder_1 = require(\"./stream-decoder\");\nconst logging = require(\"./logging\");\nconst constants_2 = require(\"./constants\");\nconst TRACER_NAME = 'subchannel_call';\nconst {\n  HTTP2_HEADER_STATUS,\n  HTTP2_HEADER_CONTENT_TYPE,\n  NGHTTP2_CANCEL\n} = http2.constants;\n/**\n * Should do approximately the same thing as util.getSystemErrorName but the\n * TypeScript types don't have that function for some reason so I just made my\n * own.\n * @param errno\n */\nfunction getSystemErrorName(errno) {\n  for (const [name, num] of Object.entries(os.constants.errno)) {\n    if (num === errno) {\n      return name;\n    }\n  }\n  return 'Unknown system error ' + errno;\n}\nclass Http2SubchannelCall {\n  constructor(http2Stream, callEventTracker, listener, transport, callId) {\n    this.http2Stream = http2Stream;\n    this.callEventTracker = callEventTracker;\n    this.listener = listener;\n    this.transport = transport;\n    this.callId = callId;\n    this.decoder = new stream_decoder_1.StreamDecoder();\n    this.isReadFilterPending = false;\n    this.isPushPending = false;\n    this.canPush = false;\n    /**\n     * Indicates that an 'end' event has come from the http2 stream, so there\n     * will be no more data events.\n     */\n    this.readsClosed = false;\n    this.statusOutput = false;\n    this.unpushedReadMessages = [];\n    // Status code mapped from :status. To be used if grpc-status is not received\n    this.mappedStatusCode = constants_1.Status.UNKNOWN;\n    // This is populated (non-null) if and only if the call has ended\n    this.finalStatus = null;\n    this.internalError = null;\n    http2Stream.on('response', (headers, flags) => {\n      let headersString = '';\n      for (const header of Object.keys(headers)) {\n        headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n      }\n      this.trace('Received server headers:\\n' + headersString);\n      switch (headers[':status']) {\n        // TODO(murgatroid99): handle 100 and 101\n        case 400:\n          this.mappedStatusCode = constants_1.Status.INTERNAL;\n          break;\n        case 401:\n          this.mappedStatusCode = constants_1.Status.UNAUTHENTICATED;\n          break;\n        case 403:\n          this.mappedStatusCode = constants_1.Status.PERMISSION_DENIED;\n          break;\n        case 404:\n          this.mappedStatusCode = constants_1.Status.UNIMPLEMENTED;\n          break;\n        case 429:\n        case 502:\n        case 503:\n        case 504:\n          this.mappedStatusCode = constants_1.Status.UNAVAILABLE;\n          break;\n        default:\n          this.mappedStatusCode = constants_1.Status.UNKNOWN;\n      }\n      if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {\n        this.handleTrailers(headers);\n      } else {\n        let metadata;\n        try {\n          metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n        } catch (error) {\n          this.endCall({\n            code: constants_1.Status.UNKNOWN,\n            details: error.message,\n            metadata: new metadata_1.Metadata()\n          });\n          return;\n        }\n        this.listener.onReceiveMetadata(metadata);\n      }\n    });\n    http2Stream.on('trailers', headers => {\n      this.handleTrailers(headers);\n    });\n    http2Stream.on('data', data => {\n      /* If the status has already been output, allow the http2 stream to\n       * drain without processing the data. */\n      if (this.statusOutput) {\n        return;\n      }\n      this.trace('receive HTTP/2 data frame of length ' + data.length);\n      const messages = this.decoder.write(data);\n      for (const message of messages) {\n        this.trace('parsed message of length ' + message.length);\n        this.callEventTracker.addMessageReceived();\n        this.tryPush(message);\n      }\n    });\n    http2Stream.on('end', () => {\n      this.readsClosed = true;\n      this.maybeOutputStatus();\n    });\n    http2Stream.on('close', () => {\n      /* Use process.next tick to ensure that this code happens after any\n       * \"error\" event that may be emitted at about the same time, so that\n       * we can bubble up the error message from that event. */\n      process.nextTick(() => {\n        var _a;\n        this.trace('HTTP/2 stream closed with code ' + http2Stream.rstCode);\n        /* If we have a final status with an OK status code, that means that\n         * we have received all of the messages and we have processed the\n         * trailers and the call completed successfully, so it doesn't matter\n         * how the stream ends after that */\n        if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\n          return;\n        }\n        let code;\n        let details = '';\n        switch (http2Stream.rstCode) {\n          case http2.constants.NGHTTP2_NO_ERROR:\n            /* If we get a NO_ERROR code and we already have a status, the\n             * stream completed properly and we just haven't fully processed\n             * it yet */\n            if (this.finalStatus !== null) {\n              return;\n            }\n            code = constants_1.Status.INTERNAL;\n            details = `Received RST_STREAM with code ${http2Stream.rstCode}`;\n            break;\n          case http2.constants.NGHTTP2_REFUSED_STREAM:\n            code = constants_1.Status.UNAVAILABLE;\n            details = 'Stream refused by server';\n            break;\n          case http2.constants.NGHTTP2_CANCEL:\n            code = constants_1.Status.CANCELLED;\n            details = 'Call cancelled';\n            break;\n          case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:\n            code = constants_1.Status.RESOURCE_EXHAUSTED;\n            details = 'Bandwidth exhausted or memory limit exceeded';\n            break;\n          case http2.constants.NGHTTP2_INADEQUATE_SECURITY:\n            code = constants_1.Status.PERMISSION_DENIED;\n            details = 'Protocol not secure enough';\n            break;\n          case http2.constants.NGHTTP2_INTERNAL_ERROR:\n            code = constants_1.Status.INTERNAL;\n            if (this.internalError === null) {\n              /* This error code was previously handled in the default case, and\n               * there are several instances of it online, so I wanted to\n               * preserve the original error message so that people find existing\n               * information in searches, but also include the more recognizable\n               * \"Internal server error\" message. */\n              details = `Received RST_STREAM with code ${http2Stream.rstCode} (Internal server error)`;\n            } else {\n              if (this.internalError.code === 'ECONNRESET' || this.internalError.code === 'ETIMEDOUT') {\n                code = constants_1.Status.UNAVAILABLE;\n                details = this.internalError.message;\n              } else {\n                /* The \"Received RST_STREAM with code ...\" error is preserved\n                 * here for continuity with errors reported online, but the\n                 * error message at the end will probably be more relevant in\n                 * most cases. */\n                details = `Received RST_STREAM with code ${http2Stream.rstCode} triggered by internal client error: ${this.internalError.message}`;\n              }\n            }\n            break;\n          default:\n            code = constants_1.Status.INTERNAL;\n            details = `Received RST_STREAM with code ${http2Stream.rstCode}`;\n        }\n        // This is a no-op if trailers were received at all.\n        // This is OK, because status codes emitted here correspond to more\n        // catastrophic issues that prevent us from receiving trailers in the\n        // first place.\n        this.endCall({\n          code,\n          details,\n          metadata: new metadata_1.Metadata(),\n          rstCode: http2Stream.rstCode\n        });\n      });\n    });\n    http2Stream.on('error', err => {\n      /* We need an error handler here to stop \"Uncaught Error\" exceptions\n       * from bubbling up. However, errors here should all correspond to\n       * \"close\" events, where we will handle the error more granularly */\n      /* Specifically looking for stream errors that were *not* constructed\n       * from a RST_STREAM response here:\n       * https://github.com/nodejs/node/blob/8b8620d580314050175983402dfddf2674e8e22a/lib/internal/http2/core.js#L2267\n       */\n      if (err.code !== 'ERR_HTTP2_STREAM_ERROR') {\n        this.trace('Node error event: message=' + err.message + ' code=' + err.code + ' errno=' + getSystemErrorName(err.errno) + ' syscall=' + err.syscall);\n        this.internalError = err;\n      }\n      this.callEventTracker.onStreamEnd(false);\n    });\n  }\n  onDisconnect() {\n    this.endCall({\n      code: constants_1.Status.UNAVAILABLE,\n      details: 'Connection dropped',\n      metadata: new metadata_1.Metadata()\n    });\n  }\n  outputStatus() {\n    /* Precondition: this.finalStatus !== null */\n    if (!this.statusOutput) {\n      this.statusOutput = true;\n      this.trace('ended with status: code=' + this.finalStatus.code + ' details=\"' + this.finalStatus.details + '\"');\n      this.callEventTracker.onCallEnd(this.finalStatus);\n      /* We delay the actual action of bubbling up the status to insulate the\n       * cleanup code in this class from any errors that may be thrown in the\n       * upper layers as a result of bubbling up the status. In particular,\n       * if the status is not OK, the \"error\" event may be emitted\n       * synchronously at the top level, which will result in a thrown error if\n       * the user does not handle that event. */\n      process.nextTick(() => {\n        this.listener.onReceiveStatus(this.finalStatus);\n      });\n      /* Leave the http2 stream in flowing state to drain incoming messages, to\n       * ensure that the stream closure completes. The call stream already does\n       * not push more messages after the status is output, so the messages go\n       * nowhere either way. */\n      this.http2Stream.resume();\n    }\n  }\n  trace(text) {\n    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callId + '] ' + text);\n  }\n  /**\n   * On first call, emits a 'status' event with the given StatusObject.\n   * Subsequent calls are no-ops.\n   * @param status The status of the call.\n   */\n  endCall(status) {\n    /* If the status is OK and a new status comes in (e.g. from a\n     * deserialization failure), that new status takes priority */\n    if (this.finalStatus === null || this.finalStatus.code === constants_1.Status.OK) {\n      this.finalStatus = status;\n      this.maybeOutputStatus();\n    }\n    this.destroyHttp2Stream();\n  }\n  maybeOutputStatus() {\n    if (this.finalStatus !== null) {\n      /* The combination check of readsClosed and that the two message buffer\n       * arrays are empty checks that there all incoming data has been fully\n       * processed */\n      if (this.finalStatus.code !== constants_1.Status.OK || this.readsClosed && this.unpushedReadMessages.length === 0 && !this.isReadFilterPending && !this.isPushPending) {\n        this.outputStatus();\n      }\n    }\n  }\n  push(message) {\n    this.trace('pushing to reader message of length ' + (message instanceof Buffer ? message.length : null));\n    this.canPush = false;\n    this.isPushPending = true;\n    process.nextTick(() => {\n      this.isPushPending = false;\n      /* If we have already output the status any later messages should be\n       * ignored, and can cause out-of-order operation errors higher up in the\n       * stack. Checking as late as possible here to avoid any race conditions.\n       */\n      if (this.statusOutput) {\n        return;\n      }\n      this.listener.onReceiveMessage(message);\n      this.maybeOutputStatus();\n    });\n  }\n  tryPush(messageBytes) {\n    if (this.canPush) {\n      this.http2Stream.pause();\n      this.push(messageBytes);\n    } else {\n      this.trace('unpushedReadMessages.push message of length ' + messageBytes.length);\n      this.unpushedReadMessages.push(messageBytes);\n    }\n  }\n  handleTrailers(headers) {\n    this.callEventTracker.onStreamEnd(true);\n    let headersString = '';\n    for (const header of Object.keys(headers)) {\n      headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n    }\n    this.trace('Received server trailers:\\n' + headersString);\n    let metadata;\n    try {\n      metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n    } catch (e) {\n      metadata = new metadata_1.Metadata();\n    }\n    const metadataMap = metadata.getMap();\n    let code = this.mappedStatusCode;\n    if (code === constants_1.Status.UNKNOWN && typeof metadataMap['grpc-status'] === 'string') {\n      const receivedStatus = Number(metadataMap['grpc-status']);\n      if (receivedStatus in constants_1.Status) {\n        code = receivedStatus;\n        this.trace('received status code ' + receivedStatus + ' from server');\n      }\n      metadata.remove('grpc-status');\n    }\n    let details = '';\n    if (typeof metadataMap['grpc-message'] === 'string') {\n      try {\n        details = decodeURI(metadataMap['grpc-message']);\n      } catch (e) {\n        details = metadataMap['grpc-message'];\n      }\n      metadata.remove('grpc-message');\n      this.trace('received status details string \"' + details + '\" from server');\n    }\n    const status = {\n      code,\n      details,\n      metadata\n    };\n    // This is a no-op if the call was already ended when handling headers.\n    this.endCall(status);\n  }\n  destroyHttp2Stream() {\n    var _a;\n    // The http2 stream could already have been destroyed if cancelWithStatus\n    // is called in response to an internal http2 error.\n    if (!this.http2Stream.destroyed) {\n      /* If the call has ended with an OK status, communicate that when closing\n       * the stream, partly to avoid a situation in which we detect an error\n       * RST_STREAM as a result after we have the status */\n      let code;\n      if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\n        code = http2.constants.NGHTTP2_NO_ERROR;\n      } else {\n        code = http2.constants.NGHTTP2_CANCEL;\n      }\n      this.trace('close http2 stream with code ' + code);\n      this.http2Stream.close(code);\n    }\n  }\n  cancelWithStatus(status, details) {\n    this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\n    this.endCall({\n      code: status,\n      details,\n      metadata: new metadata_1.Metadata()\n    });\n  }\n  getStatus() {\n    return this.finalStatus;\n  }\n  getPeer() {\n    return this.transport.getPeerName();\n  }\n  getCallNumber() {\n    return this.callId;\n  }\n  startRead() {\n    /* If the stream has ended with an error, we should not emit any more\n     * messages and we should communicate that the stream has ended */\n    if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {\n      this.readsClosed = true;\n      this.maybeOutputStatus();\n      return;\n    }\n    this.canPush = true;\n    if (this.unpushedReadMessages.length > 0) {\n      const nextMessage = this.unpushedReadMessages.shift();\n      this.push(nextMessage);\n      return;\n    }\n    /* Only resume reading from the http2Stream if we don't have any pending\n      * messages to emit */\n    this.http2Stream.resume();\n  }\n  sendMessageWithContext(context, message) {\n    this.trace('write() called with message of length ' + message.length);\n    const cb = error => {\n      var _a;\n      let code = constants_1.Status.UNAVAILABLE;\n      if ((error === null || error === void 0 ? void 0 : error.code) === 'ERR_STREAM_WRITE_AFTER_END') {\n        code = constants_1.Status.INTERNAL;\n      }\n      if (error) {\n        this.cancelWithStatus(code, `Write error: ${error.message}`);\n      }\n      (_a = context.callback) === null || _a === void 0 ? void 0 : _a.call(context);\n    };\n    this.trace('sending data chunk of length ' + message.length);\n    this.callEventTracker.addMessageSent();\n    try {\n      this.http2Stream.write(message, cb);\n    } catch (error) {\n      this.endCall({\n        code: constants_1.Status.UNAVAILABLE,\n        details: `Write failed with error ${error.message}`,\n        metadata: new metadata_1.Metadata()\n      });\n    }\n  }\n  halfClose() {\n    this.trace('end() called');\n    this.trace('calling end() on HTTP/2 stream');\n    this.http2Stream.end();\n  }\n}\nexports.Http2SubchannelCall = Http2SubchannelCall;","map":{"version":3,"mappings":"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","names":["TRACER_NAME","HTTP2_HEADER_STATUS","HTTP2_HEADER_CONTENT_TYPE","NGHTTP2_CANCEL","http2","constants","getSystemErrorName","errno","name","num","Object","entries","os","Http2SubchannelCall","constructor","http2Stream","callEventTracker","listener","transport","callId","stream_decoder_1","constants_1","UNKNOWN","on","headers","flags","headersString","header","keys","trace","mappedStatusCode","INTERNAL","UNAUTHENTICATED","PERMISSION_DENIED","UNIMPLEMENTED","UNAVAILABLE","NGHTTP2_FLAG_END_STREAM","handleTrailers","metadata","metadata_1","fromHttp2Headers","error","endCall","code","details","message","onReceiveMetadata","data","statusOutput","length","messages","decoder","write","addMessageReceived","tryPush","readsClosed","maybeOutputStatus","process","nextTick","rstCode","finalStatus","OK","NGHTTP2_NO_ERROR","NGHTTP2_REFUSED_STREAM","CANCELLED","NGHTTP2_ENHANCE_YOUR_CALM","RESOURCE_EXHAUSTED","NGHTTP2_INADEQUATE_SECURITY","NGHTTP2_INTERNAL_ERROR","internalError","err","syscall","onStreamEnd","onDisconnect","outputStatus","onCallEnd","onReceiveStatus","resume","text","logging","constants_2","DEBUG","status","destroyHttp2Stream","unpushedReadMessages","isReadFilterPending","isPushPending","push","Buffer","canPush","onReceiveMessage","messageBytes","pause","e","metadataMap","getMap","receivedStatus","Number","remove","decodeURI","destroyed","close","cancelWithStatus","getStatus","getPeer","getPeerName","getCallNumber","startRead","nextMessage","shift","sendMessageWithContext","context","cb","callback","addMessageSent","halfClose","end","exports"],"sources":["/home/achwak/node_modules/@grpc/grpc-js/src/subchannel-call.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport * as http2 from 'http2';\nimport * as os from 'os';\n\nimport { Status } from './constants';\nimport { Metadata } from './metadata';\nimport { StreamDecoder } from './stream-decoder';\nimport * as logging from './logging';\nimport { LogVerbosity } from './constants';\nimport { ServerSurfaceCall } from './server-call';\nimport { Deadline } from './deadline';\nimport { InterceptingListener, MessageContext, StatusObject, WriteCallback } from './call-interface';\nimport { CallEventTracker, Transport } from './transport';\n\nconst TRACER_NAME = 'subchannel_call';\n\nconst {\n  HTTP2_HEADER_STATUS,\n  HTTP2_HEADER_CONTENT_TYPE,\n  NGHTTP2_CANCEL,\n} = http2.constants;\n\n/**\n * https://nodejs.org/api/errors.html#errors_class_systemerror\n */\ninterface SystemError extends Error {\n  address?: string;\n  code: string;\n  dest?: string;\n  errno: number;\n  info?: object;\n  message: string;\n  path?: string;\n  port?: number;\n  syscall: string;\n}\n\n/**\n * Should do approximately the same thing as util.getSystemErrorName but the\n * TypeScript types don't have that function for some reason so I just made my\n * own.\n * @param errno\n */\nfunction getSystemErrorName(errno: number): string {\n  for (const [name, num] of Object.entries(os.constants.errno)) {\n    if (num === errno) {\n      return name;\n    }\n  }\n  return 'Unknown system error ' + errno;\n}\n\nexport interface SubchannelCall {\n  cancelWithStatus(status: Status, details: string): void;\n  getPeer(): string;\n  sendMessageWithContext(context: MessageContext, message: Buffer): void;\n  startRead(): void;\n  halfClose(): void;\n  getCallNumber(): number;\n}\n\nexport interface StatusObjectWithRstCode extends StatusObject {\n  rstCode?: number;\n}\n\nexport interface SubchannelCallInterceptingListener extends InterceptingListener {\n  onReceiveStatus(status: StatusObjectWithRstCode): void;\n}\n\nexport class Http2SubchannelCall implements SubchannelCall {\n  private decoder = new StreamDecoder();\n\n  private isReadFilterPending = false;\n  private isPushPending = false;\n  private canPush = false;\n  /**\n   * Indicates that an 'end' event has come from the http2 stream, so there\n   * will be no more data events.\n   */\n  private readsClosed = false;\n\n  private statusOutput = false;\n\n  private unpushedReadMessages: Buffer[] = [];\n\n  // Status code mapped from :status. To be used if grpc-status is not received\n  private mappedStatusCode: Status = Status.UNKNOWN;\n\n  // This is populated (non-null) if and only if the call has ended\n  private finalStatus: StatusObject | null = null;\n\n  private internalError: SystemError | null = null;\n\n  constructor(\n    private readonly http2Stream: http2.ClientHttp2Stream,\n    private readonly callEventTracker: CallEventTracker,\n    private readonly listener: SubchannelCallInterceptingListener,\n    private readonly transport: Transport,\n    private readonly callId: number\n  ) {\n    http2Stream.on('response', (headers, flags) => {\n      let headersString = '';\n      for (const header of Object.keys(headers)) {\n        headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n      }\n      this.trace('Received server headers:\\n' + headersString);\n      switch (headers[':status']) {\n        // TODO(murgatroid99): handle 100 and 101\n        case 400:\n          this.mappedStatusCode = Status.INTERNAL;\n          break;\n        case 401:\n          this.mappedStatusCode = Status.UNAUTHENTICATED;\n          break;\n        case 403:\n          this.mappedStatusCode = Status.PERMISSION_DENIED;\n          break;\n        case 404:\n          this.mappedStatusCode = Status.UNIMPLEMENTED;\n          break;\n        case 429:\n        case 502:\n        case 503:\n        case 504:\n          this.mappedStatusCode = Status.UNAVAILABLE;\n          break;\n        default:\n          this.mappedStatusCode = Status.UNKNOWN;\n      }\n\n      if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {\n        this.handleTrailers(headers);\n      } else {\n        let metadata: Metadata;\n        try {\n          metadata = Metadata.fromHttp2Headers(headers);\n        } catch (error) {\n          this.endCall({\n            code: Status.UNKNOWN,\n            details: (error as Error).message,\n            metadata: new Metadata(),\n          });\n          return;\n        }\n        this.listener.onReceiveMetadata(metadata);\n      }\n    });\n    http2Stream.on('trailers', (headers: http2.IncomingHttpHeaders) => {\n      this.handleTrailers(headers);\n    });\n    http2Stream.on('data', (data: Buffer) => {\n      /* If the status has already been output, allow the http2 stream to\n       * drain without processing the data. */\n      if (this.statusOutput) {\n        return;\n      }\n      this.trace('receive HTTP/2 data frame of length ' + data.length);\n      const messages = this.decoder.write(data);\n\n      for (const message of messages) {\n        this.trace('parsed message of length ' + message.length);\n        this.callEventTracker!.addMessageReceived();\n        this.tryPush(message);\n      }\n    });\n    http2Stream.on('end', () => {\n      this.readsClosed = true;\n      this.maybeOutputStatus();\n    });\n    http2Stream.on('close', () => {\n      /* Use process.next tick to ensure that this code happens after any\n       * \"error\" event that may be emitted at about the same time, so that\n       * we can bubble up the error message from that event. */\n      process.nextTick(() => {\n        this.trace('HTTP/2 stream closed with code ' + http2Stream.rstCode);\n        /* If we have a final status with an OK status code, that means that\n         * we have received all of the messages and we have processed the\n         * trailers and the call completed successfully, so it doesn't matter\n         * how the stream ends after that */\n        if (this.finalStatus?.code === Status.OK) {\n          return;\n        }\n        let code: Status;\n        let details = '';\n        switch (http2Stream.rstCode) {\n          case http2.constants.NGHTTP2_NO_ERROR:\n            /* If we get a NO_ERROR code and we already have a status, the\n             * stream completed properly and we just haven't fully processed\n             * it yet */\n            if (this.finalStatus !== null) {\n              return;\n            }\n            code = Status.INTERNAL;\n            details = `Received RST_STREAM with code ${http2Stream.rstCode}`;\n            break;\n          case http2.constants.NGHTTP2_REFUSED_STREAM:\n            code = Status.UNAVAILABLE;\n            details = 'Stream refused by server';\n            break;\n          case http2.constants.NGHTTP2_CANCEL:\n            code = Status.CANCELLED;\n            details = 'Call cancelled';\n            break;\n          case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:\n            code = Status.RESOURCE_EXHAUSTED;\n            details = 'Bandwidth exhausted or memory limit exceeded';\n            break;\n          case http2.constants.NGHTTP2_INADEQUATE_SECURITY:\n            code = Status.PERMISSION_DENIED;\n            details = 'Protocol not secure enough';\n            break;\n          case http2.constants.NGHTTP2_INTERNAL_ERROR:\n            code = Status.INTERNAL;\n            if (this.internalError === null) {\n              /* This error code was previously handled in the default case, and\n               * there are several instances of it online, so I wanted to\n               * preserve the original error message so that people find existing\n               * information in searches, but also include the more recognizable\n               * \"Internal server error\" message. */\n              details = `Received RST_STREAM with code ${http2Stream.rstCode} (Internal server error)`;\n            } else {\n              if (this.internalError.code === 'ECONNRESET' || this.internalError.code === 'ETIMEDOUT') {\n                code = Status.UNAVAILABLE;\n                details = this.internalError.message;\n              } else {\n                /* The \"Received RST_STREAM with code ...\" error is preserved\n                 * here for continuity with errors reported online, but the\n                 * error message at the end will probably be more relevant in\n                 * most cases. */\n                details = `Received RST_STREAM with code ${http2Stream.rstCode} triggered by internal client error: ${this.internalError.message}`;\n              }\n            }\n            break;\n          default:\n            code = Status.INTERNAL;\n            details = `Received RST_STREAM with code ${http2Stream.rstCode}`;\n        }\n        // This is a no-op if trailers were received at all.\n        // This is OK, because status codes emitted here correspond to more\n        // catastrophic issues that prevent us from receiving trailers in the\n        // first place.\n        this.endCall({ code, details, metadata: new Metadata(), rstCode: http2Stream.rstCode });\n      });\n    });\n    http2Stream.on('error', (err: SystemError) => {\n      /* We need an error handler here to stop \"Uncaught Error\" exceptions\n       * from bubbling up. However, errors here should all correspond to\n       * \"close\" events, where we will handle the error more granularly */\n      /* Specifically looking for stream errors that were *not* constructed\n       * from a RST_STREAM response here:\n       * https://github.com/nodejs/node/blob/8b8620d580314050175983402dfddf2674e8e22a/lib/internal/http2/core.js#L2267\n       */\n      if (err.code !== 'ERR_HTTP2_STREAM_ERROR') {\n        this.trace(\n          'Node error event: message=' +\n            err.message +\n            ' code=' +\n            err.code +\n            ' errno=' +\n            getSystemErrorName(err.errno) +\n            ' syscall=' +\n            err.syscall\n        );\n        this.internalError = err;\n      }\n      this.callEventTracker.onStreamEnd(false);\n    });\n  }\n\n  public onDisconnect() {\n    this.endCall({\n      code: Status.UNAVAILABLE,\n      details: 'Connection dropped',\n      metadata: new Metadata(),\n    });\n  }\n\n  private outputStatus() {\n    /* Precondition: this.finalStatus !== null */\n    if (!this.statusOutput) {\n      this.statusOutput = true;\n      this.trace(\n        'ended with status: code=' +\n          this.finalStatus!.code +\n          ' details=\"' +\n          this.finalStatus!.details +\n          '\"'\n      );\n      this.callEventTracker.onCallEnd(this.finalStatus!);\n      /* We delay the actual action of bubbling up the status to insulate the\n       * cleanup code in this class from any errors that may be thrown in the\n       * upper layers as a result of bubbling up the status. In particular,\n       * if the status is not OK, the \"error\" event may be emitted\n       * synchronously at the top level, which will result in a thrown error if\n       * the user does not handle that event. */\n      process.nextTick(() => {\n        this.listener.onReceiveStatus(this.finalStatus!);\n      });\n      /* Leave the http2 stream in flowing state to drain incoming messages, to\n       * ensure that the stream closure completes. The call stream already does\n       * not push more messages after the status is output, so the messages go\n       * nowhere either way. */\n      this.http2Stream.resume();\n    }\n  }\n\n  private trace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      TRACER_NAME,\n      '[' + this.callId + '] ' + text\n    );\n  }\n\n  /**\n   * On first call, emits a 'status' event with the given StatusObject.\n   * Subsequent calls are no-ops.\n   * @param status The status of the call.\n   */\n  private endCall(status: StatusObjectWithRstCode): void {\n    /* If the status is OK and a new status comes in (e.g. from a\n     * deserialization failure), that new status takes priority */\n    if (this.finalStatus === null || this.finalStatus.code === Status.OK) {\n      this.finalStatus = status;\n      this.maybeOutputStatus();\n    }\n    this.destroyHttp2Stream();\n  }\n\n  private maybeOutputStatus() {\n    if (this.finalStatus !== null) {\n      /* The combination check of readsClosed and that the two message buffer\n       * arrays are empty checks that there all incoming data has been fully\n       * processed */\n      if (\n        this.finalStatus.code !== Status.OK ||\n        (this.readsClosed &&\n          this.unpushedReadMessages.length === 0 &&\n          !this.isReadFilterPending &&\n          !this.isPushPending)\n      ) {\n        this.outputStatus();\n      }\n    }\n  }\n\n  private push(message: Buffer): void {\n    this.trace(\n      'pushing to reader message of length ' +\n        (message instanceof Buffer ? message.length : null)\n    );\n    this.canPush = false;\n    this.isPushPending = true;\n    process.nextTick(() => {\n      this.isPushPending = false;\n      /* If we have already output the status any later messages should be\n       * ignored, and can cause out-of-order operation errors higher up in the\n       * stack. Checking as late as possible here to avoid any race conditions.\n       */\n      if (this.statusOutput) {\n        return;\n      }\n      this.listener.onReceiveMessage(message);\n      this.maybeOutputStatus();\n    });\n  }\n\n  private tryPush(messageBytes: Buffer): void {\n    if (this.canPush) {\n      this.http2Stream!.pause();\n      this.push(messageBytes);\n    } else {\n      this.trace(\n        'unpushedReadMessages.push message of length ' + messageBytes.length\n      );\n      this.unpushedReadMessages.push(messageBytes);\n    }\n  }\n\n  private handleTrailers(headers: http2.IncomingHttpHeaders) {\n    this.callEventTracker.onStreamEnd(true);\n    let headersString = '';\n    for (const header of Object.keys(headers)) {\n      headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n    }\n    this.trace('Received server trailers:\\n' + headersString);\n    let metadata: Metadata;\n    try {\n      metadata = Metadata.fromHttp2Headers(headers);\n    } catch (e) {\n      metadata = new Metadata();\n    }\n    const metadataMap = metadata.getMap();\n    let code: Status = this.mappedStatusCode;\n    if (\n      code === Status.UNKNOWN &&\n      typeof metadataMap['grpc-status'] === 'string'\n    ) {\n      const receivedStatus = Number(metadataMap['grpc-status']);\n      if (receivedStatus in Status) {\n        code = receivedStatus;\n        this.trace('received status code ' + receivedStatus + ' from server');\n      }\n      metadata.remove('grpc-status');\n    }\n    let details = '';\n    if (typeof metadataMap['grpc-message'] === 'string') {\n      try {\n        details = decodeURI(metadataMap['grpc-message']);\n      } catch (e) {\n        details = metadataMap['grpc-message'];\n      }\n      metadata.remove('grpc-message');\n      this.trace(\n        'received status details string \"' + details + '\" from server'\n      );\n    }\n    const status: StatusObject = { code, details, metadata };\n    // This is a no-op if the call was already ended when handling headers.\n    this.endCall(status);\n  }\n\n  private destroyHttp2Stream() {\n    // The http2 stream could already have been destroyed if cancelWithStatus\n    // is called in response to an internal http2 error.\n    if (!this.http2Stream.destroyed) {\n      /* If the call has ended with an OK status, communicate that when closing\n       * the stream, partly to avoid a situation in which we detect an error\n       * RST_STREAM as a result after we have the status */\n      let code: number;\n      if (this.finalStatus?.code === Status.OK) {\n        code = http2.constants.NGHTTP2_NO_ERROR;\n      } else {\n        code = http2.constants.NGHTTP2_CANCEL;\n      }\n      this.trace('close http2 stream with code ' + code);\n      this.http2Stream.close(code);\n    }\n  }\n\n  cancelWithStatus(status: Status, details: string): void {\n    this.trace(\n      'cancelWithStatus code: ' + status + ' details: \"' + details + '\"'\n    );\n    this.endCall({ code: status, details, metadata: new Metadata() });\n  }\n\n  getStatus(): StatusObject | null {\n    return this.finalStatus;\n  }\n\n  getPeer(): string {\n    return this.transport.getPeerName();\n  }\n\n  getCallNumber(): number {\n    return this.callId;\n  }\n\n  startRead() {\n    /* If the stream has ended with an error, we should not emit any more\n     * messages and we should communicate that the stream has ended */\n    if (this.finalStatus !== null && this.finalStatus.code !== Status.OK) {\n      this.readsClosed = true;\n      this.maybeOutputStatus();\n      return;\n    }\n    this.canPush = true;\n    if (this.unpushedReadMessages.length > 0) {\n      const nextMessage: Buffer = this.unpushedReadMessages.shift()!;\n      this.push(nextMessage);\n      return;\n    }\n    /* Only resume reading from the http2Stream if we don't have any pending\n      * messages to emit */\n    this.http2Stream.resume();\n  }\n\n  sendMessageWithContext(context: MessageContext, message: Buffer) {\n    this.trace('write() called with message of length ' + message.length);\n    const cb: WriteCallback = (error?: Error | null) => {\n      let code: Status = Status.UNAVAILABLE;\n      if ((error as NodeJS.ErrnoException)?.code === 'ERR_STREAM_WRITE_AFTER_END') {\n        code = Status.INTERNAL;\n      }\n      if (error) {\n        this.cancelWithStatus(code, `Write error: ${error.message}`);\n      }\n      context.callback?.();\n    };\n    this.trace('sending data chunk of length ' + message.length);\n    this.callEventTracker.addMessageSent();\n    try {\n      this.http2Stream!.write(message, cb);\n    } catch (error) {\n      this.endCall({\n        code: Status.UNAVAILABLE,\n        details: `Write failed with error ${(error as Error).message}`,\n        metadata: new Metadata()\n      });\n    }\n  }\n\n  halfClose() {\n    this.trace('end() called');\n    this.trace('calling end() on HTTP/2 stream');\n    this.http2Stream.end();\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}