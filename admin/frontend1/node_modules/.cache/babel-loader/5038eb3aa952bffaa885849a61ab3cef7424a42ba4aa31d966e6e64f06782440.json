{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nvar _a;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setup = exports.OutlierDetectionLoadBalancer = exports.OutlierDetectionLoadBalancingConfig = void 0;\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst constants_1 = require(\"./constants\");\nconst duration_1 = require(\"./duration\");\nconst experimental_1 = require(\"./experimental\");\nconst load_balancer_1 = require(\"./load-balancer\");\nconst load_balancer_child_handler_1 = require(\"./load-balancer-child-handler\");\nconst picker_1 = require(\"./picker\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst subchannel_interface_1 = require(\"./subchannel-interface\");\nconst logging = require(\"./logging\");\nconst TRACER_NAME = 'outlier_detection';\nfunction trace(text) {\n  logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = 'outlier_detection';\nconst OUTLIER_DETECTION_ENABLED = ((_a = process.env.GRPC_EXPERIMENTAL_ENABLE_OUTLIER_DETECTION) !== null && _a !== void 0 ? _a : 'true') === 'true';\nconst defaultSuccessRateEjectionConfig = {\n  stdev_factor: 1900,\n  enforcement_percentage: 100,\n  minimum_hosts: 5,\n  request_volume: 100\n};\nconst defaultFailurePercentageEjectionConfig = {\n  threshold: 85,\n  enforcement_percentage: 100,\n  minimum_hosts: 5,\n  request_volume: 50\n};\nfunction validateFieldType(obj, fieldName, expectedType, objectName) {\n  if (fieldName in obj && typeof obj[fieldName] !== expectedType) {\n    const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n    throw new Error(`outlier detection config ${fullFieldName} parse error: expected ${expectedType}, got ${typeof obj[fieldName]}`);\n  }\n}\nfunction validatePositiveDuration(obj, fieldName, objectName) {\n  const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n  if (fieldName in obj) {\n    if (!(0, duration_1.isDuration)(obj[fieldName])) {\n      throw new Error(`outlier detection config ${fullFieldName} parse error: expected Duration, got ${typeof obj[fieldName]}`);\n    }\n    if (!(obj[fieldName].seconds >= 0 && obj[fieldName].seconds <= 315576000000 && obj[fieldName].nanos >= 0 && obj[fieldName].nanos <= 999999999)) {\n      throw new Error(`outlier detection config ${fullFieldName} parse error: values out of range for non-negative Duaration`);\n    }\n  }\n}\nfunction validatePercentage(obj, fieldName, objectName) {\n  const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n  validateFieldType(obj, fieldName, 'number', objectName);\n  if (fieldName in obj && !(obj[fieldName] >= 0 && obj[fieldName] <= 100)) {\n    throw new Error(`outlier detection config ${fullFieldName} parse error: value out of range for percentage (0-100)`);\n  }\n}\nclass OutlierDetectionLoadBalancingConfig {\n  constructor(intervalMs, baseEjectionTimeMs, maxEjectionTimeMs, maxEjectionPercent, successRateEjection, failurePercentageEjection, childPolicy) {\n    this.childPolicy = childPolicy;\n    this.intervalMs = intervalMs !== null && intervalMs !== void 0 ? intervalMs : 10000;\n    this.baseEjectionTimeMs = baseEjectionTimeMs !== null && baseEjectionTimeMs !== void 0 ? baseEjectionTimeMs : 30000;\n    this.maxEjectionTimeMs = maxEjectionTimeMs !== null && maxEjectionTimeMs !== void 0 ? maxEjectionTimeMs : 300000;\n    this.maxEjectionPercent = maxEjectionPercent !== null && maxEjectionPercent !== void 0 ? maxEjectionPercent : 10;\n    this.successRateEjection = successRateEjection ? Object.assign(Object.assign({}, defaultSuccessRateEjectionConfig), successRateEjection) : null;\n    this.failurePercentageEjection = failurePercentageEjection ? Object.assign(Object.assign({}, defaultFailurePercentageEjectionConfig), failurePercentageEjection) : null;\n  }\n  getLoadBalancerName() {\n    return TYPE_NAME;\n  }\n  toJsonObject() {\n    return {\n      interval: (0, duration_1.msToDuration)(this.intervalMs),\n      base_ejection_time: (0, duration_1.msToDuration)(this.baseEjectionTimeMs),\n      max_ejection_time: (0, duration_1.msToDuration)(this.maxEjectionTimeMs),\n      max_ejection_percent: this.maxEjectionPercent,\n      success_rate_ejection: this.successRateEjection,\n      failure_percentage_ejection: this.failurePercentageEjection,\n      child_policy: this.childPolicy.map(policy => policy.toJsonObject())\n    };\n  }\n  getIntervalMs() {\n    return this.intervalMs;\n  }\n  getBaseEjectionTimeMs() {\n    return this.baseEjectionTimeMs;\n  }\n  getMaxEjectionTimeMs() {\n    return this.maxEjectionTimeMs;\n  }\n  getMaxEjectionPercent() {\n    return this.maxEjectionPercent;\n  }\n  getSuccessRateEjectionConfig() {\n    return this.successRateEjection;\n  }\n  getFailurePercentageEjectionConfig() {\n    return this.failurePercentageEjection;\n  }\n  getChildPolicy() {\n    return this.childPolicy;\n  }\n  copyWithChildPolicy(childPolicy) {\n    return new OutlierDetectionLoadBalancingConfig(this.intervalMs, this.baseEjectionTimeMs, this.maxEjectionTimeMs, this.maxEjectionPercent, this.successRateEjection, this.failurePercentageEjection, childPolicy);\n  }\n  static createFromJson(obj) {\n    var _a;\n    validatePositiveDuration(obj, 'interval');\n    validatePositiveDuration(obj, 'base_ejection_time');\n    validatePositiveDuration(obj, 'max_ejection_time');\n    validatePercentage(obj, 'max_ejection_percent');\n    if ('success_rate_ejection' in obj) {\n      if (typeof obj.success_rate_ejection !== 'object') {\n        throw new Error('outlier detection config success_rate_ejection must be an object');\n      }\n      validateFieldType(obj.success_rate_ejection, 'stdev_factor', 'number', 'success_rate_ejection');\n      validatePercentage(obj.success_rate_ejection, 'enforcement_percentage', 'success_rate_ejection');\n      validateFieldType(obj.success_rate_ejection, 'minimum_hosts', 'number', 'success_rate_ejection');\n      validateFieldType(obj.success_rate_ejection, 'request_volume', 'number', 'success_rate_ejection');\n    }\n    if ('failure_percentage_ejection' in obj) {\n      if (typeof obj.failure_percentage_ejection !== 'object') {\n        throw new Error('outlier detection config failure_percentage_ejection must be an object');\n      }\n      validatePercentage(obj.failure_percentage_ejection, 'threshold', 'failure_percentage_ejection');\n      validatePercentage(obj.failure_percentage_ejection, 'enforcement_percentage', 'failure_percentage_ejection');\n      validateFieldType(obj.failure_percentage_ejection, 'minimum_hosts', 'number', 'failure_percentage_ejection');\n      validateFieldType(obj.failure_percentage_ejection, 'request_volume', 'number', 'failure_percentage_ejection');\n    }\n    return new OutlierDetectionLoadBalancingConfig(obj.interval ? (0, duration_1.durationToMs)(obj.interval) : null, obj.base_ejection_time ? (0, duration_1.durationToMs)(obj.base_ejection_time) : null, obj.max_ejection_time ? (0, duration_1.durationToMs)(obj.max_ejection_time) : null, (_a = obj.max_ejection_percent) !== null && _a !== void 0 ? _a : null, obj.success_rate_ejection, obj.failure_percentage_ejection, obj.child_policy.map(load_balancer_1.validateLoadBalancingConfig));\n  }\n}\nexports.OutlierDetectionLoadBalancingConfig = OutlierDetectionLoadBalancingConfig;\nclass OutlierDetectionSubchannelWrapper extends subchannel_interface_1.BaseSubchannelWrapper {\n  constructor(childSubchannel, mapEntry) {\n    super(childSubchannel);\n    this.mapEntry = mapEntry;\n    this.stateListeners = [];\n    this.ejected = false;\n    this.refCount = 0;\n    this.childSubchannelState = childSubchannel.getConnectivityState();\n    childSubchannel.addConnectivityStateListener((subchannel, previousState, newState, keepaliveTime) => {\n      this.childSubchannelState = newState;\n      if (!this.ejected) {\n        for (const listener of this.stateListeners) {\n          listener(this, previousState, newState, keepaliveTime);\n        }\n      }\n    });\n  }\n  getConnectivityState() {\n    if (this.ejected) {\n      return connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE;\n    } else {\n      return this.childSubchannelState;\n    }\n  }\n  /**\n   * Add a listener function to be called whenever the wrapper's\n   * connectivity state changes.\n   * @param listener\n   */\n  addConnectivityStateListener(listener) {\n    this.stateListeners.push(listener);\n  }\n  /**\n   * Remove a listener previously added with `addConnectivityStateListener`\n   * @param listener A reference to a function previously passed to\n   *     `addConnectivityStateListener`\n   */\n  removeConnectivityStateListener(listener) {\n    const listenerIndex = this.stateListeners.indexOf(listener);\n    if (listenerIndex > -1) {\n      this.stateListeners.splice(listenerIndex, 1);\n    }\n  }\n  ref() {\n    this.child.ref();\n    this.refCount += 1;\n  }\n  unref() {\n    this.child.unref();\n    this.refCount -= 1;\n    if (this.refCount <= 0) {\n      if (this.mapEntry) {\n        const index = this.mapEntry.subchannelWrappers.indexOf(this);\n        if (index >= 0) {\n          this.mapEntry.subchannelWrappers.splice(index, 1);\n        }\n      }\n    }\n  }\n  eject() {\n    this.ejected = true;\n    for (const listener of this.stateListeners) {\n      listener(this, this.childSubchannelState, connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, -1);\n    }\n  }\n  uneject() {\n    this.ejected = false;\n    for (const listener of this.stateListeners) {\n      listener(this, connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, this.childSubchannelState, -1);\n    }\n  }\n  getMapEntry() {\n    return this.mapEntry;\n  }\n  getWrappedSubchannel() {\n    return this.child;\n  }\n}\nfunction createEmptyBucket() {\n  return {\n    success: 0,\n    failure: 0\n  };\n}\nclass CallCounter {\n  constructor() {\n    this.activeBucket = createEmptyBucket();\n    this.inactiveBucket = createEmptyBucket();\n  }\n  addSuccess() {\n    this.activeBucket.success += 1;\n  }\n  addFailure() {\n    this.activeBucket.failure += 1;\n  }\n  switchBuckets() {\n    this.inactiveBucket = this.activeBucket;\n    this.activeBucket = createEmptyBucket();\n  }\n  getLastSuccesses() {\n    return this.inactiveBucket.success;\n  }\n  getLastFailures() {\n    return this.inactiveBucket.failure;\n  }\n}\nclass OutlierDetectionPicker {\n  constructor(wrappedPicker, countCalls) {\n    this.wrappedPicker = wrappedPicker;\n    this.countCalls = countCalls;\n  }\n  pick(pickArgs) {\n    const wrappedPick = this.wrappedPicker.pick(pickArgs);\n    if (wrappedPick.pickResultType === picker_1.PickResultType.COMPLETE) {\n      const subchannelWrapper = wrappedPick.subchannel;\n      const mapEntry = subchannelWrapper.getMapEntry();\n      if (mapEntry) {\n        let onCallEnded = wrappedPick.onCallEnded;\n        if (this.countCalls) {\n          onCallEnded = statusCode => {\n            var _a;\n            if (statusCode === constants_1.Status.OK) {\n              mapEntry.counter.addSuccess();\n            } else {\n              mapEntry.counter.addFailure();\n            }\n            (_a = wrappedPick.onCallEnded) === null || _a === void 0 ? void 0 : _a.call(wrappedPick, statusCode);\n          };\n        }\n        return Object.assign(Object.assign({}, wrappedPick), {\n          subchannel: subchannelWrapper.getWrappedSubchannel(),\n          onCallEnded: onCallEnded\n        });\n      } else {\n        return Object.assign(Object.assign({}, wrappedPick), {\n          subchannel: subchannelWrapper.getWrappedSubchannel()\n        });\n      }\n    } else {\n      return wrappedPick;\n    }\n  }\n}\nclass OutlierDetectionLoadBalancer {\n  constructor(channelControlHelper) {\n    this.addressMap = new Map();\n    this.latestConfig = null;\n    this.timerStartTime = null;\n    this.childBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler((0, experimental_1.createChildChannelControlHelper)(channelControlHelper, {\n      createSubchannel: (subchannelAddress, subchannelArgs) => {\n        const originalSubchannel = channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);\n        const mapEntry = this.addressMap.get((0, subchannel_address_1.subchannelAddressToString)(subchannelAddress));\n        const subchannelWrapper = new OutlierDetectionSubchannelWrapper(originalSubchannel, mapEntry);\n        if ((mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.currentEjectionTimestamp) !== null) {\n          // If the address is ejected, propagate that to the new subchannel wrapper\n          subchannelWrapper.eject();\n        }\n        mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.subchannelWrappers.push(subchannelWrapper);\n        return subchannelWrapper;\n      },\n      updateState: (connectivityState, picker) => {\n        if (connectivityState === connectivity_state_1.ConnectivityState.READY) {\n          channelControlHelper.updateState(connectivityState, new OutlierDetectionPicker(picker, this.isCountingEnabled()));\n        } else {\n          channelControlHelper.updateState(connectivityState, picker);\n        }\n      }\n    }));\n    this.ejectionTimer = setInterval(() => {}, 0);\n    clearInterval(this.ejectionTimer);\n  }\n  isCountingEnabled() {\n    return this.latestConfig !== null && (this.latestConfig.getSuccessRateEjectionConfig() !== null || this.latestConfig.getFailurePercentageEjectionConfig() !== null);\n  }\n  getCurrentEjectionPercent() {\n    let ejectionCount = 0;\n    for (const mapEntry of this.addressMap.values()) {\n      if (mapEntry.currentEjectionTimestamp !== null) {\n        ejectionCount += 1;\n      }\n    }\n    return ejectionCount * 100 / this.addressMap.size;\n  }\n  runSuccessRateCheck(ejectionTimestamp) {\n    if (!this.latestConfig) {\n      return;\n    }\n    const successRateConfig = this.latestConfig.getSuccessRateEjectionConfig();\n    if (!successRateConfig) {\n      return;\n    }\n    trace('Running success rate check');\n    // Step 1\n    const targetRequestVolume = successRateConfig.request_volume;\n    let addresesWithTargetVolume = 0;\n    const successRates = [];\n    for (const [address, mapEntry] of this.addressMap) {\n      const successes = mapEntry.counter.getLastSuccesses();\n      const failures = mapEntry.counter.getLastFailures();\n      trace('Stats for ' + address + ': successes=' + successes + ' failures=' + failures + ' targetRequestVolume=' + targetRequestVolume);\n      if (successes + failures >= targetRequestVolume) {\n        addresesWithTargetVolume += 1;\n        successRates.push(successes / (successes + failures));\n      }\n    }\n    trace('Found ' + addresesWithTargetVolume + ' success rate candidates; currentEjectionPercent=' + this.getCurrentEjectionPercent() + ' successRates=[' + successRates + ']');\n    if (addresesWithTargetVolume < successRateConfig.minimum_hosts) {\n      return;\n    }\n    // Step 2\n    const successRateMean = successRates.reduce((a, b) => a + b) / successRates.length;\n    let successRateDeviationSum = 0;\n    for (const rate of successRates) {\n      const deviation = rate - successRateMean;\n      successRateDeviationSum += deviation * deviation;\n    }\n    const successRateVariance = successRateDeviationSum / successRates.length;\n    const successRateStdev = Math.sqrt(successRateVariance);\n    const ejectionThreshold = successRateMean - successRateStdev * (successRateConfig.stdev_factor / 1000);\n    trace('stdev=' + successRateStdev + ' ejectionThreshold=' + ejectionThreshold);\n    // Step 3\n    for (const [address, mapEntry] of this.addressMap.entries()) {\n      // Step 3.i\n      if (this.getCurrentEjectionPercent() >= this.latestConfig.getMaxEjectionPercent()) {\n        break;\n      }\n      // Step 3.ii\n      const successes = mapEntry.counter.getLastSuccesses();\n      const failures = mapEntry.counter.getLastFailures();\n      if (successes + failures < targetRequestVolume) {\n        continue;\n      }\n      // Step 3.iii\n      const successRate = successes / (successes + failures);\n      trace('Checking candidate ' + address + ' successRate=' + successRate);\n      if (successRate < ejectionThreshold) {\n        const randomNumber = Math.random() * 100;\n        trace('Candidate ' + address + ' randomNumber=' + randomNumber + ' enforcement_percentage=' + successRateConfig.enforcement_percentage);\n        if (randomNumber < successRateConfig.enforcement_percentage) {\n          trace('Ejecting candidate ' + address);\n          this.eject(mapEntry, ejectionTimestamp);\n        }\n      }\n    }\n  }\n  runFailurePercentageCheck(ejectionTimestamp) {\n    if (!this.latestConfig) {\n      return;\n    }\n    const failurePercentageConfig = this.latestConfig.getFailurePercentageEjectionConfig();\n    if (!failurePercentageConfig) {\n      return;\n    }\n    trace('Running failure percentage check. threshold=' + failurePercentageConfig.threshold + ' request volume threshold=' + failurePercentageConfig.request_volume);\n    // Step 1\n    let addressesWithTargetVolume = 0;\n    for (const mapEntry of this.addressMap.values()) {\n      const successes = mapEntry.counter.getLastSuccesses();\n      const failures = mapEntry.counter.getLastFailures();\n      if (successes + failures >= failurePercentageConfig.request_volume) {\n        addressesWithTargetVolume += 1;\n      }\n    }\n    if (addressesWithTargetVolume < failurePercentageConfig.minimum_hosts) {\n      return;\n    }\n    // Step 2\n    for (const [address, mapEntry] of this.addressMap.entries()) {\n      // Step 2.i\n      if (this.getCurrentEjectionPercent() >= this.latestConfig.getMaxEjectionPercent()) {\n        break;\n      }\n      // Step 2.ii\n      const successes = mapEntry.counter.getLastSuccesses();\n      const failures = mapEntry.counter.getLastFailures();\n      trace('Candidate successes=' + successes + ' failures=' + failures);\n      if (successes + failures < failurePercentageConfig.request_volume) {\n        continue;\n      }\n      // Step 2.iii\n      const failurePercentage = failures * 100 / (failures + successes);\n      if (failurePercentage > failurePercentageConfig.threshold) {\n        const randomNumber = Math.random() * 100;\n        trace('Candidate ' + address + ' randomNumber=' + randomNumber + ' enforcement_percentage=' + failurePercentageConfig.enforcement_percentage);\n        if (randomNumber < failurePercentageConfig.enforcement_percentage) {\n          trace('Ejecting candidate ' + address);\n          this.eject(mapEntry, ejectionTimestamp);\n        }\n      }\n    }\n  }\n  eject(mapEntry, ejectionTimestamp) {\n    mapEntry.currentEjectionTimestamp = new Date();\n    mapEntry.ejectionTimeMultiplier += 1;\n    for (const subchannelWrapper of mapEntry.subchannelWrappers) {\n      subchannelWrapper.eject();\n    }\n  }\n  uneject(mapEntry) {\n    mapEntry.currentEjectionTimestamp = null;\n    for (const subchannelWrapper of mapEntry.subchannelWrappers) {\n      subchannelWrapper.uneject();\n    }\n  }\n  switchAllBuckets() {\n    for (const mapEntry of this.addressMap.values()) {\n      mapEntry.counter.switchBuckets();\n    }\n  }\n  startTimer(delayMs) {\n    var _a, _b;\n    this.ejectionTimer = setTimeout(() => this.runChecks(), delayMs);\n    (_b = (_a = this.ejectionTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n  }\n  runChecks() {\n    const ejectionTimestamp = new Date();\n    trace('Ejection timer running');\n    this.switchAllBuckets();\n    if (!this.latestConfig) {\n      return;\n    }\n    this.timerStartTime = ejectionTimestamp;\n    this.startTimer(this.latestConfig.getIntervalMs());\n    this.runSuccessRateCheck(ejectionTimestamp);\n    this.runFailurePercentageCheck(ejectionTimestamp);\n    for (const [address, mapEntry] of this.addressMap.entries()) {\n      if (mapEntry.currentEjectionTimestamp === null) {\n        if (mapEntry.ejectionTimeMultiplier > 0) {\n          mapEntry.ejectionTimeMultiplier -= 1;\n        }\n      } else {\n        const baseEjectionTimeMs = this.latestConfig.getBaseEjectionTimeMs();\n        const maxEjectionTimeMs = this.latestConfig.getMaxEjectionTimeMs();\n        const returnTime = new Date(mapEntry.currentEjectionTimestamp.getTime());\n        returnTime.setMilliseconds(returnTime.getMilliseconds() + Math.min(baseEjectionTimeMs * mapEntry.ejectionTimeMultiplier, Math.max(baseEjectionTimeMs, maxEjectionTimeMs)));\n        if (returnTime < new Date()) {\n          trace('Unejecting ' + address);\n          this.uneject(mapEntry);\n        }\n      }\n    }\n  }\n  updateAddressList(addressList, lbConfig, attributes) {\n    if (!(lbConfig instanceof OutlierDetectionLoadBalancingConfig)) {\n      return;\n    }\n    const subchannelAddresses = new Set();\n    for (const address of addressList) {\n      subchannelAddresses.add((0, subchannel_address_1.subchannelAddressToString)(address));\n    }\n    for (const address of subchannelAddresses) {\n      if (!this.addressMap.has(address)) {\n        trace('Adding map entry for ' + address);\n        this.addressMap.set(address, {\n          counter: new CallCounter(),\n          currentEjectionTimestamp: null,\n          ejectionTimeMultiplier: 0,\n          subchannelWrappers: []\n        });\n      }\n    }\n    for (const key of this.addressMap.keys()) {\n      if (!subchannelAddresses.has(key)) {\n        trace('Removing map entry for ' + key);\n        this.addressMap.delete(key);\n      }\n    }\n    const childPolicy = (0, load_balancer_1.getFirstUsableConfig)(lbConfig.getChildPolicy(), true);\n    this.childBalancer.updateAddressList(addressList, childPolicy, attributes);\n    if (lbConfig.getSuccessRateEjectionConfig() || lbConfig.getFailurePercentageEjectionConfig()) {\n      if (this.timerStartTime) {\n        trace('Previous timer existed. Replacing timer');\n        clearTimeout(this.ejectionTimer);\n        const remainingDelay = lbConfig.getIntervalMs() - (new Date().getTime() - this.timerStartTime.getTime());\n        this.startTimer(remainingDelay);\n      } else {\n        trace('Starting new timer');\n        this.timerStartTime = new Date();\n        this.startTimer(lbConfig.getIntervalMs());\n        this.switchAllBuckets();\n      }\n    } else {\n      trace('Counting disabled. Cancelling timer.');\n      this.timerStartTime = null;\n      clearTimeout(this.ejectionTimer);\n      for (const mapEntry of this.addressMap.values()) {\n        this.uneject(mapEntry);\n        mapEntry.ejectionTimeMultiplier = 0;\n      }\n    }\n    this.latestConfig = lbConfig;\n  }\n  exitIdle() {\n    this.childBalancer.exitIdle();\n  }\n  resetBackoff() {\n    this.childBalancer.resetBackoff();\n  }\n  destroy() {\n    clearTimeout(this.ejectionTimer);\n    this.childBalancer.destroy();\n  }\n  getTypeName() {\n    return TYPE_NAME;\n  }\n}\nexports.OutlierDetectionLoadBalancer = OutlierDetectionLoadBalancer;\nfunction setup() {\n  if (OUTLIER_DETECTION_ENABLED) {\n    (0, experimental_1.registerLoadBalancerType)(TYPE_NAME, OutlierDetectionLoadBalancer, OutlierDetectionLoadBalancingConfig);\n  }\n}\nexports.setup = setup;","map":{"version":3,"mappings":"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","names":["TRACER_NAME","trace","text","logging","constants_1","DEBUG","TYPE_NAME","OUTLIER_DETECTION_ENABLED","env","GRPC_EXPERIMENTAL_ENABLE_OUTLIER_DETECTION","defaultSuccessRateEjectionConfig","stdev_factor","enforcement_percentage","minimum_hosts","request_volume","defaultFailurePercentageEjectionConfig","threshold","validateFieldType","obj","fieldName","expectedType","objectName","fullFieldName","Error","validatePositiveDuration","seconds","nanos","validatePercentage","OutlierDetectionLoadBalancingConfig","constructor","intervalMs","baseEjectionTimeMs","maxEjectionTimeMs","maxEjectionPercent","successRateEjection","failurePercentageEjection","childPolicy","Object","getLoadBalancerName","toJsonObject","interval","base_ejection_time","max_ejection_time","max_ejection_percent","success_rate_ejection","failure_percentage_ejection","child_policy","map","policy","getIntervalMs","getBaseEjectionTimeMs","getMaxEjectionTimeMs","getMaxEjectionPercent","getSuccessRateEjectionConfig","getFailurePercentageEjectionConfig","getChildPolicy","copyWithChildPolicy","createFromJson","load_balancer_1","exports","OutlierDetectionSubchannelWrapper","subchannel_interface_1","childSubchannel","mapEntry","childSubchannelState","getConnectivityState","addConnectivityStateListener","subchannel","previousState","newState","keepaliveTime","ejected","listener","stateListeners","connectivity_state_1","TRANSIENT_FAILURE","push","removeConnectivityStateListener","listenerIndex","indexOf","splice","ref","child","refCount","unref","index","subchannelWrappers","eject","uneject","getMapEntry","getWrappedSubchannel","createEmptyBucket","success","failure","CallCounter","addSuccess","activeBucket","addFailure","switchBuckets","inactiveBucket","getLastSuccesses","getLastFailures","OutlierDetectionPicker","wrappedPicker","countCalls","pick","pickArgs","wrappedPick","pickResultType","picker_1","COMPLETE","subchannelWrapper","onCallEnded","statusCode","OK","counter","OutlierDetectionLoadBalancer","channelControlHelper","Map","childBalancer","load_balancer_child_handler_1","createSubchannel","subchannelAddress","subchannelArgs","originalSubchannel","addressMap","get","currentEjectionTimestamp","updateState","connectivityState","picker","READY","isCountingEnabled","ejectionTimer","setInterval","clearInterval","latestConfig","getCurrentEjectionPercent","ejectionCount","values","size","runSuccessRateCheck","ejectionTimestamp","successRateConfig","targetRequestVolume","addresesWithTargetVolume","successRates","address","successes","failures","successRateMean","reduce","a","b","length","successRateDeviationSum","rate","deviation","successRateVariance","successRateStdev","Math","sqrt","ejectionThreshold","entries","successRate","randomNumber","random","runFailurePercentageCheck","failurePercentageConfig","addressesWithTargetVolume","failurePercentage","Date","ejectionTimeMultiplier","switchAllBuckets","startTimer","delayMs","setTimeout","runChecks","timerStartTime","returnTime","getTime","setMilliseconds","getMilliseconds","min","max","updateAddressList","addressList","lbConfig","attributes","subchannelAddresses","Set","add","has","set","key","keys","delete","clearTimeout","remainingDelay","exitIdle","resetBackoff","destroy","getTypeName","setup"],"sources":["/home/achwak/node_modules/@grpc/grpc-js/src/load-balancer-outlier-detection.ts"],"sourcesContent":["/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { ChannelOptions } from \"./channel-options\";\nimport { ConnectivityState } from \"./connectivity-state\";\nimport { LogVerbosity, Status } from \"./constants\";\nimport { durationToMs, isDuration, msToDuration } from \"./duration\";\nimport { ChannelControlHelper, createChildChannelControlHelper, registerLoadBalancerType } from \"./experimental\";\nimport { BaseFilter, Filter, FilterFactory } from \"./filter\";\nimport { getFirstUsableConfig, LoadBalancer, LoadBalancingConfig, validateLoadBalancingConfig } from \"./load-balancer\";\nimport { ChildLoadBalancerHandler } from \"./load-balancer-child-handler\";\nimport { PickArgs, Picker, PickResult, PickResultType, QueuePicker, UnavailablePicker } from \"./picker\";\nimport { Subchannel } from \"./subchannel\";\nimport { SubchannelAddress, subchannelAddressToString } from \"./subchannel-address\";\nimport { BaseSubchannelWrapper, ConnectivityStateListener, SubchannelInterface } from \"./subchannel-interface\";\nimport * as logging from './logging';\n\nconst TRACER_NAME = 'outlier_detection';\n\nfunction trace(text: string): void {\n  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\nconst TYPE_NAME = 'outlier_detection';\n\nconst OUTLIER_DETECTION_ENABLED = (process.env.GRPC_EXPERIMENTAL_ENABLE_OUTLIER_DETECTION ?? 'true') === 'true';\n\nexport interface SuccessRateEjectionConfig {\n  readonly stdev_factor: number;\n  readonly enforcement_percentage: number;\n  readonly minimum_hosts: number;\n  readonly request_volume: number;\n}\n\nexport interface FailurePercentageEjectionConfig {\n  readonly threshold: number;\n  readonly enforcement_percentage: number;\n  readonly minimum_hosts: number;\n  readonly request_volume: number;\n}\n\nconst defaultSuccessRateEjectionConfig: SuccessRateEjectionConfig = {\n  stdev_factor: 1900,\n  enforcement_percentage: 100,\n  minimum_hosts: 5,\n  request_volume: 100\n};\n\nconst defaultFailurePercentageEjectionConfig: FailurePercentageEjectionConfig = {\n  threshold: 85,\n  enforcement_percentage: 100,\n  minimum_hosts: 5,\n  request_volume: 50\n}\n\ntype TypeofValues = 'object' | 'boolean' | 'function' | 'number' | 'string' | 'undefined';\n\nfunction validateFieldType(obj: any, fieldName: string, expectedType: TypeofValues, objectName?: string) {\n  if (fieldName in obj && typeof obj[fieldName] !== expectedType) {\n    const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n    throw new Error(`outlier detection config ${fullFieldName} parse error: expected ${expectedType}, got ${typeof obj[fieldName]}`);\n  }\n}\n\nfunction validatePositiveDuration(obj: any, fieldName: string, objectName?: string) {\n  const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n  if (fieldName in obj) {\n    if (!isDuration(obj[fieldName])) {\n      throw new Error(`outlier detection config ${fullFieldName} parse error: expected Duration, got ${typeof obj[fieldName]}`);\n    }\n    if (!(obj[fieldName].seconds >= 0 && obj[fieldName].seconds <= 315_576_000_000 && obj[fieldName].nanos >= 0 && obj[fieldName].nanos <= 999_999_999)) {\n      throw new Error(`outlier detection config ${fullFieldName} parse error: values out of range for non-negative Duaration`);\n    }\n  }\n}\n\nfunction validatePercentage(obj: any, fieldName: string, objectName?: string) {\n  const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n  validateFieldType(obj, fieldName, 'number', objectName);\n  if (fieldName in obj && !(obj[fieldName] >= 0 && obj[fieldName] <= 100)) {\n    throw new Error(`outlier detection config ${fullFieldName} parse error: value out of range for percentage (0-100)`);\n  }\n}\n\nexport class OutlierDetectionLoadBalancingConfig implements LoadBalancingConfig {\n  private readonly intervalMs: number;\n  private readonly baseEjectionTimeMs: number;\n  private readonly maxEjectionTimeMs: number;\n  private readonly maxEjectionPercent: number;\n  private readonly successRateEjection: SuccessRateEjectionConfig | null;\n  private readonly failurePercentageEjection: FailurePercentageEjectionConfig | null;\n\n  constructor(\n    intervalMs: number | null,\n    baseEjectionTimeMs: number | null,\n    maxEjectionTimeMs: number | null,\n    maxEjectionPercent: number | null,\n    successRateEjection: Partial<SuccessRateEjectionConfig> | null,\n    failurePercentageEjection: Partial<FailurePercentageEjectionConfig> | null,\n    private readonly childPolicy: LoadBalancingConfig[]\n  ) {\n    this.intervalMs = intervalMs ?? 10_000;\n    this.baseEjectionTimeMs = baseEjectionTimeMs ?? 30_000;\n    this.maxEjectionTimeMs = maxEjectionTimeMs ?? 300_000;\n    this.maxEjectionPercent = maxEjectionPercent ?? 10;\n    this.successRateEjection = successRateEjection ? {...defaultSuccessRateEjectionConfig, ...successRateEjection} : null;\n    this.failurePercentageEjection = failurePercentageEjection ? {...defaultFailurePercentageEjectionConfig, ...failurePercentageEjection}: null;\n  }\n  getLoadBalancerName(): string {\n    return TYPE_NAME;\n  }\n  toJsonObject(): object {\n    return {\n      interval: msToDuration(this.intervalMs),\n      base_ejection_time: msToDuration(this.baseEjectionTimeMs),\n      max_ejection_time: msToDuration(this.maxEjectionTimeMs),\n      max_ejection_percent: this.maxEjectionPercent,\n      success_rate_ejection: this.successRateEjection,\n      failure_percentage_ejection: this.failurePercentageEjection,\n      child_policy: this.childPolicy.map(policy => policy.toJsonObject())\n    };\n  }\n\n  getIntervalMs(): number {\n    return this.intervalMs;\n  }\n  getBaseEjectionTimeMs(): number {\n    return this.baseEjectionTimeMs;\n  }\n  getMaxEjectionTimeMs(): number {\n    return this.maxEjectionTimeMs;\n  }\n  getMaxEjectionPercent(): number {\n    return this.maxEjectionPercent;\n  }\n  getSuccessRateEjectionConfig(): SuccessRateEjectionConfig | null {\n    return this.successRateEjection;\n  }\n  getFailurePercentageEjectionConfig(): FailurePercentageEjectionConfig | null {\n    return this.failurePercentageEjection;\n  }\n  getChildPolicy(): LoadBalancingConfig[] {\n    return this.childPolicy;\n  }\n\n  copyWithChildPolicy(childPolicy: LoadBalancingConfig[]): OutlierDetectionLoadBalancingConfig {\n    return new OutlierDetectionLoadBalancingConfig(this.intervalMs, this.baseEjectionTimeMs, this.maxEjectionTimeMs, this.maxEjectionPercent, this.successRateEjection, this.failurePercentageEjection, childPolicy);\n  }\n\n  static createFromJson(obj: any): OutlierDetectionLoadBalancingConfig {\n    validatePositiveDuration(obj, 'interval');\n    validatePositiveDuration(obj, 'base_ejection_time');\n    validatePositiveDuration(obj, 'max_ejection_time');\n    validatePercentage(obj, 'max_ejection_percent');\n    if ('success_rate_ejection' in obj) {\n      if (typeof obj.success_rate_ejection !== 'object') {\n        throw new Error('outlier detection config success_rate_ejection must be an object');\n      }\n      validateFieldType(obj.success_rate_ejection, 'stdev_factor', 'number', 'success_rate_ejection');\n      validatePercentage(obj.success_rate_ejection, 'enforcement_percentage', 'success_rate_ejection');\n      validateFieldType(obj.success_rate_ejection, 'minimum_hosts', 'number', 'success_rate_ejection');\n      validateFieldType(obj.success_rate_ejection, 'request_volume', 'number', 'success_rate_ejection');\n    }\n    if ('failure_percentage_ejection' in obj) {\n      if (typeof obj.failure_percentage_ejection !== 'object') {\n        throw new Error('outlier detection config failure_percentage_ejection must be an object');\n      }\n      validatePercentage(obj.failure_percentage_ejection, 'threshold', 'failure_percentage_ejection');\n      validatePercentage(obj.failure_percentage_ejection, 'enforcement_percentage', 'failure_percentage_ejection');\n      validateFieldType(obj.failure_percentage_ejection, 'minimum_hosts', 'number', 'failure_percentage_ejection');\n      validateFieldType(obj.failure_percentage_ejection, 'request_volume', 'number', 'failure_percentage_ejection');\n    }\n\n    return new OutlierDetectionLoadBalancingConfig(\n      obj.interval ? durationToMs(obj.interval) : null,\n      obj.base_ejection_time ? durationToMs(obj.base_ejection_time) : null,\n      obj.max_ejection_time ? durationToMs(obj.max_ejection_time) : null,\n      obj.max_ejection_percent ?? null,\n      obj.success_rate_ejection,\n      obj.failure_percentage_ejection,\n      obj.child_policy.map(validateLoadBalancingConfig)\n    );\n  }\n}\n\nclass OutlierDetectionSubchannelWrapper extends BaseSubchannelWrapper implements SubchannelInterface {\n  private childSubchannelState: ConnectivityState;\n  private stateListeners: ConnectivityStateListener[] = [];\n  private ejected: boolean = false;\n  private refCount: number = 0;\n  constructor(childSubchannel: SubchannelInterface, private mapEntry?: MapEntry) {\n    super(childSubchannel);\n    this.childSubchannelState = childSubchannel.getConnectivityState();\n    childSubchannel.addConnectivityStateListener((subchannel, previousState, newState, keepaliveTime) => {\n      this.childSubchannelState = newState;\n      if (!this.ejected) {\n        for (const listener of this.stateListeners) {\n          listener(this, previousState, newState, keepaliveTime);\n        }\n      }\n    });\n  }\n\n  getConnectivityState(): ConnectivityState {\n    if (this.ejected) {\n      return ConnectivityState.TRANSIENT_FAILURE;\n    } else {\n      return this.childSubchannelState;\n    }\n  }\n\n  /**\n   * Add a listener function to be called whenever the wrapper's\n   * connectivity state changes.\n   * @param listener\n   */\n  addConnectivityStateListener(listener: ConnectivityStateListener) {\n    this.stateListeners.push(listener);\n  }\n\n  /**\n   * Remove a listener previously added with `addConnectivityStateListener`\n   * @param listener A reference to a function previously passed to\n   *     `addConnectivityStateListener`\n   */\n  removeConnectivityStateListener(listener: ConnectivityStateListener) {\n    const listenerIndex = this.stateListeners.indexOf(listener);\n    if (listenerIndex > -1) {\n      this.stateListeners.splice(listenerIndex, 1);\n    }\n  }\n\n  ref() {\n    this.child.ref();\n    this.refCount += 1;\n  }\n\n  unref() {\n    this.child.unref();\n    this.refCount -= 1;\n    if (this.refCount <= 0) {\n      if (this.mapEntry) {\n        const index = this.mapEntry.subchannelWrappers.indexOf(this);\n        if (index >= 0) {\n          this.mapEntry.subchannelWrappers.splice(index, 1);\n        }\n      }\n    }\n  }\n\n  eject() {\n    this.ejected = true;\n    for (const listener of this.stateListeners) {\n      listener(this, this.childSubchannelState, ConnectivityState.TRANSIENT_FAILURE, -1);\n    }\n  }\n\n  uneject() {\n    this.ejected = false;\n    for (const listener of this.stateListeners) {\n      listener(this, ConnectivityState.TRANSIENT_FAILURE, this.childSubchannelState, -1);\n    }\n  }\n\n  getMapEntry(): MapEntry | undefined {\n    return this.mapEntry;\n  }\n\n  getWrappedSubchannel(): SubchannelInterface {\n    return this.child;\n  }\n}\n\ninterface CallCountBucket {\n  success: number;\n  failure: number;\n}\n\nfunction createEmptyBucket(): CallCountBucket {\n  return {\n    success: 0,\n    failure: 0\n  }\n}\n\nclass CallCounter {\n  private activeBucket: CallCountBucket = createEmptyBucket();\n  private inactiveBucket: CallCountBucket = createEmptyBucket();\n  addSuccess() {\n    this.activeBucket.success += 1;\n  }\n  addFailure() {\n    this.activeBucket.failure += 1;\n  }\n  switchBuckets() {\n    this.inactiveBucket = this.activeBucket;\n    this.activeBucket = createEmptyBucket();\n  }\n  getLastSuccesses() {\n    return this.inactiveBucket.success;\n  }\n  getLastFailures() {\n    return this.inactiveBucket.failure;\n  }\n}\n\ninterface MapEntry {\n  counter: CallCounter;\n  currentEjectionTimestamp: Date | null;\n  ejectionTimeMultiplier: number;\n  subchannelWrappers: OutlierDetectionSubchannelWrapper[];\n}\n\nclass OutlierDetectionPicker implements Picker {\n  constructor(private wrappedPicker: Picker, private countCalls: boolean) {}\n  pick(pickArgs: PickArgs): PickResult {\n    const wrappedPick = this.wrappedPicker.pick(pickArgs);\n    if (wrappedPick.pickResultType === PickResultType.COMPLETE) {\n      const subchannelWrapper = wrappedPick.subchannel as OutlierDetectionSubchannelWrapper;\n      const mapEntry = subchannelWrapper.getMapEntry();\n      if (mapEntry) {\n        let onCallEnded = wrappedPick.onCallEnded;\n        if (this.countCalls) {\n          onCallEnded = statusCode => {\n            if (statusCode === Status.OK) {\n              mapEntry.counter.addSuccess();\n            } else {\n              mapEntry.counter.addFailure();\n            }\n            wrappedPick.onCallEnded?.(statusCode);\n          };\n        }\n        return {\n          ...wrappedPick,\n          subchannel: subchannelWrapper.getWrappedSubchannel(),\n          onCallEnded: onCallEnded\n        };\n      } else {\n        return {\n          ...wrappedPick,\n          subchannel: subchannelWrapper.getWrappedSubchannel()\n        }\n      }\n    } else {\n      return wrappedPick;\n    }\n  }\n\n}\n\nexport class OutlierDetectionLoadBalancer implements LoadBalancer {\n  private childBalancer: ChildLoadBalancerHandler;\n  private addressMap: Map<string, MapEntry> = new Map<string, MapEntry>();\n  private latestConfig: OutlierDetectionLoadBalancingConfig | null = null;\n  private ejectionTimer: NodeJS.Timer;\n  private timerStartTime: Date | null = null;\n\n  constructor(channelControlHelper: ChannelControlHelper) {\n    this.childBalancer = new ChildLoadBalancerHandler(createChildChannelControlHelper(channelControlHelper, {\n      createSubchannel: (subchannelAddress: SubchannelAddress, subchannelArgs: ChannelOptions) => {\n        const originalSubchannel = channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);\n        const mapEntry = this.addressMap.get(subchannelAddressToString(subchannelAddress));\n        const subchannelWrapper = new OutlierDetectionSubchannelWrapper(originalSubchannel, mapEntry);\n        if (mapEntry?.currentEjectionTimestamp !== null) {\n          // If the address is ejected, propagate that to the new subchannel wrapper\n          subchannelWrapper.eject();\n        }\n        mapEntry?.subchannelWrappers.push(subchannelWrapper);\n        return subchannelWrapper;\n      },\n      updateState: (connectivityState: ConnectivityState, picker: Picker) => {\n        if (connectivityState === ConnectivityState.READY) {\n          channelControlHelper.updateState(connectivityState, new OutlierDetectionPicker(picker, this.isCountingEnabled()));\n        } else {\n          channelControlHelper.updateState(connectivityState, picker);\n        }\n      }\n    }));\n    this.ejectionTimer = setInterval(() => {}, 0);\n    clearInterval(this.ejectionTimer);\n  }\n\n  private isCountingEnabled(): boolean {\n    return this.latestConfig !== null && \n      (this.latestConfig.getSuccessRateEjectionConfig() !== null || \n       this.latestConfig.getFailurePercentageEjectionConfig() !== null);\n  }\n\n  private getCurrentEjectionPercent() {\n    let ejectionCount = 0;\n    for (const mapEntry of this.addressMap.values()) {\n      if (mapEntry.currentEjectionTimestamp !== null) {\n        ejectionCount += 1;\n      }\n    }\n    return (ejectionCount * 100) / this.addressMap.size;\n  }\n\n  private runSuccessRateCheck(ejectionTimestamp: Date) {\n    if (!this.latestConfig) {\n      return;\n    }\n    const successRateConfig = this.latestConfig.getSuccessRateEjectionConfig();\n    if (!successRateConfig) {\n      return;\n    }\n    trace('Running success rate check');\n    // Step 1\n    const targetRequestVolume = successRateConfig.request_volume;\n    let addresesWithTargetVolume = 0;\n    const successRates: number[] = []\n    for (const [address, mapEntry] of this.addressMap) {\n      const successes = mapEntry.counter.getLastSuccesses();\n      const failures = mapEntry.counter.getLastFailures();\n      trace('Stats for ' + address + ': successes=' + successes + ' failures=' + failures + ' targetRequestVolume=' + targetRequestVolume);\n      if (successes + failures >= targetRequestVolume) {\n        addresesWithTargetVolume += 1;\n        successRates.push(successes/(successes + failures));\n      }\n    }\n    trace('Found ' + addresesWithTargetVolume + ' success rate candidates; currentEjectionPercent=' + this.getCurrentEjectionPercent() + ' successRates=[' + successRates + ']');\n    if (addresesWithTargetVolume < successRateConfig.minimum_hosts) {\n      return;\n    }\n\n    // Step 2\n    const successRateMean = successRates.reduce((a, b) => a + b) / successRates.length;\n    let successRateDeviationSum = 0;\n    for (const rate of successRates) {\n      const deviation = rate - successRateMean;\n      successRateDeviationSum += deviation * deviation;\n    }\n    const successRateVariance = successRateDeviationSum / successRates.length;\n    const successRateStdev = Math.sqrt(successRateVariance);\n    const ejectionThreshold = successRateMean - successRateStdev * (successRateConfig.stdev_factor / 1000);\n    trace('stdev=' + successRateStdev + ' ejectionThreshold=' + ejectionThreshold);\n\n    // Step 3\n    for (const [address, mapEntry] of this.addressMap.entries()) {\n      // Step 3.i\n      if (this.getCurrentEjectionPercent() >= this.latestConfig.getMaxEjectionPercent()) {\n        break;\n      }\n      // Step 3.ii\n      const successes = mapEntry.counter.getLastSuccesses();\n      const failures = mapEntry.counter.getLastFailures();\n      if (successes + failures < targetRequestVolume) {\n        continue;\n      }\n      // Step 3.iii\n      const successRate = successes / (successes + failures);\n      trace('Checking candidate ' + address + ' successRate=' + successRate);\n      if (successRate < ejectionThreshold) {\n        const randomNumber = Math.random() * 100;\n        trace('Candidate ' + address + ' randomNumber=' + randomNumber + ' enforcement_percentage=' + successRateConfig.enforcement_percentage);\n        if (randomNumber < successRateConfig.enforcement_percentage) {\n          trace('Ejecting candidate ' + address);\n          this.eject(mapEntry, ejectionTimestamp);\n        }\n      }\n    }\n  }\n\n  private runFailurePercentageCheck(ejectionTimestamp: Date) {\n    if (!this.latestConfig) {\n      return;\n    }\n    const failurePercentageConfig = this.latestConfig.getFailurePercentageEjectionConfig()\n    if (!failurePercentageConfig) {\n      return;\n    }\n    trace('Running failure percentage check. threshold=' + failurePercentageConfig.threshold + ' request volume threshold=' + failurePercentageConfig.request_volume);\n    // Step 1\n    let addressesWithTargetVolume = 0;\n    for (const mapEntry of this.addressMap.values()) {\n      const successes = mapEntry.counter.getLastSuccesses();\n      const failures = mapEntry.counter.getLastFailures();\n      if (successes + failures >= failurePercentageConfig.request_volume) {\n        addressesWithTargetVolume += 1;\n      }\n    }\n    if (addressesWithTargetVolume < failurePercentageConfig.minimum_hosts) {\n      return;\n    }\n    \n    // Step 2\n    for (const [address, mapEntry] of this.addressMap.entries()) {\n      // Step 2.i\n      if (this.getCurrentEjectionPercent() >= this.latestConfig.getMaxEjectionPercent()) {\n        break;\n      }\n      // Step 2.ii\n      const successes = mapEntry.counter.getLastSuccesses();\n      const failures = mapEntry.counter.getLastFailures();\n      trace('Candidate successes=' + successes + ' failures=' + failures);\n      if (successes + failures < failurePercentageConfig.request_volume) {\n        continue;\n      }\n      // Step 2.iii\n      const failurePercentage = (failures * 100) / (failures + successes);\n      if (failurePercentage > failurePercentageConfig.threshold) {\n        const randomNumber = Math.random() * 100;\n        trace('Candidate ' + address + ' randomNumber=' + randomNumber + ' enforcement_percentage=' + failurePercentageConfig.enforcement_percentage);\n        if (randomNumber < failurePercentageConfig.enforcement_percentage) {\n          trace('Ejecting candidate ' + address);\n          this.eject(mapEntry, ejectionTimestamp);\n        }\n      }\n    }\n  }\n\n  private eject(mapEntry: MapEntry, ejectionTimestamp: Date) {\n    mapEntry.currentEjectionTimestamp = new Date();\n    mapEntry.ejectionTimeMultiplier += 1;\n    for (const subchannelWrapper of mapEntry.subchannelWrappers) {\n      subchannelWrapper.eject();\n    }\n  }\n\n  private uneject(mapEntry: MapEntry) {\n    mapEntry.currentEjectionTimestamp = null;\n    for (const subchannelWrapper of mapEntry.subchannelWrappers) {\n      subchannelWrapper.uneject();\n    }\n  }\n\n  private switchAllBuckets() {\n    for (const mapEntry of this.addressMap.values()) {\n      mapEntry.counter.switchBuckets();\n    }\n  }\n\n  private startTimer(delayMs: number) {\n    this.ejectionTimer = setTimeout(() => this.runChecks(), delayMs);\n    this.ejectionTimer.unref?.();\n  }\n\n  private runChecks() {\n    const ejectionTimestamp = new Date();\n    trace('Ejection timer running');\n\n    this.switchAllBuckets();\n\n    if (!this.latestConfig) {\n      return;\n    }\n    this.timerStartTime = ejectionTimestamp;\n    this.startTimer(this.latestConfig.getIntervalMs());\n\n    this.runSuccessRateCheck(ejectionTimestamp);\n    this.runFailurePercentageCheck(ejectionTimestamp);\n\n    for (const [address, mapEntry] of this.addressMap.entries()) {\n      if (mapEntry.currentEjectionTimestamp === null) {\n        if (mapEntry.ejectionTimeMultiplier > 0) {\n          mapEntry.ejectionTimeMultiplier -= 1;\n        }\n      } else {\n        const baseEjectionTimeMs = this.latestConfig.getBaseEjectionTimeMs();\n        const maxEjectionTimeMs = this.latestConfig.getMaxEjectionTimeMs();\n        const returnTime = new Date(mapEntry.currentEjectionTimestamp.getTime());\n        returnTime.setMilliseconds(returnTime.getMilliseconds() + Math.min(baseEjectionTimeMs * mapEntry.ejectionTimeMultiplier, Math.max(baseEjectionTimeMs, maxEjectionTimeMs)));\n        if (returnTime < new Date()) {\n          trace('Unejecting ' + address);\n          this.uneject(mapEntry);\n        }\n      }\n    }\n  }\n\n  updateAddressList(addressList: SubchannelAddress[], lbConfig: LoadBalancingConfig, attributes: { [key: string]: unknown; }): void {\n    if (!(lbConfig instanceof OutlierDetectionLoadBalancingConfig)) {\n      return;\n    }\n    const subchannelAddresses = new Set<string>();\n    for (const address of addressList) {\n      subchannelAddresses.add(subchannelAddressToString(address));\n    }\n    for (const address of subchannelAddresses) {\n      if (!this.addressMap.has(address)) {\n        trace('Adding map entry for ' + address);\n        this.addressMap.set(address, {\n          counter: new CallCounter(),\n          currentEjectionTimestamp: null,\n          ejectionTimeMultiplier: 0,\n          subchannelWrappers: []\n        });\n      }\n    }\n    for (const key of this.addressMap.keys()) {\n      if (!subchannelAddresses.has(key)) {\n        trace('Removing map entry for ' + key);\n        this.addressMap.delete(key);\n      }\n    }\n    const childPolicy: LoadBalancingConfig = getFirstUsableConfig(\n      lbConfig.getChildPolicy(),\n      true\n    );\n    this.childBalancer.updateAddressList(addressList, childPolicy, attributes);\n\n    if (lbConfig.getSuccessRateEjectionConfig() || lbConfig.getFailurePercentageEjectionConfig()) {\n      if (this.timerStartTime) {\n        trace('Previous timer existed. Replacing timer');\n        clearTimeout(this.ejectionTimer);\n        const remainingDelay = lbConfig.getIntervalMs() - ((new Date()).getTime() - this.timerStartTime.getTime());\n        this.startTimer(remainingDelay);\n      } else {\n        trace('Starting new timer');\n        this.timerStartTime = new Date();\n        this.startTimer(lbConfig.getIntervalMs());\n        this.switchAllBuckets();\n      }\n    } else {\n      trace('Counting disabled. Cancelling timer.');\n      this.timerStartTime = null;\n      clearTimeout(this.ejectionTimer);\n      for (const mapEntry of this.addressMap.values()) {\n        this.uneject(mapEntry);\n        mapEntry.ejectionTimeMultiplier = 0;\n      }\n    }\n\n    this.latestConfig = lbConfig;\n  }\n  exitIdle(): void {\n    this.childBalancer.exitIdle();\n  }\n  resetBackoff(): void {\n    this.childBalancer.resetBackoff();\n  }\n  destroy(): void {\n    clearTimeout(this.ejectionTimer);\n    this.childBalancer.destroy();\n  }\n  getTypeName(): string {\n    return TYPE_NAME;\n  }\n}\n\nexport function setup() {\n  if (OUTLIER_DETECTION_ENABLED) {\n    registerLoadBalancerType(TYPE_NAME, OutlierDetectionLoadBalancer, OutlierDetectionLoadBalancingConfig);\n  }\n}"]},"metadata":{},"sourceType":"script","externalDependencies":[]}