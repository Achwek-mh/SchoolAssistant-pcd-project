{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getInterceptingCall = exports.InterceptingCall = exports.RequesterBuilder = exports.ListenerBuilder = exports.InterceptorConfigurationError = void 0;\nconst metadata_1 = require(\"./metadata\");\nconst call_interface_1 = require(\"./call-interface\");\nconst constants_1 = require(\"./constants\");\nconst error_1 = require(\"./error\");\n/**\n * Error class associated with passing both interceptors and interceptor\n * providers to a client constructor or as call options.\n */\nclass InterceptorConfigurationError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'InterceptorConfigurationError';\n    Error.captureStackTrace(this, InterceptorConfigurationError);\n  }\n}\nexports.InterceptorConfigurationError = InterceptorConfigurationError;\nclass ListenerBuilder {\n  constructor() {\n    this.metadata = undefined;\n    this.message = undefined;\n    this.status = undefined;\n  }\n  withOnReceiveMetadata(onReceiveMetadata) {\n    this.metadata = onReceiveMetadata;\n    return this;\n  }\n  withOnReceiveMessage(onReceiveMessage) {\n    this.message = onReceiveMessage;\n    return this;\n  }\n  withOnReceiveStatus(onReceiveStatus) {\n    this.status = onReceiveStatus;\n    return this;\n  }\n  build() {\n    return {\n      onReceiveMetadata: this.metadata,\n      onReceiveMessage: this.message,\n      onReceiveStatus: this.status\n    };\n  }\n}\nexports.ListenerBuilder = ListenerBuilder;\nclass RequesterBuilder {\n  constructor() {\n    this.start = undefined;\n    this.message = undefined;\n    this.halfClose = undefined;\n    this.cancel = undefined;\n  }\n  withStart(start) {\n    this.start = start;\n    return this;\n  }\n  withSendMessage(sendMessage) {\n    this.message = sendMessage;\n    return this;\n  }\n  withHalfClose(halfClose) {\n    this.halfClose = halfClose;\n    return this;\n  }\n  withCancel(cancel) {\n    this.cancel = cancel;\n    return this;\n  }\n  build() {\n    return {\n      start: this.start,\n      sendMessage: this.message,\n      halfClose: this.halfClose,\n      cancel: this.cancel\n    };\n  }\n}\nexports.RequesterBuilder = RequesterBuilder;\n/**\n * A Listener with a default pass-through implementation of each method. Used\n * for filling out Listeners with some methods omitted.\n */\nconst defaultListener = {\n  onReceiveMetadata: (metadata, next) => {\n    next(metadata);\n  },\n  onReceiveMessage: (message, next) => {\n    next(message);\n  },\n  onReceiveStatus: (status, next) => {\n    next(status);\n  }\n};\n/**\n * A Requester with a default pass-through implementation of each method. Used\n * for filling out Requesters with some methods omitted.\n */\nconst defaultRequester = {\n  start: (metadata, listener, next) => {\n    next(metadata, listener);\n  },\n  sendMessage: (message, next) => {\n    next(message);\n  },\n  halfClose: next => {\n    next();\n  },\n  cancel: next => {\n    next();\n  }\n};\nclass InterceptingCall {\n  constructor(nextCall, requester) {\n    var _a, _b, _c, _d;\n    this.nextCall = nextCall;\n    /**\n     * Indicates that metadata has been passed to the requester's start\n     * method but it has not been passed to the corresponding next callback\n     */\n    this.processingMetadata = false;\n    /**\n     * Message context for a pending message that is waiting for\n     */\n    this.pendingMessageContext = null;\n    /**\n     * Indicates that a message has been passed to the requester's sendMessage\n     * method but it has not been passed to the corresponding next callback\n     */\n    this.processingMessage = false;\n    /**\n     * Indicates that a status was received but could not be propagated because\n     * a message was still being processed.\n     */\n    this.pendingHalfClose = false;\n    if (requester) {\n      this.requester = {\n        start: (_a = requester.start) !== null && _a !== void 0 ? _a : defaultRequester.start,\n        sendMessage: (_b = requester.sendMessage) !== null && _b !== void 0 ? _b : defaultRequester.sendMessage,\n        halfClose: (_c = requester.halfClose) !== null && _c !== void 0 ? _c : defaultRequester.halfClose,\n        cancel: (_d = requester.cancel) !== null && _d !== void 0 ? _d : defaultRequester.cancel\n      };\n    } else {\n      this.requester = defaultRequester;\n    }\n  }\n  cancelWithStatus(status, details) {\n    this.requester.cancel(() => {\n      this.nextCall.cancelWithStatus(status, details);\n    });\n  }\n  getPeer() {\n    return this.nextCall.getPeer();\n  }\n  processPendingMessage() {\n    if (this.pendingMessageContext) {\n      this.nextCall.sendMessageWithContext(this.pendingMessageContext, this.pendingMessage);\n      this.pendingMessageContext = null;\n      this.pendingMessage = null;\n    }\n  }\n  processPendingHalfClose() {\n    if (this.pendingHalfClose) {\n      this.nextCall.halfClose();\n    }\n  }\n  start(metadata, interceptingListener) {\n    var _a, _b, _c, _d, _e, _f;\n    const fullInterceptingListener = {\n      onReceiveMetadata: (_b = (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(interceptingListener)) !== null && _b !== void 0 ? _b : metadata => {},\n      onReceiveMessage: (_d = (_c = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _c === void 0 ? void 0 : _c.bind(interceptingListener)) !== null && _d !== void 0 ? _d : message => {},\n      onReceiveStatus: (_f = (_e = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _e === void 0 ? void 0 : _e.bind(interceptingListener)) !== null && _f !== void 0 ? _f : status => {}\n    };\n    this.processingMetadata = true;\n    this.requester.start(metadata, fullInterceptingListener, (md, listener) => {\n      var _a, _b, _c;\n      this.processingMetadata = false;\n      let finalInterceptingListener;\n      if ((0, call_interface_1.isInterceptingListener)(listener)) {\n        finalInterceptingListener = listener;\n      } else {\n        const fullListener = {\n          onReceiveMetadata: (_a = listener.onReceiveMetadata) !== null && _a !== void 0 ? _a : defaultListener.onReceiveMetadata,\n          onReceiveMessage: (_b = listener.onReceiveMessage) !== null && _b !== void 0 ? _b : defaultListener.onReceiveMessage,\n          onReceiveStatus: (_c = listener.onReceiveStatus) !== null && _c !== void 0 ? _c : defaultListener.onReceiveStatus\n        };\n        finalInterceptingListener = new call_interface_1.InterceptingListenerImpl(fullListener, fullInterceptingListener);\n      }\n      this.nextCall.start(md, finalInterceptingListener);\n      this.processPendingMessage();\n      this.processPendingHalfClose();\n    });\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessageWithContext(context, message) {\n    this.processingMessage = true;\n    this.requester.sendMessage(message, finalMessage => {\n      this.processingMessage = false;\n      if (this.processingMetadata) {\n        this.pendingMessageContext = context;\n        this.pendingMessage = message;\n      } else {\n        this.nextCall.sendMessageWithContext(context, finalMessage);\n        this.processPendingHalfClose();\n      }\n    });\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessage(message) {\n    this.sendMessageWithContext({}, message);\n  }\n  startRead() {\n    this.nextCall.startRead();\n  }\n  halfClose() {\n    this.requester.halfClose(() => {\n      if (this.processingMetadata || this.processingMessage) {\n        this.pendingHalfClose = true;\n      } else {\n        this.nextCall.halfClose();\n      }\n    });\n  }\n}\nexports.InterceptingCall = InterceptingCall;\nfunction getCall(channel, path, options) {\n  var _a, _b;\n  const deadline = (_a = options.deadline) !== null && _a !== void 0 ? _a : Infinity;\n  const host = options.host;\n  const parent = (_b = options.parent) !== null && _b !== void 0 ? _b : null;\n  const propagateFlags = options.propagate_flags;\n  const credentials = options.credentials;\n  const call = channel.createCall(path, deadline, host, parent, propagateFlags);\n  if (credentials) {\n    call.setCredentials(credentials);\n  }\n  return call;\n}\n/**\n * InterceptingCall implementation that directly owns the underlying Call\n * object and handles serialization and deseraizliation.\n */\nclass BaseInterceptingCall {\n  constructor(call,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  methodDefinition) {\n    this.call = call;\n    this.methodDefinition = methodDefinition;\n  }\n  cancelWithStatus(status, details) {\n    this.call.cancelWithStatus(status, details);\n  }\n  getPeer() {\n    return this.call.getPeer();\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessageWithContext(context, message) {\n    let serialized;\n    try {\n      serialized = this.methodDefinition.requestSerialize(message);\n    } catch (e) {\n      this.call.cancelWithStatus(constants_1.Status.INTERNAL, `Request message serialization failure: ${(0, error_1.getErrorMessage)(e)}`);\n      return;\n    }\n    this.call.sendMessageWithContext(context, serialized);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessage(message) {\n    this.sendMessageWithContext({}, message);\n  }\n  start(metadata, interceptingListener) {\n    let readError = null;\n    this.call.start(metadata, {\n      onReceiveMetadata: metadata => {\n        var _a;\n        (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, metadata);\n      },\n      onReceiveMessage: message => {\n        var _a;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let deserialized;\n        try {\n          deserialized = this.methodDefinition.responseDeserialize(message);\n        } catch (e) {\n          readError = {\n            code: constants_1.Status.INTERNAL,\n            details: `Response message parsing error: ${(0, error_1.getErrorMessage)(e)}`,\n            metadata: new metadata_1.Metadata()\n          };\n          this.call.cancelWithStatus(readError.code, readError.details);\n          return;\n        }\n        (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, deserialized);\n      },\n      onReceiveStatus: status => {\n        var _a, _b;\n        if (readError) {\n          (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, readError);\n        } else {\n          (_b = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(interceptingListener, status);\n        }\n      }\n    });\n  }\n  startRead() {\n    this.call.startRead();\n  }\n  halfClose() {\n    this.call.halfClose();\n  }\n}\n/**\n * BaseInterceptingCall with special-cased behavior for methods with unary\n * responses.\n */\nclass BaseUnaryInterceptingCall extends BaseInterceptingCall {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(call, methodDefinition) {\n    super(call, methodDefinition);\n  }\n  start(metadata, listener) {\n    var _a, _b;\n    let receivedMessage = false;\n    const wrapperListener = {\n      onReceiveMetadata: (_b = (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(listener)) !== null && _b !== void 0 ? _b : metadata => {},\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      onReceiveMessage: message => {\n        var _a;\n        receivedMessage = true;\n        (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, message);\n      },\n      onReceiveStatus: status => {\n        var _a, _b;\n        if (!receivedMessage) {\n          (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, null);\n        }\n        (_b = listener === null || listener === void 0 ? void 0 : listener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(listener, status);\n      }\n    };\n    super.start(metadata, wrapperListener);\n    this.call.startRead();\n  }\n}\n/**\n * BaseInterceptingCall with special-cased behavior for methods with streaming\n * responses.\n */\nclass BaseStreamingInterceptingCall extends BaseInterceptingCall {}\nfunction getBottomInterceptingCall(channel, options,\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nmethodDefinition) {\n  const call = getCall(channel, methodDefinition.path, options);\n  if (methodDefinition.responseStream) {\n    return new BaseStreamingInterceptingCall(call, methodDefinition);\n  } else {\n    return new BaseUnaryInterceptingCall(call, methodDefinition);\n  }\n}\nfunction getInterceptingCall(interceptorArgs,\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nmethodDefinition, options, channel) {\n  if (interceptorArgs.clientInterceptors.length > 0 && interceptorArgs.clientInterceptorProviders.length > 0) {\n    throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as options ' + 'to the client constructor. Only one of these is allowed.');\n  }\n  if (interceptorArgs.callInterceptors.length > 0 && interceptorArgs.callInterceptorProviders.length > 0) {\n    throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as call ' + 'options. Only one of these is allowed.');\n  }\n  let interceptors = [];\n  // Interceptors passed to the call override interceptors passed to the client constructor\n  if (interceptorArgs.callInterceptors.length > 0 || interceptorArgs.callInterceptorProviders.length > 0) {\n    interceptors = [].concat(interceptorArgs.callInterceptors, interceptorArgs.callInterceptorProviders.map(provider => provider(methodDefinition))).filter(interceptor => interceptor);\n    // Filter out falsy values when providers return nothing\n  } else {\n    interceptors = [].concat(interceptorArgs.clientInterceptors, interceptorArgs.clientInterceptorProviders.map(provider => provider(methodDefinition))).filter(interceptor => interceptor);\n    // Filter out falsy values when providers return nothing\n  }\n\n  const interceptorOptions = Object.assign({}, options, {\n    method_definition: methodDefinition\n  });\n  /* For each interceptor in the list, the nextCall function passed to it is\n   * based on the next interceptor in the list, using a nextCall function\n   * constructed with the following interceptor in the list, and so on. The\n   * initialValue, which is effectively at the end of the list, is a nextCall\n   * function that invokes getBottomInterceptingCall, the result of which\n   * handles (de)serialization and also gets the underlying call from the\n   * channel. */\n  const getCall = interceptors.reduceRight((nextCall, nextInterceptor) => {\n    return currentOptions => nextInterceptor(currentOptions, nextCall);\n  }, finalOptions => getBottomInterceptingCall(channel, finalOptions, methodDefinition));\n  return getCall(interceptorOptions);\n}\nexports.getInterceptingCall = getInterceptingCall;","map":{"version":3,"mappings":";;AAAA;;;;;;;;;;;;;;;;;;;;AAiBA;AACA;AAaA;AAKA;AAEA;;;;AAIA,MAAaA,6BAA8B,SAAQC,KAAK;EACtDC,YAAYC,OAAe;IACzB,KAAK,CAACA,OAAO,CAAC;IACd,IAAI,CAACC,IAAI,GAAG,+BAA+B;IAC3CH,KAAK,CAACI,iBAAiB,CAAC,IAAI,EAAEL,6BAA6B,CAAC;EAC9D;;AALFM;AA4CA,MAAaC,eAAe;EAA5BL;IACU,aAAQ,GAAiCM,SAAS;IAClD,YAAO,GAAgCA,SAAS;IAChD,WAAM,GAA+BA,SAAS;EAwBxD;EAtBEC,qBAAqB,CAACC,iBAAmC;IACvD,IAAI,CAACC,QAAQ,GAAGD,iBAAiB;IACjC,OAAO,IAAI;EACb;EAEAE,oBAAoB,CAACC,gBAAiC;IACpD,IAAI,CAACV,OAAO,GAAGU,gBAAgB;IAC/B,OAAO,IAAI;EACb;EAEAC,mBAAmB,CAACC,eAA+B;IACjD,IAAI,CAACC,MAAM,GAAGD,eAAe;IAC7B,OAAO,IAAI;EACb;EAEAE,KAAK;IACH,OAAO;MACLP,iBAAiB,EAAE,IAAI,CAACC,QAAQ;MAChCE,gBAAgB,EAAE,IAAI,CAACV,OAAO;MAC9BY,eAAe,EAAE,IAAI,CAACC;KACvB;EACH;;AA1BFV;AA6BA,MAAaY,gBAAgB;EAA7BhB;IACU,UAAK,GAAkCM,SAAS;IAChD,YAAO,GAAiCA,SAAS;IACjD,cAAS,GAA+BA,SAAS;IACjD,WAAM,GAAgCA,SAAS;EA8BzD;EA5BEW,SAAS,CAACC,KAAwB;IAChC,IAAI,CAACA,KAAK,GAAGA,KAAK;IAClB,OAAO,IAAI;EACb;EAEAC,eAAe,CAACC,WAA6B;IAC3C,IAAI,CAACnB,OAAO,GAAGmB,WAAW;IAC1B,OAAO,IAAI;EACb;EAEAC,aAAa,CAACC,SAAyB;IACrC,IAAI,CAACA,SAAS,GAAGA,SAAS;IAC1B,OAAO,IAAI;EACb;EAEAC,UAAU,CAACC,MAAuB;IAChC,IAAI,CAACA,MAAM,GAAGA,MAAM;IACpB,OAAO,IAAI;EACb;EAEAT,KAAK;IACH,OAAO;MACLG,KAAK,EAAE,IAAI,CAACA,KAAK;MACjBE,WAAW,EAAE,IAAI,CAACnB,OAAO;MACzBqB,SAAS,EAAE,IAAI,CAACA,SAAS;MACzBE,MAAM,EAAE,IAAI,CAACA;KACd;EACH;;AAjCFpB;AAoCA;;;;AAIA,MAAMqB,eAAe,GAAiB;EACpCjB,iBAAiB,EAAE,CAACC,QAAQ,EAAEiB,IAAI,KAAI;IACpCA,IAAI,CAACjB,QAAQ,CAAC;EAChB,CAAC;EACDE,gBAAgB,EAAE,CAACV,OAAO,EAAEyB,IAAI,KAAI;IAClCA,IAAI,CAACzB,OAAO,CAAC;EACf,CAAC;EACDY,eAAe,EAAE,CAACC,MAAM,EAAEY,IAAI,KAAI;IAChCA,IAAI,CAACZ,MAAM,CAAC;EACd;CACD;AAED;;;;AAIA,MAAMa,gBAAgB,GAAkB;EACtCT,KAAK,EAAE,CAACT,QAAQ,EAAEmB,QAAQ,EAAEF,IAAI,KAAI;IAClCA,IAAI,CAACjB,QAAQ,EAAEmB,QAAQ,CAAC;EAC1B,CAAC;EACDR,WAAW,EAAE,CAACnB,OAAO,EAAEyB,IAAI,KAAI;IAC7BA,IAAI,CAACzB,OAAO,CAAC;EACf,CAAC;EACDqB,SAAS,EAAGI,IAAI,IAAI;IAClBA,IAAI,EAAE;EACR,CAAC;EACDF,MAAM,EAAGE,IAAI,IAAI;IACfA,IAAI,EAAE;EACR;CACD;AAmBD,MAAaG,gBAAgB;EAyB3B7B,YACU8B,QAAmC,EAC3CC,SAAqB;;IADb,aAAQ,GAARD,QAAQ;IArBlB;;;;IAIQ,uBAAkB,GAAG,KAAK;IAClC;;;IAGQ,0BAAqB,GAA0B,IAAI;IAE3D;;;;IAIQ,sBAAiB,GAAG,KAAK;IACjC;;;;IAIQ,qBAAgB,GAAG,KAAK;IAK9B,IAAIC,SAAS,EAAE;MACb,IAAI,CAACA,SAAS,GAAG;QACfb,KAAK,EAAE,eAAS,CAACA,KAAK,mCAAIS,gBAAgB,CAACT,KAAK;QAChDE,WAAW,EAAE,eAAS,CAACA,WAAW,mCAAIO,gBAAgB,CAACP,WAAW;QAClEE,SAAS,EAAE,eAAS,CAACA,SAAS,mCAAIK,gBAAgB,CAACL,SAAS;QAC5DE,MAAM,EAAE,eAAS,CAACA,MAAM,mCAAIG,gBAAgB,CAACH;OAC9C;KACF,MAAM;MACL,IAAI,CAACO,SAAS,GAAGJ,gBAAgB;;EAErC;EAEAK,gBAAgB,CAAClB,MAAc,EAAEmB,OAAe;IAC9C,IAAI,CAACF,SAAS,CAACP,MAAM,CAAC,MAAK;MACzB,IAAI,CAACM,QAAQ,CAACE,gBAAgB,CAAClB,MAAM,EAAEmB,OAAO,CAAC;IACjD,CAAC,CAAC;EACJ;EAEAC,OAAO;IACL,OAAO,IAAI,CAACJ,QAAQ,CAACI,OAAO,EAAE;EAChC;EAEQC,qBAAqB;IAC3B,IAAI,IAAI,CAACC,qBAAqB,EAAE;MAC9B,IAAI,CAACN,QAAQ,CAACO,sBAAsB,CAAC,IAAI,CAACD,qBAAqB,EAAE,IAAI,CAACE,cAAc,CAAC;MACrF,IAAI,CAACF,qBAAqB,GAAG,IAAI;MACjC,IAAI,CAACE,cAAc,GAAG,IAAI;;EAE9B;EAEQC,uBAAuB;IAC7B,IAAI,IAAI,CAACC,gBAAgB,EAAE;MACzB,IAAI,CAACV,QAAQ,CAACR,SAAS,EAAE;;EAE7B;EAEAJ,KAAK,CACHT,QAAkB,EAClBgC,oBAAoD;;IAEpD,MAAMC,wBAAwB,GAAyB;MACrDlC,iBAAiB,EACf,gCAAoB,aAApBiC,oBAAoB,uBAApBA,oBAAoB,CAAEjC,iBAAiB,0CAAEmC,IAAI,CAACF,oBAAoB,CAAC,mCACjEhC,QAAQ,IAAI,CAAE,CAAE;MACpBE,gBAAgB,EACd,gCAAoB,aAApB8B,oBAAoB,uBAApBA,oBAAoB,CAAE9B,gBAAgB,0CAAEgC,IAAI,CAACF,oBAAoB,CAAC,mCAChExC,OAAO,IAAI,CAAE,CAAE;MACnBY,eAAe,EACb,gCAAoB,aAApB4B,oBAAoB,uBAApBA,oBAAoB,CAAE5B,eAAe,0CAAE8B,IAAI,CAACF,oBAAoB,CAAC,mCAC/D3B,MAAM,IAAI,CAAE;KACjB;IACD,IAAI,CAAC8B,kBAAkB,GAAG,IAAI;IAC9B,IAAI,CAACb,SAAS,CAACb,KAAK,CAACT,QAAQ,EAAEiC,wBAAwB,EAAE,CAACG,EAAE,EAAEjB,QAAQ,KAAI;;MACxE,IAAI,CAACgB,kBAAkB,GAAG,KAAK;MAC/B,IAAIE,yBAA+C;MACnD,IAAI,2CAAsB,EAAClB,QAAQ,CAAC,EAAE;QACpCkB,yBAAyB,GAAGlB,QAAQ;OACrC,MAAM;QACL,MAAMmB,YAAY,GAAiB;UACjCvC,iBAAiB,EACf,cAAQ,CAACA,iBAAiB,mCAAIiB,eAAe,CAACjB,iBAAiB;UACjEG,gBAAgB,EACd,cAAQ,CAACA,gBAAgB,mCAAIc,eAAe,CAACd,gBAAgB;UAC/DE,eAAe,EACb,cAAQ,CAACA,eAAe,mCAAIY,eAAe,CAACZ;SAC/C;QACDiC,yBAAyB,GAAG,IAAIE,yCAAwB,CACtDD,YAAY,EACZL,wBAAwB,CACzB;;MAEH,IAAI,CAACZ,QAAQ,CAACZ,KAAK,CAAC2B,EAAE,EAAEC,yBAAyB,CAAC;MAClD,IAAI,CAACX,qBAAqB,EAAE;MAC5B,IAAI,CAACI,uBAAuB,EAAE;IAChC,CAAC,CAAC;EACJ;EACA;EACAF,sBAAsB,CAACY,OAAuB,EAAEhD,OAAY;IAC1D,IAAI,CAACiD,iBAAiB,GAAG,IAAI;IAC7B,IAAI,CAACnB,SAAS,CAACX,WAAW,CAACnB,OAAO,EAAGkD,YAAY,IAAI;MACnD,IAAI,CAACD,iBAAiB,GAAG,KAAK;MAC9B,IAAI,IAAI,CAACN,kBAAkB,EAAE;QAC3B,IAAI,CAACR,qBAAqB,GAAGa,OAAO;QACpC,IAAI,CAACX,cAAc,GAAGrC,OAAO;OAC9B,MAAM;QACL,IAAI,CAAC6B,QAAQ,CAACO,sBAAsB,CAACY,OAAO,EAAEE,YAAY,CAAC;QAC3D,IAAI,CAACZ,uBAAuB,EAAE;;IAElC,CAAC,CAAC;EACJ;EACA;EACAnB,WAAW,CAACnB,OAAY;IACtB,IAAI,CAACoC,sBAAsB,CAAC,EAAE,EAAEpC,OAAO,CAAC;EAC1C;EACAmD,SAAS;IACP,IAAI,CAACtB,QAAQ,CAACsB,SAAS,EAAE;EAC3B;EACA9B,SAAS;IACP,IAAI,CAACS,SAAS,CAACT,SAAS,CAAC,MAAK;MAC5B,IAAI,IAAI,CAACsB,kBAAkB,IAAI,IAAI,CAACM,iBAAiB,EAAE;QACrD,IAAI,CAACV,gBAAgB,GAAG,IAAI;OAC7B,MAAM;QACL,IAAI,CAACV,QAAQ,CAACR,SAAS,EAAE;;IAE7B,CAAC,CAAC;EACJ;;AAtIFlB;AAyIA,SAASiD,OAAO,CAACC,OAAgB,EAAEC,IAAY,EAAEC,OAAoB;;EACnE,MAAMC,QAAQ,GAAG,aAAO,CAACA,QAAQ,mCAAIC,QAAQ;EAC7C,MAAMC,IAAI,GAAGH,OAAO,CAACG,IAAI;EACzB,MAAMC,MAAM,GAAG,aAAO,CAACA,MAAM,mCAAI,IAAI;EACrC,MAAMC,cAAc,GAAGL,OAAO,CAACM,eAAe;EAC9C,MAAMC,WAAW,GAAGP,OAAO,CAACO,WAAW;EACvC,MAAMC,IAAI,GAAGV,OAAO,CAACW,UAAU,CAACV,IAAI,EAAEE,QAAQ,EAAEE,IAAI,EAAEC,MAAM,EAAEC,cAAc,CAAC;EAC7E,IAAIE,WAAW,EAAE;IACfC,IAAI,CAACE,cAAc,CAACH,WAAW,CAAC;;EAElC,OAAOC,IAAI;AACb;AAEA;;;;AAIA,MAAMG,oBAAoB;EACxBnE,YACYgE,IAAU;EACpB;EACUI,gBAAkD;IAFlD,SAAI,GAAJJ,IAAI;IAEJ,qBAAgB,GAAhBI,gBAAgB;EACzB;EACHpC,gBAAgB,CAAClB,MAAc,EAAEmB,OAAe;IAC9C,IAAI,CAAC+B,IAAI,CAAChC,gBAAgB,CAAClB,MAAM,EAAEmB,OAAO,CAAC;EAC7C;EACAC,OAAO;IACL,OAAO,IAAI,CAAC8B,IAAI,CAAC9B,OAAO,EAAE;EAC5B;EACA;EACAG,sBAAsB,CAACY,OAAuB,EAAEhD,OAAY;IAC1D,IAAIoE,UAAkB;IACtB,IAAI;MACFA,UAAU,GAAG,IAAI,CAACD,gBAAgB,CAACE,gBAAgB,CAACrE,OAAO,CAAC;KAC7D,CAAC,OAAOsE,CAAC,EAAE;MACV,IAAI,CAACP,IAAI,CAAChC,gBAAgB,CACxBwC,kBAAM,CAACC,QAAQ,EACf,0CAA0C,2BAAe,EAACF,CAAC,CAAC,EAAE,CAC/D;MACD;;IAEF,IAAI,CAACP,IAAI,CAAC3B,sBAAsB,CAACY,OAAO,EAAEoB,UAAU,CAAC;EACvD;EACA;EACAjD,WAAW,CAACnB,OAAY;IACtB,IAAI,CAACoC,sBAAsB,CAAC,EAAE,EAAEpC,OAAO,CAAC;EAC1C;EACAiB,KAAK,CACHT,QAAkB,EAClBgC,oBAAoD;IAEpD,IAAIiC,SAAS,GAAwB,IAAI;IACzC,IAAI,CAACV,IAAI,CAAC9C,KAAK,CAACT,QAAQ,EAAE;MACxBD,iBAAiB,EAAGC,QAAQ,IAAI;;QAC9B,0BAAoB,aAApBgC,oBAAoB,uBAApBA,oBAAoB,CAAEjC,iBAAiB,qEAAGC,QAAQ,CAAC;MACrD,CAAC;MACDE,gBAAgB,EAAGV,OAAO,IAAI;;QAC5B;QACA,IAAI0E,YAAiB;QACrB,IAAI;UACFA,YAAY,GAAG,IAAI,CAACP,gBAAgB,CAACQ,mBAAmB,CAAC3E,OAAO,CAAC;SAClE,CAAC,OAAOsE,CAAC,EAAE;UACVG,SAAS,GAAG;YACVG,IAAI,EAAEL,kBAAM,CAACC,QAAQ;YACrBxC,OAAO,EAAE,mCAAmC,2BAAe,EAACsC,CAAC,CAAC,EAAE;YAChE9D,QAAQ,EAAE,IAAIqE,mBAAQ;WACvB;UACD,IAAI,CAACd,IAAI,CAAChC,gBAAgB,CAAC0C,SAAS,CAACG,IAAI,EAAEH,SAAS,CAACzC,OAAO,CAAC;UAC7D;;QAEF,0BAAoB,aAApBQ,oBAAoB,uBAApBA,oBAAoB,CAAE9B,gBAAgB,qEAAGgE,YAAY,CAAC;MACxD,CAAC;MACD9D,eAAe,EAAGC,MAAM,IAAI;;QAC1B,IAAI4D,SAAS,EAAE;UACb,0BAAoB,aAApBjC,oBAAoB,uBAApBA,oBAAoB,CAAE5B,eAAe,qEAAG6D,SAAS,CAAC;SACnD,MAAM;UACL,0BAAoB,aAApBjC,oBAAoB,uBAApBA,oBAAoB,CAAE5B,eAAe,qEAAGC,MAAM,CAAC;;MAEnD;KACD,CAAC;EACJ;EACAsC,SAAS;IACP,IAAI,CAACY,IAAI,CAACZ,SAAS,EAAE;EACvB;EACA9B,SAAS;IACP,IAAI,CAAC0C,IAAI,CAAC1C,SAAS,EAAE;EACvB;;AAGF;;;;AAIA,MAAMyD,yBACJ,SAAQZ,oBAAoB;EAE5B;EACAnE,YAAYgE,IAAU,EAAEI,gBAAkD;IACxE,KAAK,CAACJ,IAAI,EAAEI,gBAAgB,CAAC;EAC/B;EACAlD,KAAK,CAACT,QAAkB,EAAEmB,QAAwC;;IAChE,IAAIoD,eAAe,GAAG,KAAK;IAC3B,MAAMC,eAAe,GAAyB;MAC5CzE,iBAAiB,EACf,oBAAQ,aAARoB,QAAQ,uBAARA,QAAQ,CAAEpB,iBAAiB,0CAAEmC,IAAI,CAACf,QAAQ,CAAC,mCAAMnB,QAAQ,IAAI,CAAE,CAAE;MACnE;MACAE,gBAAgB,EAAGV,OAAY,IAAI;;QACjC+E,eAAe,GAAG,IAAI;QACtB,cAAQ,aAARpD,QAAQ,uBAARA,QAAQ,CAAEjB,gBAAgB,yDAAGV,OAAO,CAAC;MACvC,CAAC;MACDY,eAAe,EAAGC,MAAoB,IAAI;;QACxC,IAAI,CAACkE,eAAe,EAAE;UACpB,cAAQ,aAARpD,QAAQ,uBAARA,QAAQ,CAAEjB,gBAAgB,yDAAG,IAAI,CAAC;;QAEpC,cAAQ,aAARiB,QAAQ,uBAARA,QAAQ,CAAEf,eAAe,yDAAGC,MAAM,CAAC;MACrC;KACD;IACD,KAAK,CAACI,KAAK,CAACT,QAAQ,EAAEwE,eAAe,CAAC;IACtC,IAAI,CAACjB,IAAI,CAACZ,SAAS,EAAE;EACvB;;AAGF;;;;AAIA,MAAM8B,6BACJ,SAAQf,oBAAoB;AAG9B,SAASgB,yBAAyB,CAChC7B,OAAgB,EAChBE,OAA2B;AAC3B;AACAY,gBAAkD;EAElD,MAAMJ,IAAI,GAAGX,OAAO,CAACC,OAAO,EAAEc,gBAAgB,CAACb,IAAI,EAAEC,OAAO,CAAC;EAC7D,IAAIY,gBAAgB,CAACgB,cAAc,EAAE;IACnC,OAAO,IAAIF,6BAA6B,CAAClB,IAAI,EAAEI,gBAAgB,CAAC;GACjE,MAAM;IACL,OAAO,IAAIW,yBAAyB,CAACf,IAAI,EAAEI,gBAAgB,CAAC;;AAEhE;AAsBA,SAAgBiB,mBAAmB,CACjCC,eAAqC;AACrC;AACAlB,gBAAkD,EAClDZ,OAAoB,EACpBF,OAAgB;EAEhB,IACEgC,eAAe,CAACC,kBAAkB,CAACC,MAAM,GAAG,CAAC,IAC7CF,eAAe,CAACG,0BAA0B,CAACD,MAAM,GAAG,CAAC,EACrD;IACA,MAAM,IAAI1F,6BAA6B,CACrC,qEAAqE,GACnE,0DAA0D,CAC7D;;EAEH,IACEwF,eAAe,CAACI,gBAAgB,CAACF,MAAM,GAAG,CAAC,IAC3CF,eAAe,CAACK,wBAAwB,CAACH,MAAM,GAAG,CAAC,EACnD;IACA,MAAM,IAAI1F,6BAA6B,CACrC,kEAAkE,GAChE,wCAAwC,CAC3C;;EAEH,IAAI8F,YAAY,GAAkB,EAAE;EACpC;EACA,IACEN,eAAe,CAACI,gBAAgB,CAACF,MAAM,GAAG,CAAC,IAC3CF,eAAe,CAACK,wBAAwB,CAACH,MAAM,GAAG,CAAC,EACnD;IACAI,YAAY,GAAI,EAAoB,CACjCC,MAAM,CACLP,eAAe,CAACI,gBAAgB,EAChCJ,eAAe,CAACK,wBAAwB,CAACG,GAAG,CAAEC,QAAQ,IACpDA,QAAQ,CAAC3B,gBAAgB,CAAC,CAC3B,CACF,CACA4B,MAAM,CAAEC,WAAW,IAAKA,WAAW,CAAC;IACvC;GACD,MAAM;IACLL,YAAY,GAAI,EAAoB,CACjCC,MAAM,CACLP,eAAe,CAACC,kBAAkB,EAClCD,eAAe,CAACG,0BAA0B,CAACK,GAAG,CAAEC,QAAQ,IACtDA,QAAQ,CAAC3B,gBAAgB,CAAC,CAC3B,CACF,CACA4B,MAAM,CAAEC,WAAW,IAAKA,WAAW,CAAC;IACvC;;;EAEF,MAAMC,kBAAkB,GAAGC,MAAM,CAACC,MAAM,CAAC,EAAE,EAAE5C,OAAO,EAAE;IACpD6C,iBAAiB,EAAEjC;GACpB,CAAC;EACF;;;;;;;EAOA,MAAMf,OAAO,GAAauC,YAAY,CAACU,WAAW,CAChD,CAACxE,QAAkB,EAAEyE,eAA4B,KAAI;IACnD,OAAQC,cAAc,IAAKD,eAAe,CAACC,cAAc,EAAE1E,QAAQ,CAAC;EACtE,CAAC,EACA2E,YAAgC,IAC/BtB,yBAAyB,CAAC7B,OAAO,EAAEmD,YAAY,EAAErC,gBAAgB,CAAC,CACrE;EACD,OAAOf,OAAO,CAAC6C,kBAAkB,CAAC;AACpC;AArEA9F","names":["InterceptorConfigurationError","Error","constructor","message","name","captureStackTrace","exports","ListenerBuilder","undefined","withOnReceiveMetadata","onReceiveMetadata","metadata","withOnReceiveMessage","onReceiveMessage","withOnReceiveStatus","onReceiveStatus","status","build","RequesterBuilder","withStart","start","withSendMessage","sendMessage","withHalfClose","halfClose","withCancel","cancel","defaultListener","next","defaultRequester","listener","InterceptingCall","nextCall","requester","cancelWithStatus","details","getPeer","processPendingMessage","pendingMessageContext","sendMessageWithContext","pendingMessage","processPendingHalfClose","pendingHalfClose","interceptingListener","fullInterceptingListener","bind","processingMetadata","md","finalInterceptingListener","fullListener","call_interface_1","context","processingMessage","finalMessage","startRead","getCall","channel","path","options","deadline","Infinity","host","parent","propagateFlags","propagate_flags","credentials","call","createCall","setCredentials","BaseInterceptingCall","methodDefinition","serialized","requestSerialize","e","constants_1","INTERNAL","readError","deserialized","responseDeserialize","code","metadata_1","BaseUnaryInterceptingCall","receivedMessage","wrapperListener","BaseStreamingInterceptingCall","getBottomInterceptingCall","responseStream","getInterceptingCall","interceptorArgs","clientInterceptors","length","clientInterceptorProviders","callInterceptors","callInterceptorProviders","interceptors","concat","map","provider","filter","interceptor","interceptorOptions","Object","assign","method_definition","reduceRight","nextInterceptor","currentOptions","finalOptions"],"sources":["/home/achwak/node_modules/@grpc/grpc-js/src/client-interceptors.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { Metadata } from './metadata';\nimport {\n  StatusObject,\n  Listener,\n  MetadataListener,\n  MessageListener,\n  StatusListener,\n  FullListener,\n  InterceptingListener,\n  InterceptingListenerImpl,\n  isInterceptingListener,\n  MessageContext,\n  Call,\n} from './call-interface';\nimport { Status } from './constants';\nimport { Channel } from './channel';\nimport { CallOptions } from './client';\nimport { CallCredentials } from './call-credentials';\nimport { ClientMethodDefinition } from './make-client';\nimport { getErrorMessage } from './error';\n\n/**\n * Error class associated with passing both interceptors and interceptor\n * providers to a client constructor or as call options.\n */\nexport class InterceptorConfigurationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'InterceptorConfigurationError';\n    Error.captureStackTrace(this, InterceptorConfigurationError);\n  }\n}\n\nexport interface MetadataRequester {\n  (\n    metadata: Metadata,\n    listener: InterceptingListener,\n    next: (\n      metadata: Metadata,\n      listener: InterceptingListener | Listener\n    ) => void\n  ): void;\n}\n\nexport interface MessageRequester {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (message: any, next: (message: any) => void): void;\n}\n\nexport interface CloseRequester {\n  (next: () => void): void;\n}\n\nexport interface CancelRequester {\n  (next: () => void): void;\n}\n\n/**\n * An object with methods for intercepting and modifying outgoing call operations.\n */\nexport interface FullRequester {\n  start: MetadataRequester;\n  sendMessage: MessageRequester;\n  halfClose: CloseRequester;\n  cancel: CancelRequester;\n}\n\nexport type Requester = Partial<FullRequester>;\n\nexport class ListenerBuilder {\n  private metadata: MetadataListener | undefined = undefined;\n  private message: MessageListener | undefined = undefined;\n  private status: StatusListener | undefined = undefined;\n\n  withOnReceiveMetadata(onReceiveMetadata: MetadataListener): this {\n    this.metadata = onReceiveMetadata;\n    return this;\n  }\n\n  withOnReceiveMessage(onReceiveMessage: MessageListener): this {\n    this.message = onReceiveMessage;\n    return this;\n  }\n\n  withOnReceiveStatus(onReceiveStatus: StatusListener): this {\n    this.status = onReceiveStatus;\n    return this;\n  }\n\n  build(): Listener {\n    return {\n      onReceiveMetadata: this.metadata,\n      onReceiveMessage: this.message,\n      onReceiveStatus: this.status,\n    };\n  }\n}\n\nexport class RequesterBuilder {\n  private start: MetadataRequester | undefined = undefined;\n  private message: MessageRequester | undefined = undefined;\n  private halfClose: CloseRequester | undefined = undefined;\n  private cancel: CancelRequester | undefined = undefined;\n\n  withStart(start: MetadataRequester): this {\n    this.start = start;\n    return this;\n  }\n\n  withSendMessage(sendMessage: MessageRequester): this {\n    this.message = sendMessage;\n    return this;\n  }\n\n  withHalfClose(halfClose: CloseRequester): this {\n    this.halfClose = halfClose;\n    return this;\n  }\n\n  withCancel(cancel: CancelRequester): this {\n    this.cancel = cancel;\n    return this;\n  }\n\n  build(): Requester {\n    return {\n      start: this.start,\n      sendMessage: this.message,\n      halfClose: this.halfClose,\n      cancel: this.cancel,\n    };\n  }\n}\n\n/**\n * A Listener with a default pass-through implementation of each method. Used\n * for filling out Listeners with some methods omitted.\n */\nconst defaultListener: FullListener = {\n  onReceiveMetadata: (metadata, next) => {\n    next(metadata);\n  },\n  onReceiveMessage: (message, next) => {\n    next(message);\n  },\n  onReceiveStatus: (status, next) => {\n    next(status);\n  },\n};\n\n/**\n * A Requester with a default pass-through implementation of each method. Used\n * for filling out Requesters with some methods omitted.\n */\nconst defaultRequester: FullRequester = {\n  start: (metadata, listener, next) => {\n    next(metadata, listener);\n  },\n  sendMessage: (message, next) => {\n    next(message);\n  },\n  halfClose: (next) => {\n    next();\n  },\n  cancel: (next) => {\n    next();\n  },\n};\n\nexport interface InterceptorOptions extends CallOptions {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  method_definition: ClientMethodDefinition<any, any>;\n}\n\nexport interface InterceptingCallInterface {\n  cancelWithStatus(status: Status, details: string): void;\n  getPeer(): string;\n  start(metadata: Metadata, listener?: Partial<InterceptingListener>): void;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessageWithContext(context: MessageContext, message: any): void;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessage(message: any): void;\n  startRead(): void;\n  halfClose(): void;\n}\n\nexport class InterceptingCall implements InterceptingCallInterface {\n  /**\n   * The requester that this InterceptingCall uses to modify outgoing operations\n   */\n  private requester: FullRequester;\n  /**\n   * Indicates that metadata has been passed to the requester's start\n   * method but it has not been passed to the corresponding next callback\n   */\n  private processingMetadata = false;\n  /**\n   * Message context for a pending message that is waiting for\n   */\n  private pendingMessageContext: MessageContext | null = null;\n  private pendingMessage: any;\n  /**\n   * Indicates that a message has been passed to the requester's sendMessage\n   * method but it has not been passed to the corresponding next callback\n   */\n  private processingMessage = false;\n  /**\n   * Indicates that a status was received but could not be propagated because\n   * a message was still being processed.\n   */\n  private pendingHalfClose = false;\n  constructor(\n    private nextCall: InterceptingCallInterface,\n    requester?: Requester\n  ) {\n    if (requester) {\n      this.requester = {\n        start: requester.start ?? defaultRequester.start,\n        sendMessage: requester.sendMessage ?? defaultRequester.sendMessage,\n        halfClose: requester.halfClose ?? defaultRequester.halfClose,\n        cancel: requester.cancel ?? defaultRequester.cancel,\n      };\n    } else {\n      this.requester = defaultRequester;\n    }\n  }\n\n  cancelWithStatus(status: Status, details: string) {\n    this.requester.cancel(() => {\n      this.nextCall.cancelWithStatus(status, details);\n    });\n  }\n\n  getPeer() {\n    return this.nextCall.getPeer();\n  }\n\n  private processPendingMessage() {\n    if (this.pendingMessageContext) {\n      this.nextCall.sendMessageWithContext(this.pendingMessageContext, this.pendingMessage);\n      this.pendingMessageContext = null;\n      this.pendingMessage = null;\n    }\n  }\n\n  private processPendingHalfClose() {\n    if (this.pendingHalfClose) {\n      this.nextCall.halfClose();\n    }\n  }\n\n  start(\n    metadata: Metadata,\n    interceptingListener?: Partial<InterceptingListener>\n  ): void {\n    const fullInterceptingListener: InterceptingListener = {\n      onReceiveMetadata:\n        interceptingListener?.onReceiveMetadata?.bind(interceptingListener) ??\n        ((metadata) => {}),\n      onReceiveMessage:\n        interceptingListener?.onReceiveMessage?.bind(interceptingListener) ??\n        ((message) => {}),\n      onReceiveStatus:\n        interceptingListener?.onReceiveStatus?.bind(interceptingListener) ??\n        ((status) => {}),\n    };\n    this.processingMetadata = true;\n    this.requester.start(metadata, fullInterceptingListener, (md, listener) => {\n      this.processingMetadata = false;\n      let finalInterceptingListener: InterceptingListener;\n      if (isInterceptingListener(listener)) {\n        finalInterceptingListener = listener;\n      } else {\n        const fullListener: FullListener = {\n          onReceiveMetadata:\n            listener.onReceiveMetadata ?? defaultListener.onReceiveMetadata,\n          onReceiveMessage:\n            listener.onReceiveMessage ?? defaultListener.onReceiveMessage,\n          onReceiveStatus:\n            listener.onReceiveStatus ?? defaultListener.onReceiveStatus,\n        };\n        finalInterceptingListener = new InterceptingListenerImpl(\n          fullListener,\n          fullInterceptingListener\n        );\n      }\n      this.nextCall.start(md, finalInterceptingListener);\n      this.processPendingMessage();\n      this.processPendingHalfClose();\n    });\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessageWithContext(context: MessageContext, message: any): void {\n    this.processingMessage = true;\n    this.requester.sendMessage(message, (finalMessage) => {\n      this.processingMessage = false;\n      if (this.processingMetadata) {\n        this.pendingMessageContext = context;\n        this.pendingMessage = message;\n      } else {\n        this.nextCall.sendMessageWithContext(context, finalMessage);\n        this.processPendingHalfClose();\n      }\n    });\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessage(message: any): void {\n    this.sendMessageWithContext({}, message);\n  }\n  startRead(): void {\n    this.nextCall.startRead();\n  }\n  halfClose(): void {\n    this.requester.halfClose(() => {\n      if (this.processingMetadata || this.processingMessage) {\n        this.pendingHalfClose = true;\n      } else {\n        this.nextCall.halfClose();\n      }\n    });\n  }\n}\n\nfunction getCall(channel: Channel, path: string, options: CallOptions): Call {\n  const deadline = options.deadline ?? Infinity;\n  const host = options.host;\n  const parent = options.parent ?? null;\n  const propagateFlags = options.propagate_flags;\n  const credentials = options.credentials;\n  const call = channel.createCall(path, deadline, host, parent, propagateFlags);\n  if (credentials) {\n    call.setCredentials(credentials);\n  }\n  return call;\n}\n\n/**\n * InterceptingCall implementation that directly owns the underlying Call\n * object and handles serialization and deseraizliation.\n */\nclass BaseInterceptingCall implements InterceptingCallInterface {\n  constructor(\n    protected call: Call,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    protected methodDefinition: ClientMethodDefinition<any, any>\n  ) {}\n  cancelWithStatus(status: Status, details: string): void {\n    this.call.cancelWithStatus(status, details);\n  }\n  getPeer(): string {\n    return this.call.getPeer();\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessageWithContext(context: MessageContext, message: any): void {\n    let serialized: Buffer;\n    try {\n      serialized = this.methodDefinition.requestSerialize(message);\n    } catch (e) {\n      this.call.cancelWithStatus(\n        Status.INTERNAL,\n        `Request message serialization failure: ${getErrorMessage(e)}`\n      );\n      return;\n    }\n    this.call.sendMessageWithContext(context, serialized);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessage(message: any) {\n    this.sendMessageWithContext({}, message);\n  }\n  start(\n    metadata: Metadata,\n    interceptingListener?: Partial<InterceptingListener>\n  ): void {\n    let readError: StatusObject | null = null;\n    this.call.start(metadata, {\n      onReceiveMetadata: (metadata) => {\n        interceptingListener?.onReceiveMetadata?.(metadata);\n      },\n      onReceiveMessage: (message) => {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let deserialized: any;\n        try {\n          deserialized = this.methodDefinition.responseDeserialize(message);\n        } catch (e) {\n          readError = {\n            code: Status.INTERNAL,\n            details: `Response message parsing error: ${getErrorMessage(e)}`,\n            metadata: new Metadata(),\n          };\n          this.call.cancelWithStatus(readError.code, readError.details);\n          return;\n        }\n        interceptingListener?.onReceiveMessage?.(deserialized);\n      },\n      onReceiveStatus: (status) => {\n        if (readError) {\n          interceptingListener?.onReceiveStatus?.(readError);\n        } else {\n          interceptingListener?.onReceiveStatus?.(status);\n        }\n      },\n    });\n  }\n  startRead() {\n    this.call.startRead();\n  }\n  halfClose(): void {\n    this.call.halfClose();\n  }\n}\n\n/**\n * BaseInterceptingCall with special-cased behavior for methods with unary\n * responses.\n */\nclass BaseUnaryInterceptingCall\n  extends BaseInterceptingCall\n  implements InterceptingCallInterface {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(call: Call, methodDefinition: ClientMethodDefinition<any, any>) {\n    super(call, methodDefinition);\n  }\n  start(metadata: Metadata, listener?: Partial<InterceptingListener>): void {\n    let receivedMessage = false;\n    const wrapperListener: InterceptingListener = {\n      onReceiveMetadata:\n        listener?.onReceiveMetadata?.bind(listener) ?? ((metadata) => {}),\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      onReceiveMessage: (message: any) => {\n        receivedMessage = true;\n        listener?.onReceiveMessage?.(message);\n      },\n      onReceiveStatus: (status: StatusObject) => {\n        if (!receivedMessage) {\n          listener?.onReceiveMessage?.(null);\n        }\n        listener?.onReceiveStatus?.(status);\n      },\n    };\n    super.start(metadata, wrapperListener);\n    this.call.startRead();\n  }\n}\n\n/**\n * BaseInterceptingCall with special-cased behavior for methods with streaming\n * responses.\n */\nclass BaseStreamingInterceptingCall\n  extends BaseInterceptingCall\n  implements InterceptingCallInterface {}\n\nfunction getBottomInterceptingCall(\n  channel: Channel,\n  options: InterceptorOptions,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  methodDefinition: ClientMethodDefinition<any, any>\n) {\n  const call = getCall(channel, methodDefinition.path, options);\n  if (methodDefinition.responseStream) {\n    return new BaseStreamingInterceptingCall(call, methodDefinition);\n  } else {\n    return new BaseUnaryInterceptingCall(call, methodDefinition);\n  }\n}\n\nexport interface NextCall {\n  (options: InterceptorOptions): InterceptingCallInterface;\n}\n\nexport interface Interceptor {\n  (options: InterceptorOptions, nextCall: NextCall): InterceptingCall;\n}\n\nexport interface InterceptorProvider {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (methodDefinition: ClientMethodDefinition<any, any>): Interceptor;\n}\n\nexport interface InterceptorArguments {\n  clientInterceptors: Interceptor[];\n  clientInterceptorProviders: InterceptorProvider[];\n  callInterceptors: Interceptor[];\n  callInterceptorProviders: InterceptorProvider[];\n}\n\nexport function getInterceptingCall(\n  interceptorArgs: InterceptorArguments,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  methodDefinition: ClientMethodDefinition<any, any>,\n  options: CallOptions,\n  channel: Channel\n): InterceptingCallInterface {\n  if (\n    interceptorArgs.clientInterceptors.length > 0 &&\n    interceptorArgs.clientInterceptorProviders.length > 0\n  ) {\n    throw new InterceptorConfigurationError(\n      'Both interceptors and interceptor_providers were passed as options ' +\n        'to the client constructor. Only one of these is allowed.'\n    );\n  }\n  if (\n    interceptorArgs.callInterceptors.length > 0 &&\n    interceptorArgs.callInterceptorProviders.length > 0\n  ) {\n    throw new InterceptorConfigurationError(\n      'Both interceptors and interceptor_providers were passed as call ' +\n        'options. Only one of these is allowed.'\n    );\n  }\n  let interceptors: Interceptor[] = [];\n  // Interceptors passed to the call override interceptors passed to the client constructor\n  if (\n    interceptorArgs.callInterceptors.length > 0 ||\n    interceptorArgs.callInterceptorProviders.length > 0\n  ) {\n    interceptors = ([] as Interceptor[])\n      .concat(\n        interceptorArgs.callInterceptors,\n        interceptorArgs.callInterceptorProviders.map((provider) =>\n          provider(methodDefinition)\n        )\n      )\n      .filter((interceptor) => interceptor);\n    // Filter out falsy values when providers return nothing\n  } else {\n    interceptors = ([] as Interceptor[])\n      .concat(\n        interceptorArgs.clientInterceptors,\n        interceptorArgs.clientInterceptorProviders.map((provider) =>\n          provider(methodDefinition)\n        )\n      )\n      .filter((interceptor) => interceptor);\n    // Filter out falsy values when providers return nothing\n  }\n  const interceptorOptions = Object.assign({}, options, {\n    method_definition: methodDefinition,\n  });\n  /* For each interceptor in the list, the nextCall function passed to it is\n   * based on the next interceptor in the list, using a nextCall function\n   * constructed with the following interceptor in the list, and so on. The\n   * initialValue, which is effectively at the end of the list, is a nextCall\n   * function that invokes getBottomInterceptingCall, the result of which\n   * handles (de)serialization and also gets the underlying call from the\n   * channel. */\n  const getCall: NextCall = interceptors.reduceRight<NextCall>(\n    (nextCall: NextCall, nextInterceptor: Interceptor) => {\n      return (currentOptions) => nextInterceptor(currentOptions, nextCall);\n    },\n    (finalOptions: InterceptorOptions) =>\n      getBottomInterceptingCall(channel, finalOptions, methodDefinition)\n  );\n  return getCall(interceptorOptions);\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}