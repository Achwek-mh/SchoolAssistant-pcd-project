{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSubchannelPool = exports.SubchannelPool = void 0;\nconst channel_options_1 = require(\"./channel-options\");\nconst subchannel_1 = require(\"./subchannel\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst transport_1 = require(\"./transport\");\n// 10 seconds in milliseconds. This value is arbitrary.\n/**\n * The amount of time in between checks for dropping subchannels that have no\n * other references\n */\nconst REF_CHECK_INTERVAL = 10000;\nclass SubchannelPool {\n  /**\n   * A pool of subchannels use for making connections. Subchannels with the\n   * exact same parameters will be reused.\n   */\n  constructor() {\n    this.pool = Object.create(null);\n    /**\n     * A timer of a task performing a periodic subchannel cleanup.\n     */\n    this.cleanupTimer = null;\n  }\n  /**\n   * Unrefs all unused subchannels and cancels the cleanup task if all\n   * subchannels have been unrefed.\n   */\n  unrefUnusedSubchannels() {\n    let allSubchannelsUnrefed = true;\n    /* These objects are created with Object.create(null), so they do not\n     * have a prototype, which means that for (... in ...) loops over them\n     * do not need to be filtered */\n    // eslint-disable-disable-next-line:forin\n    for (const channelTarget in this.pool) {\n      const subchannelObjArray = this.pool[channelTarget];\n      const refedSubchannels = subchannelObjArray.filter(value => !value.subchannel.unrefIfOneRef());\n      if (refedSubchannels.length > 0) {\n        allSubchannelsUnrefed = false;\n      }\n      /* For each subchannel in the pool, try to unref it if it has\n       * exactly one ref (which is the ref from the pool itself). If that\n       * does happen, remove the subchannel from the pool */\n      this.pool[channelTarget] = refedSubchannels;\n    }\n    /* Currently we do not delete keys with empty values. If that results\n     * in significant memory usage we should change it. */\n    // Cancel the cleanup task if all subchannels have been unrefed.\n    if (allSubchannelsUnrefed && this.cleanupTimer !== null) {\n      clearInterval(this.cleanupTimer);\n      this.cleanupTimer = null;\n    }\n  }\n  /**\n   * Ensures that the cleanup task is spawned.\n   */\n  ensureCleanupTask() {\n    var _a, _b;\n    if (this.cleanupTimer === null) {\n      this.cleanupTimer = setInterval(() => {\n        this.unrefUnusedSubchannels();\n      }, REF_CHECK_INTERVAL);\n      // Unref because this timer should not keep the event loop running.\n      // Call unref only if it exists to address electron/electron#21162\n      (_b = (_a = this.cleanupTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n  }\n  /**\n   * Get a subchannel if one already exists with exactly matching parameters.\n   * Otherwise, create and save a subchannel with those parameters.\n   * @param channelTarget\n   * @param subchannelTarget\n   * @param channelArguments\n   * @param channelCredentials\n   */\n  getOrCreateSubchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials) {\n    this.ensureCleanupTask();\n    const channelTarget = (0, uri_parser_1.uriToString)(channelTargetUri);\n    if (channelTarget in this.pool) {\n      const subchannelObjArray = this.pool[channelTarget];\n      for (const subchannelObj of subchannelObjArray) {\n        if ((0, subchannel_address_1.subchannelAddressEqual)(subchannelTarget, subchannelObj.subchannelAddress) && (0, channel_options_1.channelOptionsEqual)(channelArguments, subchannelObj.channelArguments) && channelCredentials._equals(subchannelObj.channelCredentials)) {\n          return subchannelObj.subchannel;\n        }\n      }\n    }\n    // If we get here, no matching subchannel was found\n    const subchannel = new subchannel_1.Subchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials, new transport_1.Http2SubchannelConnector(channelTargetUri));\n    if (!(channelTarget in this.pool)) {\n      this.pool[channelTarget] = [];\n    }\n    this.pool[channelTarget].push({\n      subchannelAddress: subchannelTarget,\n      channelArguments,\n      channelCredentials,\n      subchannel\n    });\n    subchannel.ref();\n    return subchannel;\n  }\n}\nexports.SubchannelPool = SubchannelPool;\nconst globalSubchannelPool = new SubchannelPool();\n/**\n * Get either the global subchannel pool, or a new subchannel pool.\n * @param global\n */\nfunction getSubchannelPool(global) {\n  if (global) {\n    return globalSubchannelPool;\n  } else {\n    return new SubchannelPool();\n  }\n}\nexports.getSubchannelPool = getSubchannelPool;","map":{"version":3,"mappings":"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","names":["REF_CHECK_INTERVAL","SubchannelPool","constructor","Object","create","unrefUnusedSubchannels","allSubchannelsUnrefed","channelTarget","pool","subchannelObjArray","refedSubchannels","filter","value","subchannel","unrefIfOneRef","length","cleanupTimer","clearInterval","ensureCleanupTask","setInterval","unref","getOrCreateSubchannel","channelTargetUri","subchannelTarget","channelArguments","channelCredentials","subchannelObj","subchannelAddress","_equals","subchannel_1","transport_1","push","ref","exports","globalSubchannelPool","getSubchannelPool","global"],"sources":["/home/achwak/node_modules/@grpc/grpc-js/src/subchannel-pool.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { ChannelOptions, channelOptionsEqual } from './channel-options';\nimport { Subchannel } from './subchannel';\nimport {\n  SubchannelAddress,\n  subchannelAddressEqual,\n} from './subchannel-address';\nimport { ChannelCredentials } from './channel-credentials';\nimport { GrpcUri, uriToString } from './uri-parser';\nimport { Http2SubchannelConnector } from './transport';\n\n// 10 seconds in milliseconds. This value is arbitrary.\n/**\n * The amount of time in between checks for dropping subchannels that have no\n * other references\n */\nconst REF_CHECK_INTERVAL = 10_000;\n\nexport class SubchannelPool {\n  private pool: {\n    [channelTarget: string]: Array<{\n      subchannelAddress: SubchannelAddress;\n      channelArguments: ChannelOptions;\n      channelCredentials: ChannelCredentials;\n      subchannel: Subchannel;\n    }>;\n  } = Object.create(null);\n\n  /**\n   * A timer of a task performing a periodic subchannel cleanup.\n   */\n  private cleanupTimer: NodeJS.Timer | null = null;\n\n  /**\n   * A pool of subchannels use for making connections. Subchannels with the\n   * exact same parameters will be reused.\n   */\n  constructor() {}\n\n  /**\n   * Unrefs all unused subchannels and cancels the cleanup task if all\n   * subchannels have been unrefed.\n   */\n  unrefUnusedSubchannels(): void {\n    let allSubchannelsUnrefed = true;\n\n    /* These objects are created with Object.create(null), so they do not\n     * have a prototype, which means that for (... in ...) loops over them\n     * do not need to be filtered */\n    // eslint-disable-disable-next-line:forin\n    for (const channelTarget in this.pool) {\n      const subchannelObjArray = this.pool[channelTarget];\n\n      const refedSubchannels = subchannelObjArray.filter(\n        (value) => !value.subchannel.unrefIfOneRef()\n      );\n\n      if (refedSubchannels.length > 0) {\n        allSubchannelsUnrefed = false;\n      }\n\n      /* For each subchannel in the pool, try to unref it if it has\n       * exactly one ref (which is the ref from the pool itself). If that\n       * does happen, remove the subchannel from the pool */\n      this.pool[channelTarget] = refedSubchannels;\n    }\n    /* Currently we do not delete keys with empty values. If that results\n     * in significant memory usage we should change it. */\n\n    // Cancel the cleanup task if all subchannels have been unrefed.\n    if (allSubchannelsUnrefed && this.cleanupTimer !== null) {\n      clearInterval(this.cleanupTimer);\n      this.cleanupTimer = null;\n    }\n  }\n\n  /**\n   * Ensures that the cleanup task is spawned.\n   */\n  ensureCleanupTask(): void {\n    if (this.cleanupTimer === null) {\n      this.cleanupTimer = setInterval(() => {\n        this.unrefUnusedSubchannels();\n      }, REF_CHECK_INTERVAL);\n\n      // Unref because this timer should not keep the event loop running.\n      // Call unref only if it exists to address electron/electron#21162\n      this.cleanupTimer.unref?.();\n    }\n  }\n\n  /**\n   * Get a subchannel if one already exists with exactly matching parameters.\n   * Otherwise, create and save a subchannel with those parameters.\n   * @param channelTarget\n   * @param subchannelTarget\n   * @param channelArguments\n   * @param channelCredentials\n   */\n  getOrCreateSubchannel(\n    channelTargetUri: GrpcUri,\n    subchannelTarget: SubchannelAddress,\n    channelArguments: ChannelOptions,\n    channelCredentials: ChannelCredentials\n  ): Subchannel {\n    this.ensureCleanupTask();\n    const channelTarget = uriToString(channelTargetUri);\n    if (channelTarget in this.pool) {\n      const subchannelObjArray = this.pool[channelTarget];\n      for (const subchannelObj of subchannelObjArray) {\n        if (\n          subchannelAddressEqual(\n            subchannelTarget,\n            subchannelObj.subchannelAddress\n          ) &&\n          channelOptionsEqual(\n            channelArguments,\n            subchannelObj.channelArguments\n          ) &&\n          channelCredentials._equals(subchannelObj.channelCredentials)\n        ) {\n          return subchannelObj.subchannel;\n        }\n      }\n    }\n    // If we get here, no matching subchannel was found\n    const subchannel = new Subchannel(\n      channelTargetUri,\n      subchannelTarget,\n      channelArguments,\n      channelCredentials,\n      new Http2SubchannelConnector(channelTargetUri)\n    );\n    if (!(channelTarget in this.pool)) {\n      this.pool[channelTarget] = [];\n    }\n    this.pool[channelTarget].push({\n      subchannelAddress: subchannelTarget,\n      channelArguments,\n      channelCredentials,\n      subchannel,\n    });\n    subchannel.ref();\n    return subchannel;\n  }\n}\n\nconst globalSubchannelPool = new SubchannelPool();\n\n/**\n * Get either the global subchannel pool, or a new subchannel pool.\n * @param global\n */\nexport function getSubchannelPool(global: boolean): SubchannelPool {\n  if (global) {\n    return globalSubchannelPool;\n  } else {\n    return new SubchannelPool();\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}