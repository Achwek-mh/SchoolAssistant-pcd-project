{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2020 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ChildLoadBalancerHandler = void 0;\nconst load_balancer_1 = require(\"./load-balancer\");\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst TYPE_NAME = 'child_load_balancer_helper';\nclass ChildLoadBalancerHandler {\n  constructor(channelControlHelper) {\n    this.channelControlHelper = channelControlHelper;\n    this.currentChild = null;\n    this.pendingChild = null;\n    this.ChildPolicyHelper = class {\n      constructor(parent) {\n        this.parent = parent;\n        this.child = null;\n      }\n      createSubchannel(subchannelAddress, subchannelArgs) {\n        return this.parent.channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);\n      }\n      updateState(connectivityState, picker) {\n        var _a;\n        if (this.calledByPendingChild()) {\n          if (connectivityState === connectivity_state_1.ConnectivityState.CONNECTING) {\n            return;\n          }\n          (_a = this.parent.currentChild) === null || _a === void 0 ? void 0 : _a.destroy();\n          this.parent.currentChild = this.parent.pendingChild;\n          this.parent.pendingChild = null;\n        } else if (!this.calledByCurrentChild()) {\n          return;\n        }\n        this.parent.channelControlHelper.updateState(connectivityState, picker);\n      }\n      requestReresolution() {\n        var _a;\n        const latestChild = (_a = this.parent.pendingChild) !== null && _a !== void 0 ? _a : this.parent.currentChild;\n        if (this.child === latestChild) {\n          this.parent.channelControlHelper.requestReresolution();\n        }\n      }\n      setChild(newChild) {\n        this.child = newChild;\n      }\n      addChannelzChild(child) {\n        this.parent.channelControlHelper.addChannelzChild(child);\n      }\n      removeChannelzChild(child) {\n        this.parent.channelControlHelper.removeChannelzChild(child);\n      }\n      calledByPendingChild() {\n        return this.child === this.parent.pendingChild;\n      }\n      calledByCurrentChild() {\n        return this.child === this.parent.currentChild;\n      }\n    };\n  }\n  /**\n   * Prerequisites: lbConfig !== null and lbConfig.name is registered\n   * @param addressList\n   * @param lbConfig\n   * @param attributes\n   */\n  updateAddressList(addressList, lbConfig, attributes) {\n    let childToUpdate;\n    if (this.currentChild === null || this.currentChild.getTypeName() !== lbConfig.getLoadBalancerName()) {\n      const newHelper = new this.ChildPolicyHelper(this);\n      const newChild = (0, load_balancer_1.createLoadBalancer)(lbConfig, newHelper);\n      newHelper.setChild(newChild);\n      if (this.currentChild === null) {\n        this.currentChild = newChild;\n        childToUpdate = this.currentChild;\n      } else {\n        if (this.pendingChild) {\n          this.pendingChild.destroy();\n        }\n        this.pendingChild = newChild;\n        childToUpdate = this.pendingChild;\n      }\n    } else {\n      if (this.pendingChild === null) {\n        childToUpdate = this.currentChild;\n      } else {\n        childToUpdate = this.pendingChild;\n      }\n    }\n    childToUpdate.updateAddressList(addressList, lbConfig, attributes);\n  }\n  exitIdle() {\n    if (this.currentChild) {\n      this.currentChild.exitIdle();\n      if (this.pendingChild) {\n        this.pendingChild.exitIdle();\n      }\n    }\n  }\n  resetBackoff() {\n    if (this.currentChild) {\n      this.currentChild.resetBackoff();\n      if (this.pendingChild) {\n        this.pendingChild.resetBackoff();\n      }\n    }\n  }\n  destroy() {\n    if (this.currentChild) {\n      this.currentChild.destroy();\n      this.currentChild = null;\n    }\n    if (this.pendingChild) {\n      this.pendingChild.destroy();\n      this.pendingChild = null;\n    }\n  }\n  getTypeName() {\n    return TYPE_NAME;\n  }\n}\nexports.ChildLoadBalancerHandler = ChildLoadBalancerHandler;","map":{"version":3,"mappings":"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","names":["TYPE_NAME","ChildLoadBalancerHandler","constructor","channelControlHelper","parent","createSubchannel","subchannelAddress","subchannelArgs","updateState","connectivityState","picker","calledByPendingChild","connectivity_state_1","CONNECTING","currentChild","destroy","pendingChild","calledByCurrentChild","requestReresolution","latestChild","child","setChild","newChild","addChannelzChild","removeChannelzChild","updateAddressList","addressList","lbConfig","attributes","childToUpdate","getTypeName","getLoadBalancerName","newHelper","ChildPolicyHelper","exitIdle","resetBackoff","exports"],"sources":["/home/achwak/node_modules/@grpc/grpc-js/src/load-balancer-child-handler.ts"],"sourcesContent":["/*\n * Copyright 2020 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport {\n  LoadBalancer,\n  ChannelControlHelper,\n  LoadBalancingConfig,\n  createLoadBalancer,\n} from './load-balancer';\nimport { SubchannelAddress } from './subchannel-address';\nimport { ChannelOptions } from './channel-options';\nimport { ConnectivityState } from './connectivity-state';\nimport { Picker } from './picker';\nimport { ChannelRef, SubchannelRef } from './channelz';\nimport { SubchannelInterface } from './subchannel-interface';\n\nconst TYPE_NAME = 'child_load_balancer_helper';\n\nexport class ChildLoadBalancerHandler implements LoadBalancer {\n  private currentChild: LoadBalancer | null = null;\n  private pendingChild: LoadBalancer | null = null;\n\n  private ChildPolicyHelper = class {\n    private child: LoadBalancer | null = null;\n    constructor(private parent: ChildLoadBalancerHandler) {}\n    createSubchannel(\n      subchannelAddress: SubchannelAddress,\n      subchannelArgs: ChannelOptions\n    ): SubchannelInterface {\n      return this.parent.channelControlHelper.createSubchannel(\n        subchannelAddress,\n        subchannelArgs\n      );\n    }\n    updateState(connectivityState: ConnectivityState, picker: Picker): void {\n      if (this.calledByPendingChild()) {\n        if (connectivityState === ConnectivityState.CONNECTING) {\n          return;\n        }\n        this.parent.currentChild?.destroy();\n        this.parent.currentChild = this.parent.pendingChild;\n        this.parent.pendingChild = null;\n      } else if (!this.calledByCurrentChild()) {\n        return;\n      }\n      this.parent.channelControlHelper.updateState(connectivityState, picker);\n    }\n    requestReresolution(): void {\n      const latestChild = this.parent.pendingChild ?? this.parent.currentChild;\n      if (this.child === latestChild) {\n        this.parent.channelControlHelper.requestReresolution();\n      }\n    }\n    setChild(newChild: LoadBalancer) {\n      this.child = newChild;\n    }\n    addChannelzChild(child: ChannelRef | SubchannelRef) {\n      this.parent.channelControlHelper.addChannelzChild(child);\n    }\n    removeChannelzChild(child: ChannelRef | SubchannelRef) {\n      this.parent.channelControlHelper.removeChannelzChild(child);\n    }\n    \n    private calledByPendingChild(): boolean {\n      return this.child === this.parent.pendingChild;\n    }\n    private calledByCurrentChild(): boolean {\n      return this.child === this.parent.currentChild;\n    }\n  };\n\n  constructor(private readonly channelControlHelper: ChannelControlHelper) {}\n\n  /**\n   * Prerequisites: lbConfig !== null and lbConfig.name is registered\n   * @param addressList\n   * @param lbConfig\n   * @param attributes\n   */\n  updateAddressList(\n    addressList: SubchannelAddress[],\n    lbConfig: LoadBalancingConfig,\n    attributes: { [key: string]: unknown }\n  ): void {\n    let childToUpdate: LoadBalancer;\n    if (\n      this.currentChild === null ||\n      this.currentChild.getTypeName() !== lbConfig.getLoadBalancerName()\n    ) {\n      const newHelper = new this.ChildPolicyHelper(this);\n      const newChild = createLoadBalancer(lbConfig, newHelper)!;\n      newHelper.setChild(newChild);\n      if (this.currentChild === null) {\n        this.currentChild = newChild;\n        childToUpdate = this.currentChild;\n      } else {\n        if (this.pendingChild) {\n          this.pendingChild.destroy();\n        }\n        this.pendingChild = newChild;\n        childToUpdate = this.pendingChild;\n      }\n    } else {\n      if (this.pendingChild === null) {\n        childToUpdate = this.currentChild;\n      } else {\n        childToUpdate = this.pendingChild;\n      }\n    }\n    childToUpdate.updateAddressList(addressList, lbConfig, attributes);\n  }\n  exitIdle(): void {\n    if (this.currentChild) {\n      this.currentChild.exitIdle();\n      if (this.pendingChild) {\n        this.pendingChild.exitIdle();\n      }\n    }\n  }\n  resetBackoff(): void {\n    if (this.currentChild) {\n      this.currentChild.resetBackoff();\n      if (this.pendingChild) {\n        this.pendingChild.resetBackoff();\n      }\n    }\n  }\n  destroy(): void {\n    if (this.currentChild) {\n      this.currentChild.destroy();\n      this.currentChild = null;\n    }\n    if (this.pendingChild) {\n      this.pendingChild.destroy();\n      this.pendingChild = null;\n    }\n  }\n  getTypeName(): string {\n    return TYPE_NAME;\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}