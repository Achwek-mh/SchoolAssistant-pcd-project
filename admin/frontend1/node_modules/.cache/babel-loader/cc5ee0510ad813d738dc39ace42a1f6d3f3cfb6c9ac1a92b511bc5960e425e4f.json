{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BaseSubchannelWrapper = void 0;\nclass BaseSubchannelWrapper {\n  constructor(child) {\n    this.child = child;\n  }\n  getConnectivityState() {\n    return this.child.getConnectivityState();\n  }\n  addConnectivityStateListener(listener) {\n    this.child.addConnectivityStateListener(listener);\n  }\n  removeConnectivityStateListener(listener) {\n    this.child.removeConnectivityStateListener(listener);\n  }\n  startConnecting() {\n    this.child.startConnecting();\n  }\n  getAddress() {\n    return this.child.getAddress();\n  }\n  throttleKeepalive(newKeepaliveTime) {\n    this.child.throttleKeepalive(newKeepaliveTime);\n  }\n  ref() {\n    this.child.ref();\n  }\n  unref() {\n    this.child.unref();\n  }\n  getChannelzRef() {\n    return this.child.getChannelzRef();\n  }\n  getRealSubchannel() {\n    return this.child.getRealSubchannel();\n  }\n}\nexports.BaseSubchannelWrapper = BaseSubchannelWrapper;","map":{"version":3,"mappings":";;AAAA;;;;;;;;;;;;;;;;;;;;AAqDA,MAAsBA,qBAAqB;EACzCC,YAAsBC,KAA0B;IAA1B,UAAK,GAALA,KAAK;EAAwB;EAEnDC,oBAAoB;IAClB,OAAO,IAAI,CAACD,KAAK,CAACC,oBAAoB,EAAE;EAC1C;EACAC,4BAA4B,CAACC,QAAmC;IAC9D,IAAI,CAACH,KAAK,CAACE,4BAA4B,CAACC,QAAQ,CAAC;EACnD;EACAC,+BAA+B,CAACD,QAAmC;IACjE,IAAI,CAACH,KAAK,CAACI,+BAA+B,CAACD,QAAQ,CAAC;EACtD;EACAE,eAAe;IACb,IAAI,CAACL,KAAK,CAACK,eAAe,EAAE;EAC9B;EACAC,UAAU;IACR,OAAO,IAAI,CAACN,KAAK,CAACM,UAAU,EAAE;EAChC;EACAC,iBAAiB,CAACC,gBAAwB;IACxC,IAAI,CAACR,KAAK,CAACO,iBAAiB,CAACC,gBAAgB,CAAC;EAChD;EACAC,GAAG;IACD,IAAI,CAACT,KAAK,CAACS,GAAG,EAAE;EAClB;EACAC,KAAK;IACH,IAAI,CAACV,KAAK,CAACU,KAAK,EAAE;EACpB;EACAC,cAAc;IACZ,OAAO,IAAI,CAACX,KAAK,CAACW,cAAc,EAAE;EACpC;EACAC,iBAAiB;IACf,OAAO,IAAI,CAACZ,KAAK,CAACY,iBAAiB,EAAE;EACvC;;AAhCFC","names":["BaseSubchannelWrapper","constructor","child","getConnectivityState","addConnectivityStateListener","listener","removeConnectivityStateListener","startConnecting","getAddress","throttleKeepalive","newKeepaliveTime","ref","unref","getChannelzRef","getRealSubchannel","exports"],"sources":["/home/achwak/node_modules/@grpc/grpc-js/src/subchannel-interface.ts"],"sourcesContent":["/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { SubchannelRef } from \"./channelz\";\nimport { ConnectivityState } from \"./connectivity-state\";\nimport { Subchannel } from \"./subchannel\";\n\nexport type ConnectivityStateListener = (\n  subchannel: SubchannelInterface,\n  previousState: ConnectivityState,\n  newState: ConnectivityState,\n  keepaliveTime: number\n) => void;\n\n/**\n * This is an interface for load balancing policies to use to interact with\n * subchannels. This allows load balancing policies to wrap and unwrap\n * subchannels.\n * \n * Any load balancing policy that wraps subchannels must unwrap the subchannel\n * in the picker, so that other load balancing policies consistently have\n * access to their own wrapper objects.\n */\nexport interface SubchannelInterface {\n  getConnectivityState(): ConnectivityState;\n  addConnectivityStateListener(listener: ConnectivityStateListener): void;\n  removeConnectivityStateListener(listener: ConnectivityStateListener): void;\n  startConnecting(): void;\n  getAddress(): string;\n  throttleKeepalive(newKeepaliveTime: number): void;\n  ref(): void;\n  unref(): void;\n  getChannelzRef(): SubchannelRef;\n  /**\n   * If this is a wrapper, return the wrapped subchannel, otherwise return this\n   */\n  getRealSubchannel(): Subchannel;\n}\n\nexport abstract class BaseSubchannelWrapper implements SubchannelInterface {\n  constructor(protected child: SubchannelInterface) {}\n\n  getConnectivityState(): ConnectivityState {\n    return this.child.getConnectivityState();\n  }\n  addConnectivityStateListener(listener: ConnectivityStateListener): void {\n    this.child.addConnectivityStateListener(listener);\n  }\n  removeConnectivityStateListener(listener: ConnectivityStateListener): void {\n    this.child.removeConnectivityStateListener(listener);\n  }\n  startConnecting(): void {\n    this.child.startConnecting();\n  }\n  getAddress(): string {\n    return this.child.getAddress();\n  }\n  throttleKeepalive(newKeepaliveTime: number): void {\n    this.child.throttleKeepalive(newKeepaliveTime);\n  }\n  ref(): void {\n    this.child.ref();\n  }\n  unref(): void {\n    this.child.unref();\n  }\n  getChannelzRef(): SubchannelRef {\n    return this.child.getChannelzRef();\n  }\n  getRealSubchannel(): Subchannel {\n    return this.child.getRealSubchannel();\n  }\n}"]},"metadata":{},"sourceType":"script","externalDependencies":[]}