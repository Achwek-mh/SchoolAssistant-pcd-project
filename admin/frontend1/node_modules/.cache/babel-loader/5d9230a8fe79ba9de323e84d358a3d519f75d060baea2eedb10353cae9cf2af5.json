{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LoadBalancingCall = void 0;\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst constants_1 = require(\"./constants\");\nconst deadline_1 = require(\"./deadline\");\nconst metadata_1 = require(\"./metadata\");\nconst picker_1 = require(\"./picker\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst logging = require(\"./logging\");\nconst control_plane_status_1 = require(\"./control-plane-status\");\nconst http2 = require(\"http2\");\nconst TRACER_NAME = 'load_balancing_call';\nclass LoadBalancingCall {\n  constructor(channel, callConfig, methodName, host, credentials, deadline, callNumber) {\n    var _a, _b;\n    this.channel = channel;\n    this.callConfig = callConfig;\n    this.methodName = methodName;\n    this.host = host;\n    this.credentials = credentials;\n    this.deadline = deadline;\n    this.callNumber = callNumber;\n    this.child = null;\n    this.readPending = false;\n    this.pendingMessage = null;\n    this.pendingHalfClose = false;\n    this.pendingChildStatus = null;\n    this.ended = false;\n    this.metadata = null;\n    this.listener = null;\n    this.onCallEnded = null;\n    const splitPath = this.methodName.split('/');\n    let serviceName = '';\n    /* The standard path format is \"/{serviceName}/{methodName}\", so if we split\n     * by '/', the first item should be empty and the second should be the\n     * service name */\n    if (splitPath.length >= 2) {\n      serviceName = splitPath[1];\n    }\n    const hostname = (_b = (_a = (0, uri_parser_1.splitHostPort)(this.host)) === null || _a === void 0 ? void 0 : _a.host) !== null && _b !== void 0 ? _b : 'localhost';\n    /* Currently, call credentials are only allowed on HTTPS connections, so we\n     * can assume that the scheme is \"https\" */\n    this.serviceUrl = `https://${hostname}/${serviceName}`;\n  }\n  trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);\n  }\n  outputStatus(status, progress) {\n    var _a, _b;\n    if (!this.ended) {\n      this.ended = true;\n      this.trace('ended with status: code=' + status.code + ' details=\"' + status.details + '\"');\n      const finalStatus = Object.assign(Object.assign({}, status), {\n        progress\n      });\n      (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(finalStatus);\n      (_b = this.onCallEnded) === null || _b === void 0 ? void 0 : _b.call(this, finalStatus.code);\n    }\n  }\n  doPick() {\n    var _a, _b;\n    if (this.ended) {\n      return;\n    }\n    if (!this.metadata) {\n      throw new Error('doPick called before start');\n    }\n    this.trace('Pick called');\n    const pickResult = this.channel.doPick(this.metadata, this.callConfig.pickInformation);\n    const subchannelString = pickResult.subchannel ? '(' + pickResult.subchannel.getChannelzRef().id + ') ' + pickResult.subchannel.getAddress() : '' + pickResult.subchannel;\n    this.trace('Pick result: ' + picker_1.PickResultType[pickResult.pickResultType] + ' subchannel: ' + subchannelString + ' status: ' + ((_a = pickResult.status) === null || _a === void 0 ? void 0 : _a.code) + ' ' + ((_b = pickResult.status) === null || _b === void 0 ? void 0 : _b.details));\n    switch (pickResult.pickResultType) {\n      case picker_1.PickResultType.COMPLETE:\n        this.credentials.generateMetadata({\n          service_url: this.serviceUrl\n        }).then(credsMetadata => {\n          var _a, _b, _c;\n          const finalMetadata = this.metadata.clone();\n          finalMetadata.merge(credsMetadata);\n          if (finalMetadata.get('authorization').length > 1) {\n            this.outputStatus({\n              code: constants_1.Status.INTERNAL,\n              details: '\"authorization\" metadata cannot have multiple values',\n              metadata: new metadata_1.Metadata()\n            }, 'PROCESSED');\n          }\n          if (pickResult.subchannel.getConnectivityState() !== connectivity_state_1.ConnectivityState.READY) {\n            this.trace('Picked subchannel ' + subchannelString + ' has state ' + connectivity_state_1.ConnectivityState[pickResult.subchannel.getConnectivityState()] + ' after getting credentials metadata. Retrying pick');\n            this.doPick();\n            return;\n          }\n          if (this.deadline !== Infinity) {\n            finalMetadata.set('grpc-timeout', (0, deadline_1.getDeadlineTimeoutString)(this.deadline));\n          }\n          try {\n            this.child = pickResult.subchannel.getRealSubchannel().createCall(finalMetadata, this.host, this.methodName, {\n              onReceiveMetadata: metadata => {\n                this.trace('Received metadata');\n                this.listener.onReceiveMetadata(metadata);\n              },\n              onReceiveMessage: message => {\n                this.trace('Received message');\n                this.listener.onReceiveMessage(message);\n              },\n              onReceiveStatus: status => {\n                this.trace('Received status');\n                if (status.rstCode === http2.constants.NGHTTP2_REFUSED_STREAM) {\n                  this.outputStatus(status, 'REFUSED');\n                } else {\n                  this.outputStatus(status, 'PROCESSED');\n                }\n              }\n            });\n          } catch (error) {\n            this.trace('Failed to start call on picked subchannel ' + subchannelString + ' with error ' + error.message);\n            this.outputStatus({\n              code: constants_1.Status.INTERNAL,\n              details: 'Failed to start HTTP/2 stream with error ' + error.message,\n              metadata: new metadata_1.Metadata()\n            }, 'NOT_STARTED');\n            return;\n          }\n          (_b = (_a = this.callConfig).onCommitted) === null || _b === void 0 ? void 0 : _b.call(_a);\n          (_c = pickResult.onCallStarted) === null || _c === void 0 ? void 0 : _c.call(pickResult);\n          this.onCallEnded = pickResult.onCallEnded;\n          this.trace('Created child call [' + this.child.getCallNumber() + ']');\n          if (this.readPending) {\n            this.child.startRead();\n          }\n          if (this.pendingMessage) {\n            this.child.sendMessageWithContext(this.pendingMessage.context, this.pendingMessage.message);\n          }\n          if (this.pendingHalfClose) {\n            this.child.halfClose();\n          }\n        }, error => {\n          // We assume the error code isn't 0 (Status.OK)\n          const {\n            code,\n            details\n          } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(typeof error.code === 'number' ? error.code : constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error.message}`);\n          this.outputStatus({\n            code: code,\n            details: details,\n            metadata: new metadata_1.Metadata()\n          }, 'PROCESSED');\n        });\n        break;\n      case picker_1.PickResultType.DROP:\n        const {\n          code,\n          details\n        } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(pickResult.status.code, pickResult.status.details);\n        this.outputStatus({\n          code,\n          details,\n          metadata: pickResult.status.metadata\n        }, 'DROP');\n        break;\n      case picker_1.PickResultType.TRANSIENT_FAILURE:\n        if (this.metadata.getOptions().waitForReady) {\n          this.channel.queueCallForPick(this);\n        } else {\n          const {\n            code,\n            details\n          } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(pickResult.status.code, pickResult.status.details);\n          this.outputStatus({\n            code,\n            details,\n            metadata: pickResult.status.metadata\n          }, 'PROCESSED');\n        }\n        break;\n      case picker_1.PickResultType.QUEUE:\n        this.channel.queueCallForPick(this);\n    }\n  }\n  cancelWithStatus(status, details) {\n    var _a;\n    this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\n    (_a = this.child) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(status, details);\n    this.outputStatus({\n      code: status,\n      details: details,\n      metadata: new metadata_1.Metadata()\n    }, 'PROCESSED');\n  }\n  getPeer() {\n    var _a, _b;\n    return (_b = (_a = this.child) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : this.channel.getTarget();\n  }\n  start(metadata, listener) {\n    this.trace('start called');\n    this.listener = listener;\n    this.metadata = metadata;\n    this.doPick();\n  }\n  sendMessageWithContext(context, message) {\n    this.trace('write() called with message of length ' + message.length);\n    if (this.child) {\n      this.child.sendMessageWithContext(context, message);\n    } else {\n      this.pendingMessage = {\n        context,\n        message\n      };\n    }\n  }\n  startRead() {\n    this.trace('startRead called');\n    if (this.child) {\n      this.child.startRead();\n    } else {\n      this.readPending = true;\n    }\n  }\n  halfClose() {\n    this.trace('halfClose called');\n    if (this.child) {\n      this.child.halfClose();\n    } else {\n      this.pendingHalfClose = true;\n    }\n  }\n  setCredentials(credentials) {\n    throw new Error(\"Method not implemented.\");\n  }\n  getCallNumber() {\n    return this.callNumber;\n  }\n}\nexports.LoadBalancingCall = LoadBalancingCall;","map":{"version":3,"mappings":"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","names":["TRACER_NAME","LoadBalancingCall","constructor","channel","callConfig","methodName","host","credentials","deadline","callNumber","splitPath","split","serviceName","length","hostname","serviceUrl","trace","text","logging","constants_1","DEBUG","outputStatus","status","progress","ended","code","details","finalStatus","listener","onReceiveStatus","onCallEnded","doPick","metadata","Error","pickResult","pickInformation","subchannelString","subchannel","getChannelzRef","id","getAddress","picker_1","pickResultType","COMPLETE","generateMetadata","service_url","then","credsMetadata","finalMetadata","clone","merge","get","INTERNAL","metadata_1","getConnectivityState","connectivity_state_1","READY","Infinity","set","child","getRealSubchannel","createCall","onReceiveMetadata","onReceiveMessage","message","rstCode","http2","constants","NGHTTP2_REFUSED_STREAM","error","onCommitted","onCallStarted","getCallNumber","readPending","startRead","pendingMessage","sendMessageWithContext","context","pendingHalfClose","halfClose","UNKNOWN","DROP","TRANSIENT_FAILURE","getOptions","waitForReady","queueCallForPick","QUEUE","cancelWithStatus","getPeer","getTarget","start","setCredentials","exports"],"sources":["/home/achwak/node_modules/@grpc/grpc-js/src/load-balancing-call.ts"],"sourcesContent":["/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { CallCredentials } from \"./call-credentials\";\nimport { Call, InterceptingListener, MessageContext, StatusObject } from \"./call-interface\";\nimport { SubchannelCall } from \"./subchannel-call\";\nimport { ConnectivityState } from \"./connectivity-state\";\nimport { LogVerbosity, Status } from \"./constants\";\nimport { Deadline, getDeadlineTimeoutString } from \"./deadline\";\nimport { FilterStack, FilterStackFactory } from \"./filter-stack\";\nimport { InternalChannel } from \"./internal-channel\";\nimport { Metadata } from \"./metadata\";\nimport { PickResultType } from \"./picker\";\nimport { CallConfig } from \"./resolver\";\nimport { splitHostPort } from \"./uri-parser\";\nimport * as logging from './logging';\nimport { restrictControlPlaneStatusCode } from \"./control-plane-status\";\nimport * as http2 from 'http2';\n\nconst TRACER_NAME = 'load_balancing_call';\n\nexport type RpcProgress = 'NOT_STARTED' | 'DROP' | 'REFUSED' | 'PROCESSED';\n\nexport interface StatusObjectWithProgress extends StatusObject {\n  progress: RpcProgress;\n}\n\nexport interface LoadBalancingCallInterceptingListener extends InterceptingListener {\n  onReceiveStatus(status: StatusObjectWithProgress): void;\n}\n\nexport class LoadBalancingCall implements Call {\n  private child: SubchannelCall | null = null;\n  private readPending = false;\n  private pendingMessage: {context: MessageContext, message: Buffer} | null = null;\n  private pendingHalfClose = false;\n  private pendingChildStatus: StatusObject | null = null;\n  private ended = false;\n  private serviceUrl: string;\n  private metadata: Metadata | null = null;\n  private listener: InterceptingListener | null = null;\n  private onCallEnded: ((statusCode: Status) => void) | null = null;\n  constructor(\n    private readonly channel: InternalChannel,\n    private readonly callConfig: CallConfig,\n    private readonly methodName: string,\n    private readonly host : string,\n    private readonly credentials: CallCredentials,\n    private readonly deadline: Deadline,\n    private readonly callNumber: number\n  ) {\n    const splitPath: string[] = this.methodName.split('/');\n    let serviceName = '';\n    /* The standard path format is \"/{serviceName}/{methodName}\", so if we split\n     * by '/', the first item should be empty and the second should be the\n     * service name */\n    if (splitPath.length >= 2) {\n      serviceName = splitPath[1];\n    }\n    const hostname = splitHostPort(this.host)?.host ?? 'localhost';\n    /* Currently, call credentials are only allowed on HTTPS connections, so we\n     * can assume that the scheme is \"https\" */\n    this.serviceUrl = `https://${hostname}/${serviceName}`;\n  }\n\n  private trace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      TRACER_NAME,\n      '[' + this.callNumber + '] ' + text\n    );\n  }\n\n  private outputStatus(status: StatusObject, progress: RpcProgress) {\n    if (!this.ended) {\n      this.ended = true;\n      this.trace('ended with status: code=' + status.code + ' details=\"' + status.details + '\"');\n      const finalStatus = {...status, progress};\n      this.listener?.onReceiveStatus(finalStatus);\n      this.onCallEnded?.(finalStatus.code);\n    }\n  }\n\n  doPick() {\n    if (this.ended) {\n      return;\n    }\n    if (!this.metadata) {\n      throw new Error('doPick called before start');\n    }\n    this.trace('Pick called')\n    const pickResult = this.channel.doPick(this.metadata, this.callConfig.pickInformation);\n    const subchannelString = pickResult.subchannel ? \n      '(' + pickResult.subchannel.getChannelzRef().id + ') ' + pickResult.subchannel.getAddress() : \n      '' + pickResult.subchannel; \n    this.trace(\n      'Pick result: ' +\n        PickResultType[pickResult.pickResultType] +\n        ' subchannel: ' +\n        subchannelString +\n        ' status: ' +\n        pickResult.status?.code +\n        ' ' +\n        pickResult.status?.details\n    );\n    switch (pickResult.pickResultType) {\n      case PickResultType.COMPLETE:\n        this.credentials.generateMetadata({service_url: this.serviceUrl}).then(\n          (credsMetadata) => {\n            const finalMetadata = this.metadata!.clone();\n            finalMetadata.merge(credsMetadata);\n            if (finalMetadata.get('authorization').length > 1) {\n              this.outputStatus(\n                {\n                  code: Status.INTERNAL,\n                  details: '\"authorization\" metadata cannot have multiple values',\n                  metadata: new Metadata()\n                },\n                'PROCESSED'\n              );\n            }\n            if (pickResult.subchannel!.getConnectivityState() !== ConnectivityState.READY) {\n              this.trace(\n                'Picked subchannel ' +\n                  subchannelString +\n                  ' has state ' +\n                  ConnectivityState[pickResult.subchannel!.getConnectivityState()] +\n                  ' after getting credentials metadata. Retrying pick'\n              );\n              this.doPick();\n              return;\n            }\n\n            if (this.deadline !== Infinity) {\n              finalMetadata.set('grpc-timeout', getDeadlineTimeoutString(this.deadline));\n            }\n            try {\n              this.child = pickResult.subchannel!.getRealSubchannel().createCall(finalMetadata, this.host, this.methodName, {\n                onReceiveMetadata: metadata => {\n                  this.trace('Received metadata');\n                  this.listener!.onReceiveMetadata(metadata);\n                },\n                onReceiveMessage: message => {\n                  this.trace('Received message');\n                  this.listener!.onReceiveMessage(message);\n                },\n                onReceiveStatus: status => {\n                  this.trace('Received status');\n                  if (status.rstCode === http2.constants.NGHTTP2_REFUSED_STREAM) {\n                    this.outputStatus(status, 'REFUSED');\n                  } else {\n                    this.outputStatus(status, 'PROCESSED');\n                  }\n                }\n              });\n            } catch (error) {\n              this.trace(\n                'Failed to start call on picked subchannel ' +\n                  subchannelString +\n                  ' with error ' +\n                  (error as Error).message\n              );\n              this.outputStatus(\n                {\n                  code: Status.INTERNAL,\n                  details: 'Failed to start HTTP/2 stream with error ' + (error as Error).message,\n                  metadata: new Metadata()\n                },\n                'NOT_STARTED'\n              );\n              return;\n            }\n            this.callConfig.onCommitted?.();\n            pickResult.onCallStarted?.();\n            this.onCallEnded = pickResult.onCallEnded;\n            this.trace('Created child call [' + this.child.getCallNumber() + ']');\n            if (this.readPending) {\n              this.child.startRead();\n            }\n            if (this.pendingMessage) {\n              this.child.sendMessageWithContext(this.pendingMessage.context, this.pendingMessage.message);\n            }\n            if (this.pendingHalfClose) {\n              this.child.halfClose();\n            }\n          }, (error: Error & { code: number }) => {\n            // We assume the error code isn't 0 (Status.OK)\n            const {code, details} = restrictControlPlaneStatusCode(\n              typeof error.code === 'number' ? error.code : Status.UNKNOWN,\n              `Getting metadata from plugin failed with error: ${error.message}`\n            )\n            this.outputStatus(\n              {\n                code: code,\n                details: details,\n                metadata: new Metadata()\n              },\n              'PROCESSED'\n            );\n          }\n        );\n        break;\n      case PickResultType.DROP:\n        const {code, details} = restrictControlPlaneStatusCode(pickResult.status!.code, pickResult.status!.details);\n        this.outputStatus({code, details, metadata: pickResult.status!.metadata}, 'DROP');\n        break;\n      case PickResultType.TRANSIENT_FAILURE:\n        if (this.metadata.getOptions().waitForReady) {\n          this.channel.queueCallForPick(this);\n        } else {\n          const {code, details} = restrictControlPlaneStatusCode(pickResult.status!.code, pickResult.status!.details);\n          this.outputStatus({code, details, metadata: pickResult.status!.metadata}, 'PROCESSED');\n        }\n        break;\n      case PickResultType.QUEUE:\n        this.channel.queueCallForPick(this);\n    }\n  }\n\n  cancelWithStatus(status: Status, details: string): void {\n    this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\n    this.child?.cancelWithStatus(status, details);\n    this.outputStatus({code: status, details: details, metadata: new Metadata()}, 'PROCESSED');\n  }\n  getPeer(): string {\n    return this.child?.getPeer() ?? this.channel.getTarget();\n  }\n  start(metadata: Metadata, listener: LoadBalancingCallInterceptingListener): void {\n    this.trace('start called');\n    this.listener = listener;\n    this.metadata = metadata;\n    this.doPick();\n  }\n  sendMessageWithContext(context: MessageContext, message: Buffer): void {\n    this.trace('write() called with message of length ' + message.length);\n    if (this.child) {\n      this.child.sendMessageWithContext(context, message);\n    } else {\n      this.pendingMessage = {context, message};\n    }\n  }\n  startRead(): void {\n    this.trace('startRead called');\n    if (this.child) {\n      this.child.startRead();\n    } else {\n      this.readPending = true;\n    }\n  }\n  halfClose(): void {\n    this.trace('halfClose called');\n    if (this.child) {\n      this.child.halfClose();\n    } else {\n      this.pendingHalfClose = true;\n    }\n  }\n  setCredentials(credentials: CallCredentials): void {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  getCallNumber(): number {\n    return this.callNumber;\n  }\n}"]},"metadata":{},"sourceType":"script","externalDependencies":[]}