{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ChannelCredentials = void 0;\nconst tls_1 = require(\"tls\");\nconst call_credentials_1 = require(\"./call-credentials\");\nconst tls_helpers_1 = require(\"./tls-helpers\");\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction verifyIsBufferOrNull(obj, friendlyName) {\n  if (obj && !(obj instanceof Buffer)) {\n    throw new TypeError(`${friendlyName}, if provided, must be a Buffer.`);\n  }\n}\nfunction bufferOrNullEqual(buf1, buf2) {\n  if (buf1 === null && buf2 === null) {\n    return true;\n  } else {\n    return buf1 !== null && buf2 !== null && buf1.equals(buf2);\n  }\n}\n/**\n * A class that contains credentials for communicating over a channel, as well\n * as a set of per-call credentials, which are applied to every method call made\n * over a channel initialized with an instance of this class.\n */\nclass ChannelCredentials {\n  constructor(callCredentials) {\n    this.callCredentials = callCredentials || call_credentials_1.CallCredentials.createEmpty();\n  }\n  /**\n   * Gets the set of per-call credentials associated with this instance.\n   */\n  _getCallCredentials() {\n    return this.callCredentials;\n  }\n  /**\n   * Return a new ChannelCredentials instance with a given set of credentials.\n   * The resulting instance can be used to construct a Channel that communicates\n   * over TLS.\n   * @param rootCerts The root certificate data.\n   * @param privateKey The client certificate private key, if available.\n   * @param certChain The client certificate key chain, if available.\n   * @param verifyOptions Additional options to modify certificate verification\n   */\n  static createSsl(rootCerts, privateKey, certChain, verifyOptions) {\n    var _a;\n    verifyIsBufferOrNull(rootCerts, 'Root certificate');\n    verifyIsBufferOrNull(privateKey, 'Private key');\n    verifyIsBufferOrNull(certChain, 'Certificate chain');\n    if (privateKey && !certChain) {\n      throw new Error('Private key must be given with accompanying certificate chain');\n    }\n    if (!privateKey && certChain) {\n      throw new Error('Certificate chain must be given with accompanying private key');\n    }\n    const secureContext = (0, tls_1.createSecureContext)({\n      ca: (_a = rootCerts !== null && rootCerts !== void 0 ? rootCerts : (0, tls_helpers_1.getDefaultRootsData)()) !== null && _a !== void 0 ? _a : undefined,\n      key: privateKey !== null && privateKey !== void 0 ? privateKey : undefined,\n      cert: certChain !== null && certChain !== void 0 ? certChain : undefined,\n      ciphers: tls_helpers_1.CIPHER_SUITES\n    });\n    return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});\n  }\n  /**\n   * Return a new ChannelCredentials instance with credentials created using\n   * the provided secureContext. The resulting instances can be used to\n   * construct a Channel that communicates over TLS. gRPC will not override\n   * anything in the provided secureContext, so the environment variables\n   * GRPC_SSL_CIPHER_SUITES and GRPC_DEFAULT_SSL_ROOTS_FILE_PATH will\n   * not be applied.\n   * @param secureContext The return value of tls.createSecureContext()\n   * @param verifyOptions Additional options to modify certificate verification\n   */\n  static createFromSecureContext(secureContext, verifyOptions) {\n    return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});\n  }\n  /**\n   * Return a new ChannelCredentials instance with no credentials.\n   */\n  static createInsecure() {\n    return new InsecureChannelCredentialsImpl();\n  }\n}\nexports.ChannelCredentials = ChannelCredentials;\nclass InsecureChannelCredentialsImpl extends ChannelCredentials {\n  constructor(callCredentials) {\n    super(callCredentials);\n  }\n  compose(callCredentials) {\n    throw new Error('Cannot compose insecure credentials');\n  }\n  _getConnectionOptions() {\n    return null;\n  }\n  _isSecure() {\n    return false;\n  }\n  _equals(other) {\n    return other instanceof InsecureChannelCredentialsImpl;\n  }\n}\nclass SecureChannelCredentialsImpl extends ChannelCredentials {\n  constructor(secureContext, verifyOptions) {\n    super();\n    this.secureContext = secureContext;\n    this.verifyOptions = verifyOptions;\n    this.connectionOptions = {\n      secureContext\n    };\n    // Node asserts that this option is a function, so we cannot pass undefined\n    if (verifyOptions === null || verifyOptions === void 0 ? void 0 : verifyOptions.checkServerIdentity) {\n      this.connectionOptions.checkServerIdentity = verifyOptions.checkServerIdentity;\n    }\n  }\n  compose(callCredentials) {\n    const combinedCallCredentials = this.callCredentials.compose(callCredentials);\n    return new ComposedChannelCredentialsImpl(this, combinedCallCredentials);\n  }\n  _getConnectionOptions() {\n    // Copy to prevent callers from mutating this.connectionOptions\n    return Object.assign({}, this.connectionOptions);\n  }\n  _isSecure() {\n    return true;\n  }\n  _equals(other) {\n    if (this === other) {\n      return true;\n    }\n    if (other instanceof SecureChannelCredentialsImpl) {\n      return this.secureContext === other.secureContext && this.verifyOptions.checkServerIdentity === other.verifyOptions.checkServerIdentity;\n    } else {\n      return false;\n    }\n  }\n}\nclass ComposedChannelCredentialsImpl extends ChannelCredentials {\n  constructor(channelCredentials, callCreds) {\n    super(callCreds);\n    this.channelCredentials = channelCredentials;\n  }\n  compose(callCredentials) {\n    const combinedCallCredentials = this.callCredentials.compose(callCredentials);\n    return new ComposedChannelCredentialsImpl(this.channelCredentials, combinedCallCredentials);\n  }\n  _getConnectionOptions() {\n    return this.channelCredentials._getConnectionOptions();\n  }\n  _isSecure() {\n    return true;\n  }\n  _equals(other) {\n    if (this === other) {\n      return true;\n    }\n    if (other instanceof ComposedChannelCredentialsImpl) {\n      return this.channelCredentials._equals(other.channelCredentials) && this.callCredentials._equals(other.callCredentials);\n    } else {\n      return false;\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["verifyIsBufferOrNull","obj","friendlyName","Buffer","TypeError","bufferOrNullEqual","buf1","buf2","equals","ChannelCredentials","constructor","callCredentials","call_credentials_1","createEmpty","_getCallCredentials","createSsl","rootCerts","privateKey","certChain","verifyOptions","Error","secureContext","ca","undefined","key","cert","ciphers","tls_helpers_1","SecureChannelCredentialsImpl","createFromSecureContext","createInsecure","InsecureChannelCredentialsImpl","exports","compose","_getConnectionOptions","_isSecure","_equals","other","connectionOptions","checkServerIdentity","combinedCallCredentials","ComposedChannelCredentialsImpl","channelCredentials","callCreds"],"sources":["/home/achwak/node_modules/@grpc/grpc-js/src/channel-credentials.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { ConnectionOptions, createSecureContext, PeerCertificate, SecureContext } from 'tls';\n\nimport { CallCredentials } from './call-credentials';\nimport { CIPHER_SUITES, getDefaultRootsData } from './tls-helpers';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction verifyIsBufferOrNull(obj: any, friendlyName: string): void {\n  if (obj && !(obj instanceof Buffer)) {\n    throw new TypeError(`${friendlyName}, if provided, must be a Buffer.`);\n  }\n}\n\n/**\n * A callback that will receive the expected hostname and presented peer\n * certificate as parameters. The callback should return an error to\n * indicate that the presented certificate is considered invalid and\n * otherwise returned undefined.\n */\nexport type CheckServerIdentityCallback = (\n  hostname: string,\n  cert: PeerCertificate\n) => Error | undefined;\n\nfunction bufferOrNullEqual(buf1: Buffer | null, buf2: Buffer | null) {\n  if (buf1 === null && buf2 === null) {\n    return true;\n  } else {\n    return buf1 !== null && buf2 !== null && buf1.equals(buf2);\n  }\n}\n\n/**\n * Additional peer verification options that can be set when creating\n * SSL credentials.\n */\nexport interface VerifyOptions {\n  /**\n   * If set, this callback will be invoked after the usual hostname verification\n   * has been performed on the peer certificate.\n   */\n  checkServerIdentity?: CheckServerIdentityCallback;\n}\n\n/**\n * A class that contains credentials for communicating over a channel, as well\n * as a set of per-call credentials, which are applied to every method call made\n * over a channel initialized with an instance of this class.\n */\nexport abstract class ChannelCredentials {\n  protected callCredentials: CallCredentials;\n\n  protected constructor(callCredentials?: CallCredentials) {\n    this.callCredentials = callCredentials || CallCredentials.createEmpty();\n  }\n  /**\n   * Returns a copy of this object with the included set of per-call credentials\n   * expanded to include callCredentials.\n   * @param callCredentials A CallCredentials object to associate with this\n   * instance.\n   */\n  abstract compose(callCredentials: CallCredentials): ChannelCredentials;\n\n  /**\n   * Gets the set of per-call credentials associated with this instance.\n   */\n  _getCallCredentials(): CallCredentials {\n    return this.callCredentials;\n  }\n\n  /**\n   * Gets a SecureContext object generated from input parameters if this\n   * instance was created with createSsl, or null if this instance was created\n   * with createInsecure.\n   */\n  abstract _getConnectionOptions(): ConnectionOptions | null;\n\n  /**\n   * Indicates whether this credentials object creates a secure channel.\n   */\n  abstract _isSecure(): boolean;\n\n  /**\n   * Check whether two channel credentials objects are equal. Two secure\n   * credentials are equal if they were constructed with the same parameters.\n   * @param other The other ChannelCredentials Object\n   */\n  abstract _equals(other: ChannelCredentials): boolean;\n\n  /**\n   * Return a new ChannelCredentials instance with a given set of credentials.\n   * The resulting instance can be used to construct a Channel that communicates\n   * over TLS.\n   * @param rootCerts The root certificate data.\n   * @param privateKey The client certificate private key, if available.\n   * @param certChain The client certificate key chain, if available.\n   * @param verifyOptions Additional options to modify certificate verification\n   */\n  static createSsl(\n    rootCerts?: Buffer | null,\n    privateKey?: Buffer | null,\n    certChain?: Buffer | null,\n    verifyOptions?: VerifyOptions\n  ): ChannelCredentials {\n    verifyIsBufferOrNull(rootCerts, 'Root certificate');\n    verifyIsBufferOrNull(privateKey, 'Private key');\n    verifyIsBufferOrNull(certChain, 'Certificate chain');\n    if (privateKey && !certChain) {\n      throw new Error(\n        'Private key must be given with accompanying certificate chain'\n      );\n    }\n    if (!privateKey && certChain) {\n      throw new Error(\n        'Certificate chain must be given with accompanying private key'\n      );\n    }\n    const secureContext = createSecureContext({\n      ca: rootCerts ?? getDefaultRootsData() ?? undefined,\n      key: privateKey ?? undefined,\n      cert: certChain ?? undefined,\n      ciphers: CIPHER_SUITES,\n    });\n    return new SecureChannelCredentialsImpl(\n      secureContext,\n      verifyOptions ?? {}\n    );\n  }\n\n  /**\n   * Return a new ChannelCredentials instance with credentials created using\n   * the provided secureContext. The resulting instances can be used to\n   * construct a Channel that communicates over TLS. gRPC will not override\n   * anything in the provided secureContext, so the environment variables\n   * GRPC_SSL_CIPHER_SUITES and GRPC_DEFAULT_SSL_ROOTS_FILE_PATH will\n   * not be applied.\n   * @param secureContext The return value of tls.createSecureContext()\n   * @param verifyOptions Additional options to modify certificate verification\n   */\n  static createFromSecureContext(secureContext: SecureContext, verifyOptions?: VerifyOptions): ChannelCredentials {\n    return new SecureChannelCredentialsImpl(\n      secureContext,\n      verifyOptions ?? {}\n    )\n  }\n\n  /**\n   * Return a new ChannelCredentials instance with no credentials.\n   */\n  static createInsecure(): ChannelCredentials {\n    return new InsecureChannelCredentialsImpl();\n  }\n}\n\nclass InsecureChannelCredentialsImpl extends ChannelCredentials {\n  constructor(callCredentials?: CallCredentials) {\n    super(callCredentials);\n  }\n\n  compose(callCredentials: CallCredentials): never {\n    throw new Error('Cannot compose insecure credentials');\n  }\n\n  _getConnectionOptions(): ConnectionOptions | null {\n    return null;\n  }\n  _isSecure(): boolean {\n    return false;\n  }\n  _equals(other: ChannelCredentials): boolean {\n    return other instanceof InsecureChannelCredentialsImpl;\n  }\n}\n\nclass SecureChannelCredentialsImpl extends ChannelCredentials {\n  connectionOptions: ConnectionOptions;\n\n  constructor(\n    private secureContext: SecureContext,\n    private verifyOptions: VerifyOptions\n  ) {\n    super();\n    this.connectionOptions = { \n      secureContext\n    };\n    // Node asserts that this option is a function, so we cannot pass undefined\n    if (verifyOptions?.checkServerIdentity) {\n      this.connectionOptions.checkServerIdentity = verifyOptions.checkServerIdentity;\n    }\n  }\n\n  compose(callCredentials: CallCredentials): ChannelCredentials {\n    const combinedCallCredentials = this.callCredentials.compose(\n      callCredentials\n    );\n    return new ComposedChannelCredentialsImpl(this, combinedCallCredentials);\n  }\n\n  _getConnectionOptions(): ConnectionOptions | null {\n    // Copy to prevent callers from mutating this.connectionOptions\n    return { ...this.connectionOptions };\n  }\n  _isSecure(): boolean {\n    return true;\n  }\n  _equals(other: ChannelCredentials): boolean {\n    if (this === other) {\n      return true;\n    }\n    if (other instanceof SecureChannelCredentialsImpl) {\n      return (\n        this.secureContext === other.secureContext && \n        this.verifyOptions.checkServerIdentity === other.verifyOptions.checkServerIdentity\n        );\n    } else {\n      return false;\n    }\n  }\n}\n\nclass ComposedChannelCredentialsImpl extends ChannelCredentials {\n  constructor(\n    private channelCredentials: SecureChannelCredentialsImpl,\n    callCreds: CallCredentials\n  ) {\n    super(callCreds);\n  }\n  compose(callCredentials: CallCredentials) {\n    const combinedCallCredentials = this.callCredentials.compose(\n      callCredentials\n    );\n    return new ComposedChannelCredentialsImpl(\n      this.channelCredentials,\n      combinedCallCredentials\n    );\n  }\n\n  _getConnectionOptions(): ConnectionOptions | null {\n    return this.channelCredentials._getConnectionOptions();\n  }\n  _isSecure(): boolean {\n    return true;\n  }\n  _equals(other: ChannelCredentials): boolean {\n    if (this === other) {\n      return true;\n    }\n    if (other instanceof ComposedChannelCredentialsImpl) {\n      return (\n        this.channelCredentials._equals(other.channelCredentials) &&\n        this.callCredentials._equals(other.callCredentials)\n      );\n    } else {\n      return false;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}