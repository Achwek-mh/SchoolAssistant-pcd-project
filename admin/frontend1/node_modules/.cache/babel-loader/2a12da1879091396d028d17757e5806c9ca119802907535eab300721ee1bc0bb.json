{"ast":null,"code":"\"use strict\";\n\nvar $protobuf = require(\"../..\");\nmodule.exports = exports = $protobuf.descriptor = $protobuf.Root.fromJSON(require(\"../../google/protobuf/descriptor.json\")).lookup(\".google.protobuf\");\nvar Namespace = $protobuf.Namespace,\n  Root = $protobuf.Root,\n  Enum = $protobuf.Enum,\n  Type = $protobuf.Type,\n  Field = $protobuf.Field,\n  MapField = $protobuf.MapField,\n  OneOf = $protobuf.OneOf,\n  Service = $protobuf.Service,\n  Method = $protobuf.Method;\n\n// --- Root ---\n\n/**\n * Properties of a FileDescriptorSet message.\n * @interface IFileDescriptorSet\n * @property {IFileDescriptorProto[]} file Files\n */\n\n/**\n * Properties of a FileDescriptorProto message.\n * @interface IFileDescriptorProto\n * @property {string} [name] File name\n * @property {string} [package] Package\n * @property {*} [dependency] Not supported\n * @property {*} [publicDependency] Not supported\n * @property {*} [weakDependency] Not supported\n * @property {IDescriptorProto[]} [messageType] Nested message types\n * @property {IEnumDescriptorProto[]} [enumType] Nested enums\n * @property {IServiceDescriptorProto[]} [service] Nested services\n * @property {IFieldDescriptorProto[]} [extension] Nested extension fields\n * @property {IFileOptions} [options] Options\n * @property {*} [sourceCodeInfo] Not supported\n * @property {string} [syntax=\"proto2\"] Syntax\n */\n\n/**\n * Properties of a FileOptions message.\n * @interface IFileOptions\n * @property {string} [javaPackage]\n * @property {string} [javaOuterClassname]\n * @property {boolean} [javaMultipleFiles]\n * @property {boolean} [javaGenerateEqualsAndHash]\n * @property {boolean} [javaStringCheckUtf8]\n * @property {IFileOptionsOptimizeMode} [optimizeFor=1]\n * @property {string} [goPackage]\n * @property {boolean} [ccGenericServices]\n * @property {boolean} [javaGenericServices]\n * @property {boolean} [pyGenericServices]\n * @property {boolean} [deprecated]\n * @property {boolean} [ccEnableArenas]\n * @property {string} [objcClassPrefix]\n * @property {string} [csharpNamespace]\n */\n\n/**\n * Values of he FileOptions.OptimizeMode enum.\n * @typedef IFileOptionsOptimizeMode\n * @type {number}\n * @property {number} SPEED=1\n * @property {number} CODE_SIZE=2\n * @property {number} LITE_RUNTIME=3\n */\n\n/**\n * Creates a root from a descriptor set.\n * @param {IFileDescriptorSet|Reader|Uint8Array} descriptor Descriptor\n * @returns {Root} Root instance\n */\nRoot.fromDescriptor = function fromDescriptor(descriptor) {\n  // Decode the descriptor message if specified as a buffer:\n  if (typeof descriptor.length === \"number\") descriptor = exports.FileDescriptorSet.decode(descriptor);\n  var root = new Root();\n  if (descriptor.file) {\n    var fileDescriptor, filePackage;\n    for (var j = 0, i; j < descriptor.file.length; ++j) {\n      filePackage = root;\n      if ((fileDescriptor = descriptor.file[j])[\"package\"] && fileDescriptor[\"package\"].length) filePackage = root.define(fileDescriptor[\"package\"]);\n      if (fileDescriptor.name && fileDescriptor.name.length) root.files.push(filePackage.filename = fileDescriptor.name);\n      if (fileDescriptor.messageType) for (i = 0; i < fileDescriptor.messageType.length; ++i) filePackage.add(Type.fromDescriptor(fileDescriptor.messageType[i], fileDescriptor.syntax));\n      if (fileDescriptor.enumType) for (i = 0; i < fileDescriptor.enumType.length; ++i) filePackage.add(Enum.fromDescriptor(fileDescriptor.enumType[i]));\n      if (fileDescriptor.extension) for (i = 0; i < fileDescriptor.extension.length; ++i) filePackage.add(Field.fromDescriptor(fileDescriptor.extension[i]));\n      if (fileDescriptor.service) for (i = 0; i < fileDescriptor.service.length; ++i) filePackage.add(Service.fromDescriptor(fileDescriptor.service[i]));\n      var opts = fromDescriptorOptions(fileDescriptor.options, exports.FileOptions);\n      if (opts) {\n        var ks = Object.keys(opts);\n        for (i = 0; i < ks.length; ++i) filePackage.setOption(ks[i], opts[ks[i]]);\n      }\n    }\n  }\n  return root;\n};\n\n/**\n * Converts a root to a descriptor set.\n * @returns {Message<IFileDescriptorSet>} Descriptor\n * @param {string} [syntax=\"proto2\"] Syntax\n */\nRoot.prototype.toDescriptor = function toDescriptor(syntax) {\n  var set = exports.FileDescriptorSet.create();\n  Root_toDescriptorRecursive(this, set.file, syntax);\n  return set;\n};\n\n// Traverses a namespace and assembles the descriptor set\nfunction Root_toDescriptorRecursive(ns, files, syntax) {\n  // Create a new file\n  var file = exports.FileDescriptorProto.create({\n    name: ns.filename || (ns.fullName.substring(1).replace(/\\./g, \"_\") || \"root\") + \".proto\"\n  });\n  if (syntax) file.syntax = syntax;\n  if (!(ns instanceof Root)) file[\"package\"] = ns.fullName.substring(1);\n\n  // Add nested types\n  for (var i = 0, nested; i < ns.nestedArray.length; ++i) if ((nested = ns._nestedArray[i]) instanceof Type) file.messageType.push(nested.toDescriptor(syntax));else if (nested instanceof Enum) file.enumType.push(nested.toDescriptor());else if (nested instanceof Field) file.extension.push(nested.toDescriptor(syntax));else if (nested instanceof Service) file.service.push(nested.toDescriptor());else if (nested instanceof /* plain */Namespace) Root_toDescriptorRecursive(nested, files, syntax); // requires new file\n\n  // Keep package-level options\n  file.options = toDescriptorOptions(ns.options, exports.FileOptions);\n\n  // And keep the file only if there is at least one nested object\n  if (file.messageType.length + file.enumType.length + file.extension.length + file.service.length) files.push(file);\n}\n\n// --- Type ---\n\n/**\n * Properties of a DescriptorProto message.\n * @interface IDescriptorProto\n * @property {string} [name] Message type name\n * @property {IFieldDescriptorProto[]} [field] Fields\n * @property {IFieldDescriptorProto[]} [extension] Extension fields\n * @property {IDescriptorProto[]} [nestedType] Nested message types\n * @property {IEnumDescriptorProto[]} [enumType] Nested enums\n * @property {IDescriptorProtoExtensionRange[]} [extensionRange] Extension ranges\n * @property {IOneofDescriptorProto[]} [oneofDecl] Oneofs\n * @property {IMessageOptions} [options] Not supported\n * @property {IDescriptorProtoReservedRange[]} [reservedRange] Reserved ranges\n * @property {string[]} [reservedName] Reserved names\n */\n\n/**\n * Properties of a MessageOptions message.\n * @interface IMessageOptions\n * @property {boolean} [mapEntry=false] Whether this message is a map entry\n */\n\n/**\n * Properties of an ExtensionRange message.\n * @interface IDescriptorProtoExtensionRange\n * @property {number} [start] Start field id\n * @property {number} [end] End field id\n */\n\n/**\n * Properties of a ReservedRange message.\n * @interface IDescriptorProtoReservedRange\n * @property {number} [start] Start field id\n * @property {number} [end] End field id\n */\n\nvar unnamedMessageIndex = 0;\n\n/**\n * Creates a type from a descriptor.\n * @param {IDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @param {string} [syntax=\"proto2\"] Syntax\n * @returns {Type} Type instance\n */\nType.fromDescriptor = function fromDescriptor(descriptor, syntax) {\n  // Decode the descriptor message if specified as a buffer:\n  if (typeof descriptor.length === \"number\") descriptor = exports.DescriptorProto.decode(descriptor);\n\n  // Create the message type\n  var type = new Type(descriptor.name.length ? descriptor.name : \"Type\" + unnamedMessageIndex++, fromDescriptorOptions(descriptor.options, exports.MessageOptions)),\n    i;\n\n  /* Oneofs */\n  if (descriptor.oneofDecl) for (i = 0; i < descriptor.oneofDecl.length; ++i) type.add(OneOf.fromDescriptor(descriptor.oneofDecl[i]));\n  /* Fields */\n  if (descriptor.field) for (i = 0; i < descriptor.field.length; ++i) {\n    var field = Field.fromDescriptor(descriptor.field[i], syntax);\n    type.add(field);\n    if (descriptor.field[i].hasOwnProperty(\"oneofIndex\"))\n      // eslint-disable-line no-prototype-builtins\n      type.oneofsArray[descriptor.field[i].oneofIndex].add(field);\n  }\n  /* Extension fields */\n  if (descriptor.extension) for (i = 0; i < descriptor.extension.length; ++i) type.add(Field.fromDescriptor(descriptor.extension[i], syntax));\n  /* Nested types */\n  if (descriptor.nestedType) for (i = 0; i < descriptor.nestedType.length; ++i) {\n    type.add(Type.fromDescriptor(descriptor.nestedType[i], syntax));\n    if (descriptor.nestedType[i].options && descriptor.nestedType[i].options.mapEntry) type.setOption(\"map_entry\", true);\n  }\n  /* Nested enums */\n  if (descriptor.enumType) for (i = 0; i < descriptor.enumType.length; ++i) type.add(Enum.fromDescriptor(descriptor.enumType[i]));\n  /* Extension ranges */\n  if (descriptor.extensionRange && descriptor.extensionRange.length) {\n    type.extensions = [];\n    for (i = 0; i < descriptor.extensionRange.length; ++i) type.extensions.push([descriptor.extensionRange[i].start, descriptor.extensionRange[i].end]);\n  }\n  /* Reserved... */\n  if (descriptor.reservedRange && descriptor.reservedRange.length || descriptor.reservedName && descriptor.reservedName.length) {\n    type.reserved = [];\n    /* Ranges */\n    if (descriptor.reservedRange) for (i = 0; i < descriptor.reservedRange.length; ++i) type.reserved.push([descriptor.reservedRange[i].start, descriptor.reservedRange[i].end]);\n    /* Names */\n    if (descriptor.reservedName) for (i = 0; i < descriptor.reservedName.length; ++i) type.reserved.push(descriptor.reservedName[i]);\n  }\n  return type;\n};\n\n/**\n * Converts a type to a descriptor.\n * @returns {Message<IDescriptorProto>} Descriptor\n * @param {string} [syntax=\"proto2\"] Syntax\n */\nType.prototype.toDescriptor = function toDescriptor(syntax) {\n  var descriptor = exports.DescriptorProto.create({\n      name: this.name\n    }),\n    i;\n\n  /* Fields */\n  for (i = 0; i < this.fieldsArray.length; ++i) {\n    var fieldDescriptor;\n    descriptor.field.push(fieldDescriptor = this._fieldsArray[i].toDescriptor(syntax));\n    if (this._fieldsArray[i] instanceof MapField) {\n      // map fields are repeated FieldNameEntry\n      var keyType = toDescriptorType(this._fieldsArray[i].keyType, this._fieldsArray[i].resolvedKeyType),\n        valueType = toDescriptorType(this._fieldsArray[i].type, this._fieldsArray[i].resolvedType),\n        valueTypeName = valueType === /* type */11 || valueType === /* enum */14 ? this._fieldsArray[i].resolvedType && shortname(this.parent, this._fieldsArray[i].resolvedType) || this._fieldsArray[i].type : undefined;\n      descriptor.nestedType.push(exports.DescriptorProto.create({\n        name: fieldDescriptor.typeName,\n        field: [exports.FieldDescriptorProto.create({\n          name: \"key\",\n          number: 1,\n          label: 1,\n          type: keyType\n        }),\n        // can't reference a type or enum\n        exports.FieldDescriptorProto.create({\n          name: \"value\",\n          number: 2,\n          label: 1,\n          type: valueType,\n          typeName: valueTypeName\n        })],\n        options: exports.MessageOptions.create({\n          mapEntry: true\n        })\n      }));\n    }\n  }\n  /* Oneofs */\n  for (i = 0; i < this.oneofsArray.length; ++i) descriptor.oneofDecl.push(this._oneofsArray[i].toDescriptor());\n  /* Nested... */\n  for (i = 0; i < this.nestedArray.length; ++i) {\n    /* Extension fields */if (this._nestedArray[i] instanceof Field) descriptor.field.push(this._nestedArray[i].toDescriptor(syntax));\n    /* Types */else if (this._nestedArray[i] instanceof Type) descriptor.nestedType.push(this._nestedArray[i].toDescriptor(syntax));\n    /* Enums */else if (this._nestedArray[i] instanceof Enum) descriptor.enumType.push(this._nestedArray[i].toDescriptor());\n    // plain nested namespaces become packages instead in Root#toDescriptor\n  }\n  /* Extension ranges */\n  if (this.extensions) for (i = 0; i < this.extensions.length; ++i) descriptor.extensionRange.push(exports.DescriptorProto.ExtensionRange.create({\n    start: this.extensions[i][0],\n    end: this.extensions[i][1]\n  }));\n  /* Reserved... */\n  if (this.reserved) for (i = 0; i < this.reserved.length; ++i) /* Names */if (typeof this.reserved[i] === \"string\") descriptor.reservedName.push(this.reserved[i]);\n  /* Ranges */else descriptor.reservedRange.push(exports.DescriptorProto.ReservedRange.create({\n    start: this.reserved[i][0],\n    end: this.reserved[i][1]\n  }));\n  descriptor.options = toDescriptorOptions(this.options, exports.MessageOptions);\n  return descriptor;\n};\n\n// --- Field ---\n\n/**\n * Properties of a FieldDescriptorProto message.\n * @interface IFieldDescriptorProto\n * @property {string} [name] Field name\n * @property {number} [number] Field id\n * @property {IFieldDescriptorProtoLabel} [label] Field rule\n * @property {IFieldDescriptorProtoType} [type] Field basic type\n * @property {string} [typeName] Field type name\n * @property {string} [extendee] Extended type name\n * @property {string} [defaultValue] Literal default value\n * @property {number} [oneofIndex] Oneof index if part of a oneof\n * @property {*} [jsonName] Not supported\n * @property {IFieldOptions} [options] Field options\n */\n\n/**\n * Values of the FieldDescriptorProto.Label enum.\n * @typedef IFieldDescriptorProtoLabel\n * @type {number}\n * @property {number} LABEL_OPTIONAL=1\n * @property {number} LABEL_REQUIRED=2\n * @property {number} LABEL_REPEATED=3\n */\n\n/**\n * Values of the FieldDescriptorProto.Type enum.\n * @typedef IFieldDescriptorProtoType\n * @type {number}\n * @property {number} TYPE_DOUBLE=1\n * @property {number} TYPE_FLOAT=2\n * @property {number} TYPE_INT64=3\n * @property {number} TYPE_UINT64=4\n * @property {number} TYPE_INT32=5\n * @property {number} TYPE_FIXED64=6\n * @property {number} TYPE_FIXED32=7\n * @property {number} TYPE_BOOL=8\n * @property {number} TYPE_STRING=9\n * @property {number} TYPE_GROUP=10\n * @property {number} TYPE_MESSAGE=11\n * @property {number} TYPE_BYTES=12\n * @property {number} TYPE_UINT32=13\n * @property {number} TYPE_ENUM=14\n * @property {number} TYPE_SFIXED32=15\n * @property {number} TYPE_SFIXED64=16\n * @property {number} TYPE_SINT32=17\n * @property {number} TYPE_SINT64=18\n */\n\n/**\n * Properties of a FieldOptions message.\n * @interface IFieldOptions\n * @property {boolean} [packed] Whether packed or not (defaults to `false` for proto2 and `true` for proto3)\n * @property {IFieldOptionsJSType} [jstype] JavaScript value type (not used by protobuf.js)\n */\n\n/**\n * Values of the FieldOptions.JSType enum.\n * @typedef IFieldOptionsJSType\n * @type {number}\n * @property {number} JS_NORMAL=0\n * @property {number} JS_STRING=1\n * @property {number} JS_NUMBER=2\n */\n\n// copied here from parse.js\nvar numberRe = /^(?![eE])[0-9]*(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/;\n\n/**\n * Creates a field from a descriptor.\n * @param {IFieldDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @param {string} [syntax=\"proto2\"] Syntax\n * @returns {Field} Field instance\n */\nField.fromDescriptor = function fromDescriptor(descriptor, syntax) {\n  // Decode the descriptor message if specified as a buffer:\n  if (typeof descriptor.length === \"number\") descriptor = exports.DescriptorProto.decode(descriptor);\n  if (typeof descriptor.number !== \"number\") throw Error(\"missing field id\");\n\n  // Rewire field type\n  var fieldType;\n  if (descriptor.typeName && descriptor.typeName.length) fieldType = descriptor.typeName;else fieldType = fromDescriptorType(descriptor.type);\n\n  // Rewire field rule\n  var fieldRule;\n  switch (descriptor.label) {\n    // 0 is reserved for errors\n    case 1:\n      fieldRule = undefined;\n      break;\n    case 2:\n      fieldRule = \"required\";\n      break;\n    case 3:\n      fieldRule = \"repeated\";\n      break;\n    default:\n      throw Error(\"illegal label: \" + descriptor.label);\n  }\n  var extendee = descriptor.extendee;\n  if (descriptor.extendee !== undefined) {\n    extendee = extendee.length ? extendee : undefined;\n  }\n  var field = new Field(descriptor.name.length ? descriptor.name : \"field\" + descriptor.number, descriptor.number, fieldType, fieldRule, extendee);\n  field.options = fromDescriptorOptions(descriptor.options, exports.FieldOptions);\n  if (descriptor.defaultValue && descriptor.defaultValue.length) {\n    var defaultValue = descriptor.defaultValue;\n    switch (defaultValue) {\n      case \"true\":\n      case \"TRUE\":\n        defaultValue = true;\n        break;\n      case \"false\":\n      case \"FALSE\":\n        defaultValue = false;\n        break;\n      default:\n        var match = numberRe.exec(defaultValue);\n        if (match) defaultValue = parseInt(defaultValue); // eslint-disable-line radix\n        break;\n    }\n    field.setOption(\"default\", defaultValue);\n  }\n  if (packableDescriptorType(descriptor.type)) {\n    if (syntax === \"proto3\") {\n      // defaults to packed=true (internal preset is packed=true)\n      if (descriptor.options && !descriptor.options.packed) field.setOption(\"packed\", false);\n    } else if (!(descriptor.options && descriptor.options.packed))\n      // defaults to packed=false\n      field.setOption(\"packed\", false);\n  }\n  return field;\n};\n\n/**\n * Converts a field to a descriptor.\n * @returns {Message<IFieldDescriptorProto>} Descriptor\n * @param {string} [syntax=\"proto2\"] Syntax\n */\nField.prototype.toDescriptor = function toDescriptor(syntax) {\n  var descriptor = exports.FieldDescriptorProto.create({\n    name: this.name,\n    number: this.id\n  });\n  if (this.map) {\n    descriptor.type = 11; // message\n    descriptor.typeName = $protobuf.util.ucFirst(this.name); // fieldName -> FieldNameEntry (built in Type#toDescriptor)\n    descriptor.label = 3; // repeated\n  } else {\n    // Rewire field type\n    switch (descriptor.type = toDescriptorType(this.type, this.resolve().resolvedType)) {\n      case 10: // group\n      case 11: // type\n      case 14:\n        // enum\n        descriptor.typeName = this.resolvedType ? shortname(this.parent, this.resolvedType) : this.type;\n        break;\n    }\n\n    // Rewire field rule\n    switch (this.rule) {\n      case \"repeated\":\n        descriptor.label = 3;\n        break;\n      case \"required\":\n        descriptor.label = 2;\n        break;\n      default:\n        descriptor.label = 1;\n        break;\n    }\n  }\n\n  // Handle extension field\n  descriptor.extendee = this.extensionField ? this.extensionField.parent.fullName : this.extend;\n\n  // Handle part of oneof\n  if (this.partOf) if ((descriptor.oneofIndex = this.parent.oneofsArray.indexOf(this.partOf)) < 0) throw Error(\"missing oneof\");\n  if (this.options) {\n    descriptor.options = toDescriptorOptions(this.options, exports.FieldOptions);\n    if (this.options[\"default\"] != null) descriptor.defaultValue = String(this.options[\"default\"]);\n  }\n  if (syntax === \"proto3\") {\n    // defaults to packed=true\n    if (!this.packed) (descriptor.options || (descriptor.options = exports.FieldOptions.create())).packed = false;\n  } else if (this.packed)\n    // defaults to packed=false\n    (descriptor.options || (descriptor.options = exports.FieldOptions.create())).packed = true;\n  return descriptor;\n};\n\n// --- Enum ---\n\n/**\n * Properties of an EnumDescriptorProto message.\n * @interface IEnumDescriptorProto\n * @property {string} [name] Enum name\n * @property {IEnumValueDescriptorProto[]} [value] Enum values\n * @property {IEnumOptions} [options] Enum options\n */\n\n/**\n * Properties of an EnumValueDescriptorProto message.\n * @interface IEnumValueDescriptorProto\n * @property {string} [name] Name\n * @property {number} [number] Value\n * @property {*} [options] Not supported\n */\n\n/**\n * Properties of an EnumOptions message.\n * @interface IEnumOptions\n * @property {boolean} [allowAlias] Whether aliases are allowed\n * @property {boolean} [deprecated]\n */\n\nvar unnamedEnumIndex = 0;\n\n/**\n * Creates an enum from a descriptor.\n * @param {IEnumDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @returns {Enum} Enum instance\n */\nEnum.fromDescriptor = function fromDescriptor(descriptor) {\n  // Decode the descriptor message if specified as a buffer:\n  if (typeof descriptor.length === \"number\") descriptor = exports.EnumDescriptorProto.decode(descriptor);\n\n  // Construct values object\n  var values = {};\n  if (descriptor.value) for (var i = 0; i < descriptor.value.length; ++i) {\n    var name = descriptor.value[i].name,\n      value = descriptor.value[i].number || 0;\n    values[name && name.length ? name : \"NAME\" + value] = value;\n  }\n  return new Enum(descriptor.name && descriptor.name.length ? descriptor.name : \"Enum\" + unnamedEnumIndex++, values, fromDescriptorOptions(descriptor.options, exports.EnumOptions));\n};\n\n/**\n * Converts an enum to a descriptor.\n * @returns {Message<IEnumDescriptorProto>} Descriptor\n */\nEnum.prototype.toDescriptor = function toDescriptor() {\n  // Values\n  var values = [];\n  for (var i = 0, ks = Object.keys(this.values); i < ks.length; ++i) values.push(exports.EnumValueDescriptorProto.create({\n    name: ks[i],\n    number: this.values[ks[i]]\n  }));\n  return exports.EnumDescriptorProto.create({\n    name: this.name,\n    value: values,\n    options: toDescriptorOptions(this.options, exports.EnumOptions)\n  });\n};\n\n// --- OneOf ---\n\n/**\n * Properties of a OneofDescriptorProto message.\n * @interface IOneofDescriptorProto\n * @property {string} [name] Oneof name\n * @property {*} [options] Not supported\n */\n\nvar unnamedOneofIndex = 0;\n\n/**\n * Creates a oneof from a descriptor.\n * @param {IOneofDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @returns {OneOf} OneOf instance\n */\nOneOf.fromDescriptor = function fromDescriptor(descriptor) {\n  // Decode the descriptor message if specified as a buffer:\n  if (typeof descriptor.length === \"number\") descriptor = exports.OneofDescriptorProto.decode(descriptor);\n  return new OneOf(\n  // unnamedOneOfIndex is global, not per type, because we have no ref to a type here\n  descriptor.name && descriptor.name.length ? descriptor.name : \"oneof\" + unnamedOneofIndex++\n  // fromDescriptorOptions(descriptor.options, exports.OneofOptions) - only uninterpreted_option\n  );\n};\n\n/**\n * Converts a oneof to a descriptor.\n * @returns {Message<IOneofDescriptorProto>} Descriptor\n */\nOneOf.prototype.toDescriptor = function toDescriptor() {\n  return exports.OneofDescriptorProto.create({\n    name: this.name\n    // options: toDescriptorOptions(this.options, exports.OneofOptions) - only uninterpreted_option\n  });\n};\n\n// --- Service ---\n\n/**\n * Properties of a ServiceDescriptorProto message.\n * @interface IServiceDescriptorProto\n * @property {string} [name] Service name\n * @property {IMethodDescriptorProto[]} [method] Methods\n * @property {IServiceOptions} [options] Options\n */\n\n/**\n * Properties of a ServiceOptions message.\n * @interface IServiceOptions\n * @property {boolean} [deprecated]\n */\n\nvar unnamedServiceIndex = 0;\n\n/**\n * Creates a service from a descriptor.\n * @param {IServiceDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @returns {Service} Service instance\n */\nService.fromDescriptor = function fromDescriptor(descriptor) {\n  // Decode the descriptor message if specified as a buffer:\n  if (typeof descriptor.length === \"number\") descriptor = exports.ServiceDescriptorProto.decode(descriptor);\n  var service = new Service(descriptor.name && descriptor.name.length ? descriptor.name : \"Service\" + unnamedServiceIndex++, fromDescriptorOptions(descriptor.options, exports.ServiceOptions));\n  if (descriptor.method) for (var i = 0; i < descriptor.method.length; ++i) service.add(Method.fromDescriptor(descriptor.method[i]));\n  return service;\n};\n\n/**\n * Converts a service to a descriptor.\n * @returns {Message<IServiceDescriptorProto>} Descriptor\n */\nService.prototype.toDescriptor = function toDescriptor() {\n  // Methods\n  var methods = [];\n  for (var i = 0; i < this.methodsArray.length; ++i) methods.push(this._methodsArray[i].toDescriptor());\n  return exports.ServiceDescriptorProto.create({\n    name: this.name,\n    method: methods,\n    options: toDescriptorOptions(this.options, exports.ServiceOptions)\n  });\n};\n\n// --- Method ---\n\n/**\n * Properties of a MethodDescriptorProto message.\n * @interface IMethodDescriptorProto\n * @property {string} [name] Method name\n * @property {string} [inputType] Request type name\n * @property {string} [outputType] Response type name\n * @property {IMethodOptions} [options] Not supported\n * @property {boolean} [clientStreaming=false] Whether requests are streamed\n * @property {boolean} [serverStreaming=false] Whether responses are streamed\n */\n\n/**\n * Properties of a MethodOptions message.\n * @interface IMethodOptions\n * @property {boolean} [deprecated]\n */\n\nvar unnamedMethodIndex = 0;\n\n/**\n * Creates a method from a descriptor.\n * @param {IMethodDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @returns {Method} Reflected method instance\n */\nMethod.fromDescriptor = function fromDescriptor(descriptor) {\n  // Decode the descriptor message if specified as a buffer:\n  if (typeof descriptor.length === \"number\") descriptor = exports.MethodDescriptorProto.decode(descriptor);\n  return new Method(\n  // unnamedMethodIndex is global, not per service, because we have no ref to a service here\n  descriptor.name && descriptor.name.length ? descriptor.name : \"Method\" + unnamedMethodIndex++, \"rpc\", descriptor.inputType, descriptor.outputType, Boolean(descriptor.clientStreaming), Boolean(descriptor.serverStreaming), fromDescriptorOptions(descriptor.options, exports.MethodOptions));\n};\n\n/**\n * Converts a method to a descriptor.\n * @returns {Message<IMethodDescriptorProto>} Descriptor\n */\nMethod.prototype.toDescriptor = function toDescriptor() {\n  return exports.MethodDescriptorProto.create({\n    name: this.name,\n    inputType: this.resolvedRequestType ? this.resolvedRequestType.fullName : this.requestType,\n    outputType: this.resolvedResponseType ? this.resolvedResponseType.fullName : this.responseType,\n    clientStreaming: this.requestStream,\n    serverStreaming: this.responseStream,\n    options: toDescriptorOptions(this.options, exports.MethodOptions)\n  });\n};\n\n// --- utility ---\n\n// Converts a descriptor type to a protobuf.js basic type\nfunction fromDescriptorType(type) {\n  switch (type) {\n    // 0 is reserved for errors\n    case 1:\n      return \"double\";\n    case 2:\n      return \"float\";\n    case 3:\n      return \"int64\";\n    case 4:\n      return \"uint64\";\n    case 5:\n      return \"int32\";\n    case 6:\n      return \"fixed64\";\n    case 7:\n      return \"fixed32\";\n    case 8:\n      return \"bool\";\n    case 9:\n      return \"string\";\n    case 12:\n      return \"bytes\";\n    case 13:\n      return \"uint32\";\n    case 15:\n      return \"sfixed32\";\n    case 16:\n      return \"sfixed64\";\n    case 17:\n      return \"sint32\";\n    case 18:\n      return \"sint64\";\n  }\n  throw Error(\"illegal type: \" + type);\n}\n\n// Tests if a descriptor type is packable\nfunction packableDescriptorType(type) {\n  switch (type) {\n    case 1: // double\n    case 2: // float\n    case 3: // int64\n    case 4: // uint64\n    case 5: // int32\n    case 6: // fixed64\n    case 7: // fixed32\n    case 8: // bool\n    case 13: // uint32\n    case 14: // enum (!)\n    case 15: // sfixed32\n    case 16: // sfixed64\n    case 17: // sint32\n    case 18:\n      // sint64\n      return true;\n  }\n  return false;\n}\n\n// Converts a protobuf.js basic type to a descriptor type\nfunction toDescriptorType(type, resolvedType) {\n  switch (type) {\n    // 0 is reserved for errors\n    case \"double\":\n      return 1;\n    case \"float\":\n      return 2;\n    case \"int64\":\n      return 3;\n    case \"uint64\":\n      return 4;\n    case \"int32\":\n      return 5;\n    case \"fixed64\":\n      return 6;\n    case \"fixed32\":\n      return 7;\n    case \"bool\":\n      return 8;\n    case \"string\":\n      return 9;\n    case \"bytes\":\n      return 12;\n    case \"uint32\":\n      return 13;\n    case \"sfixed32\":\n      return 15;\n    case \"sfixed64\":\n      return 16;\n    case \"sint32\":\n      return 17;\n    case \"sint64\":\n      return 18;\n  }\n  if (resolvedType instanceof Enum) return 14;\n  if (resolvedType instanceof Type) return resolvedType.group ? 10 : 11;\n  throw Error(\"illegal type: \" + type);\n}\n\n// Converts descriptor options to an options object\nfunction fromDescriptorOptions(options, type) {\n  if (!options) return undefined;\n  var out = [];\n  for (var i = 0, field, key, val; i < type.fieldsArray.length; ++i) if ((key = (field = type._fieldsArray[i]).name) !== \"uninterpretedOption\") if (options.hasOwnProperty(key)) {\n    // eslint-disable-line no-prototype-builtins\n    val = options[key];\n    if (field.resolvedType instanceof Enum && typeof val === \"number\" && field.resolvedType.valuesById[val] !== undefined) val = field.resolvedType.valuesById[val];\n    out.push(underScore(key), val);\n  }\n  return out.length ? $protobuf.util.toObject(out) : undefined;\n}\n\n// Converts an options object to descriptor options\nfunction toDescriptorOptions(options, type) {\n  if (!options) return undefined;\n  var out = [];\n  for (var i = 0, ks = Object.keys(options), key, val; i < ks.length; ++i) {\n    val = options[key = ks[i]];\n    if (key === \"default\") continue;\n    var field = type.fields[key];\n    if (!field && !(field = type.fields[key = $protobuf.util.camelCase(key)])) continue;\n    out.push(key, val);\n  }\n  return out.length ? type.fromObject($protobuf.util.toObject(out)) : undefined;\n}\n\n// Calculates the shortest relative path from `from` to `to`.\nfunction shortname(from, to) {\n  var fromPath = from.fullName.split(\".\"),\n    toPath = to.fullName.split(\".\"),\n    i = 0,\n    j = 0,\n    k = toPath.length - 1;\n  if (!(from instanceof Root) && to instanceof Namespace) while (i < fromPath.length && j < k && fromPath[i] === toPath[j]) {\n    var other = to.lookup(fromPath[i++], true);\n    if (other !== null && other !== to) break;\n    ++j;\n  } else for (; i < fromPath.length && j < k && fromPath[i] === toPath[j]; ++i, ++j);\n  return toPath.slice(j).join(\".\");\n}\n\n// copied here from cli/targets/proto.js\nfunction underScore(str) {\n  return str.substring(0, 1) + str.substring(1).replace(/([A-Z])(?=[a-z]|$)/g, function ($0, $1) {\n    return \"_\" + $1.toLowerCase();\n  });\n}\n\n// --- exports ---\n\n/**\n * Reflected file descriptor set.\n * @name FileDescriptorSet\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected file descriptor proto.\n * @name FileDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected descriptor proto.\n * @name DescriptorProto\n * @type {Type}\n * @property {Type} ExtensionRange\n * @property {Type} ReservedRange\n * @const\n * @tstype $protobuf.Type & {\n *     ExtensionRange: $protobuf.Type,\n *     ReservedRange: $protobuf.Type\n * }\n */\n\n/**\n * Reflected field descriptor proto.\n * @name FieldDescriptorProto\n * @type {Type}\n * @property {Enum} Label\n * @property {Enum} Type\n * @const\n * @tstype $protobuf.Type & {\n *     Label: $protobuf.Enum,\n *     Type: $protobuf.Enum\n * }\n */\n\n/**\n * Reflected oneof descriptor proto.\n * @name OneofDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected enum descriptor proto.\n * @name EnumDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected service descriptor proto.\n * @name ServiceDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected enum value descriptor proto.\n * @name EnumValueDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected method descriptor proto.\n * @name MethodDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected file options.\n * @name FileOptions\n * @type {Type}\n * @property {Enum} OptimizeMode\n * @const\n * @tstype $protobuf.Type & {\n *     OptimizeMode: $protobuf.Enum\n * }\n */\n\n/**\n * Reflected message options.\n * @name MessageOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected field options.\n * @name FieldOptions\n * @type {Type}\n * @property {Enum} CType\n * @property {Enum} JSType\n * @const\n * @tstype $protobuf.Type & {\n *     CType: $protobuf.Enum,\n *     JSType: $protobuf.Enum\n * }\n */\n\n/**\n * Reflected oneof options.\n * @name OneofOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected enum options.\n * @name EnumOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected enum value options.\n * @name EnumValueOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected service options.\n * @name ServiceOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected method options.\n * @name MethodOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected uninterpretet option.\n * @name UninterpretedOption\n * @type {Type}\n * @property {Type} NamePart\n * @const\n * @tstype $protobuf.Type & {\n *     NamePart: $protobuf.Type\n * }\n */\n\n/**\n * Reflected source code info.\n * @name SourceCodeInfo\n * @type {Type}\n * @property {Type} Location\n * @const\n * @tstype $protobuf.Type & {\n *     Location: $protobuf.Type\n * }\n */\n\n/**\n * Reflected generated code info.\n * @name GeneratedCodeInfo\n * @type {Type}\n * @property {Type} Annotation\n * @const\n * @tstype $protobuf.Type & {\n *     Annotation: $protobuf.Type\n * }\n */","map":{"version":3,"names":["$protobuf","require","module","exports","descriptor","Root","fromJSON","lookup","Namespace","Enum","Type","Field","MapField","OneOf","Service","Method","fromDescriptor","length","FileDescriptorSet","decode","root","file","fileDescriptor","filePackage","j","i","define","name","files","push","filename","messageType","add","syntax","enumType","extension","service","opts","fromDescriptorOptions","options","FileOptions","ks","Object","keys","setOption","prototype","toDescriptor","set","create","Root_toDescriptorRecursive","ns","FileDescriptorProto","fullName","substring","replace","nested","nestedArray","_nestedArray","toDescriptorOptions","unnamedMessageIndex","DescriptorProto","type","MessageOptions","oneofDecl","field","hasOwnProperty","oneofsArray","oneofIndex","nestedType","mapEntry","extensionRange","extensions","start","end","reservedRange","reservedName","reserved","fieldsArray","fieldDescriptor","_fieldsArray","keyType","toDescriptorType","resolvedKeyType","valueType","resolvedType","valueTypeName","shortname","parent","undefined","typeName","FieldDescriptorProto","number","label","_oneofsArray","ExtensionRange","ReservedRange","numberRe","Error","fieldType","fromDescriptorType","fieldRule","extendee","FieldOptions","defaultValue","match","exec","parseInt","packableDescriptorType","packed","id","map","util","ucFirst","resolve","rule","extensionField","extend","partOf","indexOf","String","unnamedEnumIndex","EnumDescriptorProto","values","value","EnumOptions","EnumValueDescriptorProto","unnamedOneofIndex","OneofDescriptorProto","unnamedServiceIndex","ServiceDescriptorProto","ServiceOptions","method","methods","methodsArray","_methodsArray","unnamedMethodIndex","MethodDescriptorProto","inputType","outputType","Boolean","clientStreaming","serverStreaming","MethodOptions","resolvedRequestType","requestType","resolvedResponseType","responseType","requestStream","responseStream","group","out","key","val","valuesById","underScore","toObject","fields","camelCase","fromObject","from","to","fromPath","split","toPath","k","other","slice","join","str","$0","$1","toLowerCase"],"sources":["/home/achwak/node_modules/@grpc/proto-loader/node_modules/protobufjs/ext/descriptor/index.js"],"sourcesContent":["\"use strict\";\nvar $protobuf = require(\"../..\");\nmodule.exports = exports = $protobuf.descriptor = $protobuf.Root.fromJSON(require(\"../../google/protobuf/descriptor.json\")).lookup(\".google.protobuf\");\n\nvar Namespace = $protobuf.Namespace,\n    Root      = $protobuf.Root,\n    Enum      = $protobuf.Enum,\n    Type      = $protobuf.Type,\n    Field     = $protobuf.Field,\n    MapField  = $protobuf.MapField,\n    OneOf     = $protobuf.OneOf,\n    Service   = $protobuf.Service,\n    Method    = $protobuf.Method;\n\n// --- Root ---\n\n/**\n * Properties of a FileDescriptorSet message.\n * @interface IFileDescriptorSet\n * @property {IFileDescriptorProto[]} file Files\n */\n\n/**\n * Properties of a FileDescriptorProto message.\n * @interface IFileDescriptorProto\n * @property {string} [name] File name\n * @property {string} [package] Package\n * @property {*} [dependency] Not supported\n * @property {*} [publicDependency] Not supported\n * @property {*} [weakDependency] Not supported\n * @property {IDescriptorProto[]} [messageType] Nested message types\n * @property {IEnumDescriptorProto[]} [enumType] Nested enums\n * @property {IServiceDescriptorProto[]} [service] Nested services\n * @property {IFieldDescriptorProto[]} [extension] Nested extension fields\n * @property {IFileOptions} [options] Options\n * @property {*} [sourceCodeInfo] Not supported\n * @property {string} [syntax=\"proto2\"] Syntax\n */\n\n/**\n * Properties of a FileOptions message.\n * @interface IFileOptions\n * @property {string} [javaPackage]\n * @property {string} [javaOuterClassname]\n * @property {boolean} [javaMultipleFiles]\n * @property {boolean} [javaGenerateEqualsAndHash]\n * @property {boolean} [javaStringCheckUtf8]\n * @property {IFileOptionsOptimizeMode} [optimizeFor=1]\n * @property {string} [goPackage]\n * @property {boolean} [ccGenericServices]\n * @property {boolean} [javaGenericServices]\n * @property {boolean} [pyGenericServices]\n * @property {boolean} [deprecated]\n * @property {boolean} [ccEnableArenas]\n * @property {string} [objcClassPrefix]\n * @property {string} [csharpNamespace]\n */\n\n/**\n * Values of he FileOptions.OptimizeMode enum.\n * @typedef IFileOptionsOptimizeMode\n * @type {number}\n * @property {number} SPEED=1\n * @property {number} CODE_SIZE=2\n * @property {number} LITE_RUNTIME=3\n */\n\n/**\n * Creates a root from a descriptor set.\n * @param {IFileDescriptorSet|Reader|Uint8Array} descriptor Descriptor\n * @returns {Root} Root instance\n */\nRoot.fromDescriptor = function fromDescriptor(descriptor) {\n\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\")\n        descriptor = exports.FileDescriptorSet.decode(descriptor);\n\n    var root = new Root();\n\n    if (descriptor.file) {\n        var fileDescriptor,\n            filePackage;\n        for (var j = 0, i; j < descriptor.file.length; ++j) {\n            filePackage = root;\n            if ((fileDescriptor = descriptor.file[j])[\"package\"] && fileDescriptor[\"package\"].length)\n                filePackage = root.define(fileDescriptor[\"package\"]);\n            if (fileDescriptor.name && fileDescriptor.name.length)\n                root.files.push(filePackage.filename = fileDescriptor.name);\n            if (fileDescriptor.messageType)\n                for (i = 0; i < fileDescriptor.messageType.length; ++i)\n                    filePackage.add(Type.fromDescriptor(fileDescriptor.messageType[i], fileDescriptor.syntax));\n            if (fileDescriptor.enumType)\n                for (i = 0; i < fileDescriptor.enumType.length; ++i)\n                    filePackage.add(Enum.fromDescriptor(fileDescriptor.enumType[i]));\n            if (fileDescriptor.extension)\n                for (i = 0; i < fileDescriptor.extension.length; ++i)\n                    filePackage.add(Field.fromDescriptor(fileDescriptor.extension[i]));\n            if (fileDescriptor.service)\n                for (i = 0; i < fileDescriptor.service.length; ++i)\n                    filePackage.add(Service.fromDescriptor(fileDescriptor.service[i]));\n            var opts = fromDescriptorOptions(fileDescriptor.options, exports.FileOptions);\n            if (opts) {\n                var ks = Object.keys(opts);\n                for (i = 0; i < ks.length; ++i)\n                    filePackage.setOption(ks[i], opts[ks[i]]);\n            }\n        }\n    }\n\n    return root;\n};\n\n/**\n * Converts a root to a descriptor set.\n * @returns {Message<IFileDescriptorSet>} Descriptor\n * @param {string} [syntax=\"proto2\"] Syntax\n */\nRoot.prototype.toDescriptor = function toDescriptor(syntax) {\n    var set = exports.FileDescriptorSet.create();\n    Root_toDescriptorRecursive(this, set.file, syntax);\n    return set;\n};\n\n// Traverses a namespace and assembles the descriptor set\nfunction Root_toDescriptorRecursive(ns, files, syntax) {\n\n    // Create a new file\n    var file = exports.FileDescriptorProto.create({ name: ns.filename || (ns.fullName.substring(1).replace(/\\./g, \"_\") || \"root\") + \".proto\" });\n    if (syntax)\n        file.syntax = syntax;\n    if (!(ns instanceof Root))\n        file[\"package\"] = ns.fullName.substring(1);\n\n    // Add nested types\n    for (var i = 0, nested; i < ns.nestedArray.length; ++i)\n        if ((nested = ns._nestedArray[i]) instanceof Type)\n            file.messageType.push(nested.toDescriptor(syntax));\n        else if (nested instanceof Enum)\n            file.enumType.push(nested.toDescriptor());\n        else if (nested instanceof Field)\n            file.extension.push(nested.toDescriptor(syntax));\n        else if (nested instanceof Service)\n            file.service.push(nested.toDescriptor());\n        else if (nested instanceof /* plain */ Namespace)\n            Root_toDescriptorRecursive(nested, files, syntax); // requires new file\n\n    // Keep package-level options\n    file.options = toDescriptorOptions(ns.options, exports.FileOptions);\n\n    // And keep the file only if there is at least one nested object\n    if (file.messageType.length + file.enumType.length + file.extension.length + file.service.length)\n        files.push(file);\n}\n\n// --- Type ---\n\n/**\n * Properties of a DescriptorProto message.\n * @interface IDescriptorProto\n * @property {string} [name] Message type name\n * @property {IFieldDescriptorProto[]} [field] Fields\n * @property {IFieldDescriptorProto[]} [extension] Extension fields\n * @property {IDescriptorProto[]} [nestedType] Nested message types\n * @property {IEnumDescriptorProto[]} [enumType] Nested enums\n * @property {IDescriptorProtoExtensionRange[]} [extensionRange] Extension ranges\n * @property {IOneofDescriptorProto[]} [oneofDecl] Oneofs\n * @property {IMessageOptions} [options] Not supported\n * @property {IDescriptorProtoReservedRange[]} [reservedRange] Reserved ranges\n * @property {string[]} [reservedName] Reserved names\n */\n\n/**\n * Properties of a MessageOptions message.\n * @interface IMessageOptions\n * @property {boolean} [mapEntry=false] Whether this message is a map entry\n */\n\n/**\n * Properties of an ExtensionRange message.\n * @interface IDescriptorProtoExtensionRange\n * @property {number} [start] Start field id\n * @property {number} [end] End field id\n */\n\n/**\n * Properties of a ReservedRange message.\n * @interface IDescriptorProtoReservedRange\n * @property {number} [start] Start field id\n * @property {number} [end] End field id\n */\n\nvar unnamedMessageIndex = 0;\n\n/**\n * Creates a type from a descriptor.\n * @param {IDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @param {string} [syntax=\"proto2\"] Syntax\n * @returns {Type} Type instance\n */\nType.fromDescriptor = function fromDescriptor(descriptor, syntax) {\n\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\")\n        descriptor = exports.DescriptorProto.decode(descriptor);\n\n    // Create the message type\n    var type = new Type(descriptor.name.length ? descriptor.name : \"Type\" + unnamedMessageIndex++, fromDescriptorOptions(descriptor.options, exports.MessageOptions)),\n        i;\n\n    /* Oneofs */ if (descriptor.oneofDecl)\n        for (i = 0; i < descriptor.oneofDecl.length; ++i)\n            type.add(OneOf.fromDescriptor(descriptor.oneofDecl[i]));\n    /* Fields */ if (descriptor.field)\n        for (i = 0; i < descriptor.field.length; ++i) {\n            var field = Field.fromDescriptor(descriptor.field[i], syntax);\n            type.add(field);\n            if (descriptor.field[i].hasOwnProperty(\"oneofIndex\")) // eslint-disable-line no-prototype-builtins\n                type.oneofsArray[descriptor.field[i].oneofIndex].add(field);\n        }\n    /* Extension fields */ if (descriptor.extension)\n        for (i = 0; i < descriptor.extension.length; ++i)\n            type.add(Field.fromDescriptor(descriptor.extension[i], syntax));\n    /* Nested types */ if (descriptor.nestedType)\n        for (i = 0; i < descriptor.nestedType.length; ++i) {\n            type.add(Type.fromDescriptor(descriptor.nestedType[i], syntax));\n            if (descriptor.nestedType[i].options && descriptor.nestedType[i].options.mapEntry)\n                type.setOption(\"map_entry\", true);\n        }\n    /* Nested enums */ if (descriptor.enumType)\n        for (i = 0; i < descriptor.enumType.length; ++i)\n            type.add(Enum.fromDescriptor(descriptor.enumType[i]));\n    /* Extension ranges */ if (descriptor.extensionRange && descriptor.extensionRange.length) {\n        type.extensions = [];\n        for (i = 0; i < descriptor.extensionRange.length; ++i)\n            type.extensions.push([ descriptor.extensionRange[i].start, descriptor.extensionRange[i].end ]);\n    }\n    /* Reserved... */ if (descriptor.reservedRange && descriptor.reservedRange.length || descriptor.reservedName && descriptor.reservedName.length) {\n        type.reserved = [];\n        /* Ranges */ if (descriptor.reservedRange)\n            for (i = 0; i < descriptor.reservedRange.length; ++i)\n                type.reserved.push([ descriptor.reservedRange[i].start, descriptor.reservedRange[i].end ]);\n        /* Names */ if (descriptor.reservedName)\n            for (i = 0; i < descriptor.reservedName.length; ++i)\n                type.reserved.push(descriptor.reservedName[i]);\n    }\n\n    return type;\n};\n\n/**\n * Converts a type to a descriptor.\n * @returns {Message<IDescriptorProto>} Descriptor\n * @param {string} [syntax=\"proto2\"] Syntax\n */\nType.prototype.toDescriptor = function toDescriptor(syntax) {\n    var descriptor = exports.DescriptorProto.create({ name: this.name }),\n        i;\n\n    /* Fields */ for (i = 0; i < this.fieldsArray.length; ++i) {\n        var fieldDescriptor;\n        descriptor.field.push(fieldDescriptor = this._fieldsArray[i].toDescriptor(syntax));\n        if (this._fieldsArray[i] instanceof MapField) { // map fields are repeated FieldNameEntry\n            var keyType = toDescriptorType(this._fieldsArray[i].keyType, this._fieldsArray[i].resolvedKeyType),\n                valueType = toDescriptorType(this._fieldsArray[i].type, this._fieldsArray[i].resolvedType),\n                valueTypeName = valueType === /* type */ 11 || valueType === /* enum */ 14\n                    ? this._fieldsArray[i].resolvedType && shortname(this.parent, this._fieldsArray[i].resolvedType) || this._fieldsArray[i].type\n                    : undefined;\n            descriptor.nestedType.push(exports.DescriptorProto.create({\n                name: fieldDescriptor.typeName,\n                field: [\n                    exports.FieldDescriptorProto.create({ name: \"key\", number: 1, label: 1, type: keyType }), // can't reference a type or enum\n                    exports.FieldDescriptorProto.create({ name: \"value\", number: 2, label: 1, type: valueType, typeName: valueTypeName })\n                ],\n                options: exports.MessageOptions.create({ mapEntry: true })\n            }));\n        }\n    }\n    /* Oneofs */ for (i = 0; i < this.oneofsArray.length; ++i)\n        descriptor.oneofDecl.push(this._oneofsArray[i].toDescriptor());\n    /* Nested... */ for (i = 0; i < this.nestedArray.length; ++i) {\n        /* Extension fields */ if (this._nestedArray[i] instanceof Field)\n            descriptor.field.push(this._nestedArray[i].toDescriptor(syntax));\n        /* Types */ else if (this._nestedArray[i] instanceof Type)\n            descriptor.nestedType.push(this._nestedArray[i].toDescriptor(syntax));\n        /* Enums */ else if (this._nestedArray[i] instanceof Enum)\n            descriptor.enumType.push(this._nestedArray[i].toDescriptor());\n        // plain nested namespaces become packages instead in Root#toDescriptor\n    }\n    /* Extension ranges */ if (this.extensions)\n        for (i = 0; i < this.extensions.length; ++i)\n            descriptor.extensionRange.push(exports.DescriptorProto.ExtensionRange.create({ start: this.extensions[i][0], end: this.extensions[i][1] }));\n    /* Reserved... */ if (this.reserved)\n        for (i = 0; i < this.reserved.length; ++i)\n            /* Names */ if (typeof this.reserved[i] === \"string\")\n                descriptor.reservedName.push(this.reserved[i]);\n            /* Ranges */ else\n                descriptor.reservedRange.push(exports.DescriptorProto.ReservedRange.create({ start: this.reserved[i][0], end: this.reserved[i][1] }));\n\n    descriptor.options = toDescriptorOptions(this.options, exports.MessageOptions);\n\n    return descriptor;\n};\n\n// --- Field ---\n\n/**\n * Properties of a FieldDescriptorProto message.\n * @interface IFieldDescriptorProto\n * @property {string} [name] Field name\n * @property {number} [number] Field id\n * @property {IFieldDescriptorProtoLabel} [label] Field rule\n * @property {IFieldDescriptorProtoType} [type] Field basic type\n * @property {string} [typeName] Field type name\n * @property {string} [extendee] Extended type name\n * @property {string} [defaultValue] Literal default value\n * @property {number} [oneofIndex] Oneof index if part of a oneof\n * @property {*} [jsonName] Not supported\n * @property {IFieldOptions} [options] Field options\n */\n\n/**\n * Values of the FieldDescriptorProto.Label enum.\n * @typedef IFieldDescriptorProtoLabel\n * @type {number}\n * @property {number} LABEL_OPTIONAL=1\n * @property {number} LABEL_REQUIRED=2\n * @property {number} LABEL_REPEATED=3\n */\n\n/**\n * Values of the FieldDescriptorProto.Type enum.\n * @typedef IFieldDescriptorProtoType\n * @type {number}\n * @property {number} TYPE_DOUBLE=1\n * @property {number} TYPE_FLOAT=2\n * @property {number} TYPE_INT64=3\n * @property {number} TYPE_UINT64=4\n * @property {number} TYPE_INT32=5\n * @property {number} TYPE_FIXED64=6\n * @property {number} TYPE_FIXED32=7\n * @property {number} TYPE_BOOL=8\n * @property {number} TYPE_STRING=9\n * @property {number} TYPE_GROUP=10\n * @property {number} TYPE_MESSAGE=11\n * @property {number} TYPE_BYTES=12\n * @property {number} TYPE_UINT32=13\n * @property {number} TYPE_ENUM=14\n * @property {number} TYPE_SFIXED32=15\n * @property {number} TYPE_SFIXED64=16\n * @property {number} TYPE_SINT32=17\n * @property {number} TYPE_SINT64=18\n */\n\n/**\n * Properties of a FieldOptions message.\n * @interface IFieldOptions\n * @property {boolean} [packed] Whether packed or not (defaults to `false` for proto2 and `true` for proto3)\n * @property {IFieldOptionsJSType} [jstype] JavaScript value type (not used by protobuf.js)\n */\n\n/**\n * Values of the FieldOptions.JSType enum.\n * @typedef IFieldOptionsJSType\n * @type {number}\n * @property {number} JS_NORMAL=0\n * @property {number} JS_STRING=1\n * @property {number} JS_NUMBER=2\n */\n\n// copied here from parse.js\nvar numberRe = /^(?![eE])[0-9]*(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/;\n\n/**\n * Creates a field from a descriptor.\n * @param {IFieldDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @param {string} [syntax=\"proto2\"] Syntax\n * @returns {Field} Field instance\n */\nField.fromDescriptor = function fromDescriptor(descriptor, syntax) {\n\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\")\n        descriptor = exports.DescriptorProto.decode(descriptor);\n\n    if (typeof descriptor.number !== \"number\")\n        throw Error(\"missing field id\");\n\n    // Rewire field type\n    var fieldType;\n    if (descriptor.typeName && descriptor.typeName.length)\n        fieldType = descriptor.typeName;\n    else\n        fieldType = fromDescriptorType(descriptor.type);\n\n    // Rewire field rule\n    var fieldRule;\n    switch (descriptor.label) {\n        // 0 is reserved for errors\n        case 1: fieldRule = undefined; break;\n        case 2: fieldRule = \"required\"; break;\n        case 3: fieldRule = \"repeated\"; break;\n        default: throw Error(\"illegal label: \" + descriptor.label);\n    }\n\n\tvar extendee = descriptor.extendee;\n\tif (descriptor.extendee !== undefined) {\n\t\textendee = extendee.length ? extendee : undefined;\n\t}\n    var field = new Field(\n        descriptor.name.length ? descriptor.name : \"field\" + descriptor.number,\n        descriptor.number,\n        fieldType,\n        fieldRule,\n        extendee\n    );\n\n    field.options = fromDescriptorOptions(descriptor.options, exports.FieldOptions);\n\n    if (descriptor.defaultValue && descriptor.defaultValue.length) {\n        var defaultValue = descriptor.defaultValue;\n        switch (defaultValue) {\n            case \"true\": case \"TRUE\":\n                defaultValue = true;\n                break;\n            case \"false\": case \"FALSE\":\n                defaultValue = false;\n                break;\n            default:\n                var match = numberRe.exec(defaultValue);\n                if (match)\n                    defaultValue = parseInt(defaultValue); // eslint-disable-line radix\n                break;\n        }\n        field.setOption(\"default\", defaultValue);\n    }\n\n    if (packableDescriptorType(descriptor.type)) {\n        if (syntax === \"proto3\") { // defaults to packed=true (internal preset is packed=true)\n            if (descriptor.options && !descriptor.options.packed)\n                field.setOption(\"packed\", false);\n        } else if (!(descriptor.options && descriptor.options.packed)) // defaults to packed=false\n            field.setOption(\"packed\", false);\n    }\n\n    return field;\n};\n\n/**\n * Converts a field to a descriptor.\n * @returns {Message<IFieldDescriptorProto>} Descriptor\n * @param {string} [syntax=\"proto2\"] Syntax\n */\nField.prototype.toDescriptor = function toDescriptor(syntax) {\n    var descriptor = exports.FieldDescriptorProto.create({ name: this.name, number: this.id });\n\n    if (this.map) {\n\n        descriptor.type = 11; // message\n        descriptor.typeName = $protobuf.util.ucFirst(this.name); // fieldName -> FieldNameEntry (built in Type#toDescriptor)\n        descriptor.label = 3; // repeated\n\n    } else {\n\n        // Rewire field type\n        switch (descriptor.type = toDescriptorType(this.type, this.resolve().resolvedType)) {\n            case 10: // group\n            case 11: // type\n            case 14: // enum\n                descriptor.typeName = this.resolvedType ? shortname(this.parent, this.resolvedType) : this.type;\n                break;\n        }\n\n        // Rewire field rule\n        switch (this.rule) {\n            case \"repeated\": descriptor.label = 3; break;\n            case \"required\": descriptor.label = 2; break;\n            default: descriptor.label = 1; break;\n        }\n\n    }\n\n    // Handle extension field\n    descriptor.extendee = this.extensionField ? this.extensionField.parent.fullName : this.extend;\n\n    // Handle part of oneof\n    if (this.partOf)\n        if ((descriptor.oneofIndex = this.parent.oneofsArray.indexOf(this.partOf)) < 0)\n            throw Error(\"missing oneof\");\n\n    if (this.options) {\n        descriptor.options = toDescriptorOptions(this.options, exports.FieldOptions);\n        if (this.options[\"default\"] != null)\n            descriptor.defaultValue = String(this.options[\"default\"]);\n    }\n\n    if (syntax === \"proto3\") { // defaults to packed=true\n        if (!this.packed)\n            (descriptor.options || (descriptor.options = exports.FieldOptions.create())).packed = false;\n    } else if (this.packed) // defaults to packed=false\n        (descriptor.options || (descriptor.options = exports.FieldOptions.create())).packed = true;\n\n    return descriptor;\n};\n\n// --- Enum ---\n\n/**\n * Properties of an EnumDescriptorProto message.\n * @interface IEnumDescriptorProto\n * @property {string} [name] Enum name\n * @property {IEnumValueDescriptorProto[]} [value] Enum values\n * @property {IEnumOptions} [options] Enum options\n */\n\n/**\n * Properties of an EnumValueDescriptorProto message.\n * @interface IEnumValueDescriptorProto\n * @property {string} [name] Name\n * @property {number} [number] Value\n * @property {*} [options] Not supported\n */\n\n/**\n * Properties of an EnumOptions message.\n * @interface IEnumOptions\n * @property {boolean} [allowAlias] Whether aliases are allowed\n * @property {boolean} [deprecated]\n */\n\nvar unnamedEnumIndex = 0;\n\n/**\n * Creates an enum from a descriptor.\n * @param {IEnumDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @returns {Enum} Enum instance\n */\nEnum.fromDescriptor = function fromDescriptor(descriptor) {\n\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\")\n        descriptor = exports.EnumDescriptorProto.decode(descriptor);\n\n    // Construct values object\n    var values = {};\n    if (descriptor.value)\n        for (var i = 0; i < descriptor.value.length; ++i) {\n            var name  = descriptor.value[i].name,\n                value = descriptor.value[i].number || 0;\n            values[name && name.length ? name : \"NAME\" + value] = value;\n        }\n\n    return new Enum(\n        descriptor.name && descriptor.name.length ? descriptor.name : \"Enum\" + unnamedEnumIndex++,\n        values,\n        fromDescriptorOptions(descriptor.options, exports.EnumOptions)\n    );\n};\n\n/**\n * Converts an enum to a descriptor.\n * @returns {Message<IEnumDescriptorProto>} Descriptor\n */\nEnum.prototype.toDescriptor = function toDescriptor() {\n\n    // Values\n    var values = [];\n    for (var i = 0, ks = Object.keys(this.values); i < ks.length; ++i)\n        values.push(exports.EnumValueDescriptorProto.create({ name: ks[i], number: this.values[ks[i]] }));\n\n    return exports.EnumDescriptorProto.create({\n        name: this.name,\n        value: values,\n        options: toDescriptorOptions(this.options, exports.EnumOptions)\n    });\n};\n\n// --- OneOf ---\n\n/**\n * Properties of a OneofDescriptorProto message.\n * @interface IOneofDescriptorProto\n * @property {string} [name] Oneof name\n * @property {*} [options] Not supported\n */\n\nvar unnamedOneofIndex = 0;\n\n/**\n * Creates a oneof from a descriptor.\n * @param {IOneofDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @returns {OneOf} OneOf instance\n */\nOneOf.fromDescriptor = function fromDescriptor(descriptor) {\n\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\")\n        descriptor = exports.OneofDescriptorProto.decode(descriptor);\n\n    return new OneOf(\n        // unnamedOneOfIndex is global, not per type, because we have no ref to a type here\n        descriptor.name && descriptor.name.length ? descriptor.name : \"oneof\" + unnamedOneofIndex++\n        // fromDescriptorOptions(descriptor.options, exports.OneofOptions) - only uninterpreted_option\n    );\n};\n\n/**\n * Converts a oneof to a descriptor.\n * @returns {Message<IOneofDescriptorProto>} Descriptor\n */\nOneOf.prototype.toDescriptor = function toDescriptor() {\n    return exports.OneofDescriptorProto.create({\n        name: this.name\n        // options: toDescriptorOptions(this.options, exports.OneofOptions) - only uninterpreted_option\n    });\n};\n\n// --- Service ---\n\n/**\n * Properties of a ServiceDescriptorProto message.\n * @interface IServiceDescriptorProto\n * @property {string} [name] Service name\n * @property {IMethodDescriptorProto[]} [method] Methods\n * @property {IServiceOptions} [options] Options\n */\n\n/**\n * Properties of a ServiceOptions message.\n * @interface IServiceOptions\n * @property {boolean} [deprecated]\n */\n\nvar unnamedServiceIndex = 0;\n\n/**\n * Creates a service from a descriptor.\n * @param {IServiceDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @returns {Service} Service instance\n */\nService.fromDescriptor = function fromDescriptor(descriptor) {\n\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\")\n        descriptor = exports.ServiceDescriptorProto.decode(descriptor);\n\n    var service = new Service(descriptor.name && descriptor.name.length ? descriptor.name : \"Service\" + unnamedServiceIndex++, fromDescriptorOptions(descriptor.options, exports.ServiceOptions));\n    if (descriptor.method)\n        for (var i = 0; i < descriptor.method.length; ++i)\n            service.add(Method.fromDescriptor(descriptor.method[i]));\n\n    return service;\n};\n\n/**\n * Converts a service to a descriptor.\n * @returns {Message<IServiceDescriptorProto>} Descriptor\n */\nService.prototype.toDescriptor = function toDescriptor() {\n\n    // Methods\n    var methods = [];\n    for (var i = 0; i < this.methodsArray.length; ++i)\n        methods.push(this._methodsArray[i].toDescriptor());\n\n    return exports.ServiceDescriptorProto.create({\n        name: this.name,\n        method: methods,\n        options: toDescriptorOptions(this.options, exports.ServiceOptions)\n    });\n};\n\n// --- Method ---\n\n/**\n * Properties of a MethodDescriptorProto message.\n * @interface IMethodDescriptorProto\n * @property {string} [name] Method name\n * @property {string} [inputType] Request type name\n * @property {string} [outputType] Response type name\n * @property {IMethodOptions} [options] Not supported\n * @property {boolean} [clientStreaming=false] Whether requests are streamed\n * @property {boolean} [serverStreaming=false] Whether responses are streamed\n */\n\n/**\n * Properties of a MethodOptions message.\n * @interface IMethodOptions\n * @property {boolean} [deprecated]\n */\n\nvar unnamedMethodIndex = 0;\n\n/**\n * Creates a method from a descriptor.\n * @param {IMethodDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @returns {Method} Reflected method instance\n */\nMethod.fromDescriptor = function fromDescriptor(descriptor) {\n\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\")\n        descriptor = exports.MethodDescriptorProto.decode(descriptor);\n\n    return new Method(\n        // unnamedMethodIndex is global, not per service, because we have no ref to a service here\n        descriptor.name && descriptor.name.length ? descriptor.name : \"Method\" + unnamedMethodIndex++,\n        \"rpc\",\n        descriptor.inputType,\n        descriptor.outputType,\n        Boolean(descriptor.clientStreaming),\n        Boolean(descriptor.serverStreaming),\n        fromDescriptorOptions(descriptor.options, exports.MethodOptions)\n    );\n};\n\n/**\n * Converts a method to a descriptor.\n * @returns {Message<IMethodDescriptorProto>} Descriptor\n */\nMethod.prototype.toDescriptor = function toDescriptor() {\n    return exports.MethodDescriptorProto.create({\n        name: this.name,\n        inputType: this.resolvedRequestType ? this.resolvedRequestType.fullName : this.requestType,\n        outputType: this.resolvedResponseType ? this.resolvedResponseType.fullName : this.responseType,\n        clientStreaming: this.requestStream,\n        serverStreaming: this.responseStream,\n        options: toDescriptorOptions(this.options, exports.MethodOptions)\n    });\n};\n\n// --- utility ---\n\n// Converts a descriptor type to a protobuf.js basic type\nfunction fromDescriptorType(type) {\n    switch (type) {\n        // 0 is reserved for errors\n        case 1: return \"double\";\n        case 2: return \"float\";\n        case 3: return \"int64\";\n        case 4: return \"uint64\";\n        case 5: return \"int32\";\n        case 6: return \"fixed64\";\n        case 7: return \"fixed32\";\n        case 8: return \"bool\";\n        case 9: return \"string\";\n        case 12: return \"bytes\";\n        case 13: return \"uint32\";\n        case 15: return \"sfixed32\";\n        case 16: return \"sfixed64\";\n        case 17: return \"sint32\";\n        case 18: return \"sint64\";\n    }\n    throw Error(\"illegal type: \" + type);\n}\n\n// Tests if a descriptor type is packable\nfunction packableDescriptorType(type) {\n    switch (type) {\n        case 1: // double\n        case 2: // float\n        case 3: // int64\n        case 4: // uint64\n        case 5: // int32\n        case 6: // fixed64\n        case 7: // fixed32\n        case 8: // bool\n        case 13: // uint32\n        case 14: // enum (!)\n        case 15: // sfixed32\n        case 16: // sfixed64\n        case 17: // sint32\n        case 18: // sint64\n            return true;\n    }\n    return false;\n}\n\n// Converts a protobuf.js basic type to a descriptor type\nfunction toDescriptorType(type, resolvedType) {\n    switch (type) {\n        // 0 is reserved for errors\n        case \"double\": return 1;\n        case \"float\": return 2;\n        case \"int64\": return 3;\n        case \"uint64\": return 4;\n        case \"int32\": return 5;\n        case \"fixed64\": return 6;\n        case \"fixed32\": return 7;\n        case \"bool\": return 8;\n        case \"string\": return 9;\n        case \"bytes\": return 12;\n        case \"uint32\": return 13;\n        case \"sfixed32\": return 15;\n        case \"sfixed64\": return 16;\n        case \"sint32\": return 17;\n        case \"sint64\": return 18;\n    }\n    if (resolvedType instanceof Enum)\n        return 14;\n    if (resolvedType instanceof Type)\n        return resolvedType.group ? 10 : 11;\n    throw Error(\"illegal type: \" + type);\n}\n\n// Converts descriptor options to an options object\nfunction fromDescriptorOptions(options, type) {\n    if (!options)\n        return undefined;\n    var out = [];\n    for (var i = 0, field, key, val; i < type.fieldsArray.length; ++i)\n        if ((key = (field = type._fieldsArray[i]).name) !== \"uninterpretedOption\")\n            if (options.hasOwnProperty(key)) { // eslint-disable-line no-prototype-builtins\n                val = options[key];\n                if (field.resolvedType instanceof Enum && typeof val === \"number\" && field.resolvedType.valuesById[val] !== undefined)\n                    val = field.resolvedType.valuesById[val];\n                out.push(underScore(key), val);\n            }\n    return out.length ? $protobuf.util.toObject(out) : undefined;\n}\n\n// Converts an options object to descriptor options\nfunction toDescriptorOptions(options, type) {\n    if (!options)\n        return undefined;\n    var out = [];\n    for (var i = 0, ks = Object.keys(options), key, val; i < ks.length; ++i) {\n        val = options[key = ks[i]];\n        if (key === \"default\")\n            continue;\n        var field = type.fields[key];\n        if (!field && !(field = type.fields[key = $protobuf.util.camelCase(key)]))\n            continue;\n        out.push(key, val);\n    }\n    return out.length ? type.fromObject($protobuf.util.toObject(out)) : undefined;\n}\n\n// Calculates the shortest relative path from `from` to `to`.\nfunction shortname(from, to) {\n    var fromPath = from.fullName.split(\".\"),\n        toPath = to.fullName.split(\".\"),\n        i = 0,\n        j = 0,\n        k = toPath.length - 1;\n    if (!(from instanceof Root) && to instanceof Namespace)\n        while (i < fromPath.length && j < k && fromPath[i] === toPath[j]) {\n            var other = to.lookup(fromPath[i++], true);\n            if (other !== null && other !== to)\n                break;\n            ++j;\n        }\n    else\n        for (; i < fromPath.length && j < k && fromPath[i] === toPath[j]; ++i, ++j);\n    return toPath.slice(j).join(\".\");\n}\n\n// copied here from cli/targets/proto.js\nfunction underScore(str) {\n    return str.substring(0,1)\n         + str.substring(1)\n               .replace(/([A-Z])(?=[a-z]|$)/g, function($0, $1) { return \"_\" + $1.toLowerCase(); });\n}\n\n// --- exports ---\n\n/**\n * Reflected file descriptor set.\n * @name FileDescriptorSet\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected file descriptor proto.\n * @name FileDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected descriptor proto.\n * @name DescriptorProto\n * @type {Type}\n * @property {Type} ExtensionRange\n * @property {Type} ReservedRange\n * @const\n * @tstype $protobuf.Type & {\n *     ExtensionRange: $protobuf.Type,\n *     ReservedRange: $protobuf.Type\n * }\n */\n\n/**\n * Reflected field descriptor proto.\n * @name FieldDescriptorProto\n * @type {Type}\n * @property {Enum} Label\n * @property {Enum} Type\n * @const\n * @tstype $protobuf.Type & {\n *     Label: $protobuf.Enum,\n *     Type: $protobuf.Enum\n * }\n */\n\n/**\n * Reflected oneof descriptor proto.\n * @name OneofDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected enum descriptor proto.\n * @name EnumDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected service descriptor proto.\n * @name ServiceDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected enum value descriptor proto.\n * @name EnumValueDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected method descriptor proto.\n * @name MethodDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected file options.\n * @name FileOptions\n * @type {Type}\n * @property {Enum} OptimizeMode\n * @const\n * @tstype $protobuf.Type & {\n *     OptimizeMode: $protobuf.Enum\n * }\n */\n\n/**\n * Reflected message options.\n * @name MessageOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected field options.\n * @name FieldOptions\n * @type {Type}\n * @property {Enum} CType\n * @property {Enum} JSType\n * @const\n * @tstype $protobuf.Type & {\n *     CType: $protobuf.Enum,\n *     JSType: $protobuf.Enum\n * }\n */\n\n/**\n * Reflected oneof options.\n * @name OneofOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected enum options.\n * @name EnumOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected enum value options.\n * @name EnumValueOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected service options.\n * @name ServiceOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected method options.\n * @name MethodOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */\n\n/**\n * Reflected uninterpretet option.\n * @name UninterpretedOption\n * @type {Type}\n * @property {Type} NamePart\n * @const\n * @tstype $protobuf.Type & {\n *     NamePart: $protobuf.Type\n * }\n */\n\n/**\n * Reflected source code info.\n * @name SourceCodeInfo\n * @type {Type}\n * @property {Type} Location\n * @const\n * @tstype $protobuf.Type & {\n *     Location: $protobuf.Type\n * }\n */\n\n/**\n * Reflected generated code info.\n * @name GeneratedCodeInfo\n * @type {Type}\n * @property {Type} Annotation\n * @const\n * @tstype $protobuf.Type & {\n *     Annotation: $protobuf.Type\n * }\n */\n"],"mappings":"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AAIH,QAAQ,CAACxI,CAAC,CAAC,KAAK0I,MAAM,CAAC3I,CAAC,CAAC,EAAE,EAAEC,CAAC,EAAE,EAAED,CAAC,CAAC;EAC/E,OAAO2I,MAAM,CAACG,KAAK,CAAC9I,CAAC,CAAC,CAAC+I,IAAI,CAAC,GAAG,CAAC;AACpC;;AAEA;AACA,SAASb,UAAU,CAACc,GAAG,EAAE;EACrB,OAAOA,GAAG,CAACnH,SAAS,CAAC,CAAC,EAAC,CAAC,CAAC,GAClBmH,GAAG,CAACnH,SAAS,CAAC,CAAC,CAAC,CACXC,OAAO,CAAC,qBAAqB,EAAE,UAASmH,EAAE,EAAEC,EAAE,EAAE;IAAE,OAAO,GAAG,GAAGA,EAAE,CAACC,WAAW,EAAE;EAAE,CAAC,CAAC;AACnG;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"script","externalDependencies":[]}